{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>deltalake</code> is an open source library that makes working with tabular datasets easier, more robust and more performant. With deltalake you can add, remove or update rows in a dataset as new data arrives. You can time travel back to earlier versions of a dataset. You can optimize dataset storage from small files to large files. </p> <p><code>deltalake</code> can be used to manage data stored on a local file system or in the cloud. <code>deltalake</code> integrates with data manipulation libraries such as Pandas, Polars, DuckDB and DataFusion.</p> <p><code>deltalake</code> uses a lakehouse framework for managing datasets. With this lakehouse approach you manage your datasets with a <code>DeltaTable</code> object and then <code>deltalake</code> takes care of the underlying files. Within a <code>DeltaTable</code> your data is stored in high performance Parquet files while metadata is stored in a set of JSON files called a transaction log.</p> <p><code>deltalake</code> is a Rust-based re-implementation of the DeltaLake protocol originally developed at DataBricks. The <code>deltalake</code> library has APIs in Rust and Python. The <code>deltalake</code> implementation has no dependencies on Java, Spark or DataBricks.</p>"},{"location":"#important-terminology","title":"Important terminology","text":"<ul> <li><code>deltalake</code> refers to the Rust or Python API of delta-rs</li> <li>\"Delta Spark\" refers to the Scala implementation of the Delta Lake transaction log protocol.  This depends on Spark and Java.</li> </ul>"},{"location":"#why-implement-the-delta-lake-transaction-log-protocol-in-rust","title":"Why implement the Delta Lake transaction log protocol in Rust?","text":"<p>Delta Spark depends on Java and Spark, which is fine for many use cases, but not all Delta Lake users want to depend on these libraries.  <code>deltalake</code> allows you to manage your dataset using a Delta Lake approach without any Java or Spark dependencies.</p> <p>A <code>DeltaTable</code> on disk is simply a directory that stores metadata in JSON files and data in Parquet files.  </p>"},{"location":"#quick-start","title":"Quick start","text":"<p>You can install <code>deltalake</code> in Python with <code>pip</code> <pre><code>pip install deltalake\n</code></pre> We create a Pandas <code>DataFrame</code> and write it to a <code>DeltaTable</code>: <pre><code>import pandas as pd\nfrom deltalake import DeltaTable,write_deltalake\n\ndf = pd.DataFrame(\n    {\n        \"id\": [1, 2, 3],\n        \"name\": [\"Aadhya\", \"Bob\", \"Chen\"],\n    }\n)\n\n(\n    write_deltalake(\n        table_or_uri=\"delta_table_dir\",\n        data=df,\n    )\n)\n</code></pre> We create a <code>DeltaTable</code> object that holds the metadata for the Delta table: <pre><code>dt = DeltaTable(\"delta_table_dir\")\n</code></pre> We load the <code>DeltaTable</code> into a Pandas <code>DataFrame</code> with <code>to_pandas</code> on a <code>DeltaTable</code>: <pre><code>new_df = dt.to_pandas()\n</code></pre></p> <p>Or we can load the data into a Polars <code>DataFrame</code> with <code>pl.read_delta</code>: <pre><code>import polars as pl\nnew_df = pl.read_delta(\"delta_table_dir\")\n</code></pre></p> <p>Or we can load the data with DuckDB: <pre><code>import duckdb\nduckdb.query(\"SELECT * FROM delta_scan('./delta_table_dir')\")\n</code></pre></p> <p>Or we can load the data with DataFusion: <pre><code>from datafusion import SessionContext\n\nctx = SessionContext()\nctx.register_dataset(\"my_delta_table\", dt.to_pyarrow_dataset())\nctx.sql(\"select * from my_delta_table\")\n</code></pre></p>"},{"location":"#contributing","title":"Contributing","text":"<p>The Delta Lake community welcomes contributors from all developers, regardless of your experience or programming background.</p> <p>You can write Rust code, Python code, documentation, submit bugs, or give talks to the community.  We welcome all of these contributions.</p> <p>Feel free to join our Slack and message us in the #delta-rs channel any time!</p> <p>We value kind communication and building a productive, friendly environment for maximum collaboration and fun.</p>"},{"location":"#project-history","title":"Project history","text":"<p>Check out this video by Denny Lee &amp; QP Hou to learn about the genesis of the delta-rs project:</p>"},{"location":"delta-lake-best-practices/","title":"Delta Lake Best Practices","text":"<p>This page outlines Delta Lake best practices.</p> <p>You should consider several factors to optimize the performance of your Delta tables and minimize costs.</p> <p>The Delta Lake best practices depend on your data ingestion into the Delta table and query patterns.  You must understand your data and how users run queries to best leverage Delta Lake.</p>"},{"location":"delta-lake-best-practices/#compacting-small-files","title":"Compacting small files","text":"<p>Delta tables work best when the files are \u201cright-sized\u201d.  Files that are too small create I/O overhead.  Files that are too large limit the impact of file skipping (a critical query optimization).</p> <p>Delta tables can accumulate a lot of small files, especially if you\u2019re frequently writing small amounts of data.  If your table has many small files, you should run a small compaction operation to consolidate all the tiny files into \u201cright-sized\u201d files.</p> <p>It\u2019s generally best for files in a Delta table to be between 100MB and 1GB, but that can vary based on the overall size of the table and the query patterns.</p> <p>Delta Lake makes it easy to compact the small files.</p>"},{"location":"delta-lake-best-practices/#optimizing-table-layout","title":"Optimizing table layout","text":"<p>You can colocate similar data in the same files to make file skipping more effective.  Delta Lake supports Z Ordering, which can colocate similar data in the same files.</p> <p>Z Ordering can yield impressive performance gains for low-cardinality columns but also works well for high-cardinality columns.  This is an advantage compared to Hive-style partitioning, which is only suitable for low-cardinality columns.</p> <p>You must analyze the most common query patterns and Z Order your dataset based on the columns allowing the most file skipping.  The ability to colocate data in the same files decreases when you add more Z Order columns.</p> <p>Let\u2019s look at Hive-style partitioning, another way to colocate data in the same files.  You can also use Hive-style partitioning in conjunction with Z Ordering.</p>"},{"location":"delta-lake-best-practices/#partitioning-datasets","title":"Partitioning datasets","text":"<p>You can partition your Delta tables, which separates the data by one or more partition keys into separate folders.  Partitioning can be an excellent performance optimization (when you filter on the partition key) and is a good way to sidestep concurrency conflict issues.</p> <p>Hive-style partitioning also has some significant downsides.</p> <ul> <li>It\u2019s only suitable for low-cardinality columns.</li> <li>It can create many small files, especially if you use the wrong partition key or frequently update the Delta table.</li> <li>It can cause some queries that don\u2019t rely on the partition key to run slower (because of the excessive number of small files).  A large number of small files is problematic for I/O throughput.</li> </ul> <p>Hive-style partitioning can be a great data management tactic and a fantastic option for many Delta tables.  Beware of the downsides before partitioning your tables.</p> <p>You can use Hive-style partitioning in conjunction with Z Ordering.  You can partition a table by one column and Z Order by another.  They\u2019re different tactics that aim to help you skip more files and run queries faster.</p> <p>Let\u2019s look at some of the built-in Delta features that help maintain the integrity of your tables.</p>"},{"location":"delta-lake-best-practices/#use-appropriate-quality-controls","title":"Use appropriate quality controls","text":"<p>Delta Lake supports schema enforcement and column constraints to protect the integrity of your data.</p> <p>Delta Lake enabled schema enforcement by default, so you can only append data to an existing table with the same exact schema.  You can bypass schema enforcement by enabling schema evolution, which allows you to append mismatched schemas to a table.</p> <p>You should only enable schema evolution when you want to allow the schema of your table to change.  You should not enable schema evolution if you don\u2019t want this flexibility.  Schema enforcement is a good default setting.</p> <p>Column-level constraints prevent you from appending data that fail SQL predicates.  For example, you may add a constraint that requires all the values in the <code>age</code> column of a table to be positive.</p> <p>You should add column constraints to your table whenever you want a column only to include values that satisfy a predicate.</p> <p>No data is appended when you apply a constraint and a row check fails.  For example, if you try to append 100 rows of data to a table and one row has a failing check, then no data is added.</p> <p>When you have column constraints, it\u2019s often a good idea to append the failing data to a \u201cquarantine table\u201d and the passing data to the main Delta table.  Or you can filter out the failing rows and just append the passing rows.  Keeping a history of the failing rows in a quarantine table is helpful for debugging.</p> <p>See here to learn more about Delta Lake constraints.</p>"},{"location":"delta-lake-best-practices/#best-practices-for-dml-operations","title":"Best practices for DML operations","text":"<p>DML operations like deleting, updating, and merging write existing data in new files and mark existing files for deletion in the transaction log.  Rewriting data files is expensive, so you want to minimize the number of rewritten files when you run DML operations.</p> <p>Delta Lake supports a table feature called deletion vectors that implements DML transactions more efficiently under the hood.  Enabling deletion vectors is usually the best way to make DML operations run faster.  Note: delta-rs doesn\u2019t support deletion vectors yet.</p> <p>You should periodically purge deletion vectors because they can accumulate and slow subsequent read operations.  Once you enable the feature, you must purge the deletion vectors in your table with an appropriate cadence.</p>"},{"location":"delta-lake-best-practices/#use-vacuum-to-save-storage-costs","title":"Use vacuum to save storage costs","text":"<p>Delta Lake supports transactions, which necessitates keeping old versions of data in storage, even the files marked for removal in the transactions log.</p> <p>Keeping old versions of Delta tables in storage is often desirable because it allows for versioned data, time travel, and rolling back tables to a previous state.</p> <p>If you don\u2019t want to leverage older versions of a table, then you should remove the legacy files from storage with the vacuum command.  Vacuum will remove all files older than the table retention period and marked for removal in the transaction log.</p> <p>You only need to vacuum when you perform operations that mark files for removal in the transaction log.  An append-only table doesn\u2019t create legacy files that need to be vacuumed.</p> <p>Create a good vacuum strategy for your tables to minimize your storage costs.</p>"},{"location":"delta-lake-best-practices/#delta-lake-best-practices-to-minimize-costs","title":"Delta Lake best practices to minimize costs","text":"<p>Delta Lake helps you minimize costs in many ways:</p> <ul> <li>It's a free, open source format (based on Parquet). It's not a proprietary format that you need to pay for.</li> <li>Delta tables store column-level min/max values in the transaction log, allowing file skipping.</li> <li>Delta tables can be optimized (small file compaction, Z Ordering, etc.), so your queries run faster. When your queries run faster, then you pay less on compute.</li> <li>Deletion vectors let you perform DML operations (delete, update, merge) much faster. If your delete operation runs 100x faster, then you pay 100x less compute.</li> <li>It's easy to remove legacy files from storage with VACUUM, which minimizes storage costs.</li> </ul> <p>You should understand your organization\u2019s query patterns and use these features to minimize the overall cost.  You need to assess tradeoffs.  For example, Z Ordering is a computation that costs money, but it can save you lots of money in the long run if all your subsequent queries run a lot faster and use less compute.</p>"},{"location":"delta-lake-best-practices/#collect-metadata-stats-on-columns-used-for-file-skipping","title":"Collect metadata stats on columns used for file skipping","text":"<p>Delta tables don\u2019t always store each column's min/max values.  Some Delta Lake implementations only store min/max values for the first 32 columns in the table, for example.</p> <p>Delta Lake can only apply file-skipping when it has min/max values for the relevant columns stored in the transaction log.  Suppose you\u2019re running a filtering operation on <code>col_a,</code> for example.  Delta Lake can only apply file skipping when the transaction log stores <code>col_a</code> min/max metadata.</p> <p>Ensure the transaction log stores metadata stats for all the columns that benefit from file skipping.</p>"},{"location":"delta-lake-best-practices/#dont-collect-column-metadata-when-its-unnecessary","title":"Don\u2019t collect column metadata when it\u2019s unnecessary","text":"<p>It takes some time to compute column statistics when writing files, and it isn\u2019t worth the effort if you cannot use the column for file skipping.</p> <p>Suppose you have a table column containing a long string of arbitrary text.  It\u2019s unlikely that this column would ever provide any data-skipping benefits.  So, you can just avoid the overhead of collecting the statistics for this particular column.</p>"},{"location":"delta-lake-best-practices/#additional-reading","title":"Additional reading","text":"<p>Delta Lake relies on transactions, and you should check out this page to learn more.</p> <p>Many Delta Lake performance benefits rely on file skipping, which you should understand well to get the most out of Delta.</p>"},{"location":"delta-lake-best-practices/#conclusion","title":"Conclusion","text":"<p>Delta Lake is a powerful technology that makes your data pipelines more reliable, saves money, and makes everyday data processing tasks easy.</p> <p>You need to learn how Delta Lake works at a high level to leverage Delta's power fully.  You will not be able to leverage Delta Lake\u2019s full performance potential if your table has improperly sized files or if you\u2019re not colocating data in the same files to maximize data skipping, for example.</p> <p>Luckily, there are only a few details that are important to learn.  You don\u2019t need to know the implementation details - just the essential high-level concepts.</p>"},{"location":"delta-lake-big-data-small-data/","title":"Delta Lake for big data and small data","text":"<p>Delta Lake is an excellent storage format for big data and small data.</p> <p>This post explains why Delta Lake is suitable for massive datasets and why many of these features that are great, even for tiny tables.  Delta Lake is fine for a table with less than 1 GB of data or hundreds of petabytes of data.</p> <p>Let\u2019s start by discussing the features that are great for small data.</p>"},{"location":"delta-lake-big-data-small-data/#delta-lake-for-small-data-tables","title":"Delta Lake for small data tables","text":"<p>Delta Lake has many features that are useful for small datasets:</p> <ul> <li>Reliable transactions</li> <li>Better performance via file skipping</li> <li>DML operations to make deletes, updates, and merges easy and performant</li> <li>Features like schema enforcement and constraints to enforce data quality</li> <li>Versioned data &amp; time travel</li> </ul> <p>All of these features are great for large and small tables.</p> <p>Delta Lake DML operations are ACID transactions, so they either finish entirely or don\u2019t finish at all.  Delta tables don\u2019t require any downtime while DML operations are running.  The Delta Lake user experience is better than a data lake that doesn\u2019t support transactions and has downtime while running DML operations.</p> <p>The Delta Lake API also makes it easy to run DML operations.  You can delete a line of code from a Delta table with a single line of code.  Writing code to delete rows from CSV files is more challenging, especially if you want to implement this operation efficiently.</p> <p>Delta Lake has built-in checks to retain the integrity of your tables.  For example, Delta tables have schema enforcement and prevent you from appending DataFrames with mismatched schema from the existing table.  Delta Lake also lets you add constraints that only allow appending specific values to a column.  Data quality is also essential for small tables!</p> <p>Delta Lake splits data into multiple files with file-level metadata in the transaction log, so query engines can sometimes skip data.  Data skipping can be a huge performance benefit, depending on how much data can be ignored by the query engine.  </p> <p>As previously mentioned, Delta tables record all DML operations as transactions.  Recording operations as transactions means that existing data isn\u2019t mutated.  So Delta Lake provides versioned data and time travel out of the box.  Versioning data is better because it allows you to roll back mistakes and compare the state of the table at different points in time.</p> <p>Delta Lake has many useful features for small data tables.  Let\u2019s look at how Delta Lake is scalable for massive datasets.</p>"},{"location":"delta-lake-big-data-small-data/#delta-lake-for-large-data-tables","title":"Delta Lake for large data tables","text":"<p>Delta Lake is designed to be scalable and can handle tables with terabytes or petabytes of data.</p> <p>See here for an example of an organization ingesting 220 TB of data into a Delta table daily.</p> <p>Delta tables store data in Parquet files, and cloud object stores allow engines to write any number of files.  Delta tables store metadata information in the transaction log as JSON files, which are periodically compacted into Parquet files, so an arbitrarily large amount of Delta table metadata can also be stored.</p> <p>Delta Lake transactions and concurrency protection maintain the integrity of tables, even for large write operations or long-running computations.</p> <p>It\u2019s well known that Delta tables are scalable, even for the most enormous tables.</p>"},{"location":"delta-lake-big-data-small-data/#small-data-operations-on-large-tables","title":"Small data operations on large tables","text":"<p>Delta Lake is flexible and allows you to use \u201csmall data engines,\u201d even for large tables, depending on the computation.</p> <p>Suppose you have a Delta table containing 10 TB of data and a pipeline that appends 0.5 GB of data to the table every hour.  You don\u2019t need a big data query engine to append a small amount of data.  You can set up this job to run the Delta table append with a small data engine like pandas or Polars.</p> <p>Delta tables are flexible and interoperable with many technologies so that you can use the right tool for each data processing job.  This allows you to design pipelines how you\u2019d like and minimize costs.</p>"},{"location":"delta-lake-big-data-small-data/#when-delta-lake-isnt-needed","title":"When Delta Lake isn\u2019t needed","text":"<p>You don\u2019t need Delta Lake for a small dataset that never changes and can be stored in a single Parquet file.</p> <p>Suppose you have a 0.5 GB dataset in a Parquet file that never needs to be updated.  You can just keep that data in a Parquet table.  Reading the metadata from the Parquet footer of a single file isn\u2019t expensive.  You won\u2019t be taking advantage of Delta Lake's features like transactions, convenient DML operations, or versioned data.</p> <p>But in most cases, it\u2019s best to use Delta Lake because its features protect the integrity of your tables and make your life easier.</p>"},{"location":"delta-lake-big-data-small-data/#conclusion","title":"Conclusion","text":"<p>Delta Lake is well known for being scalable to huge tables but is also an excellent technology for small tables.</p> <p>Delta Lake is a lightweight technology, so there is little overhead.  Writing the metadata file after performing a transaction is fast.  It\u2019s a minuscule cost, considering the benefits you receive.</p> <p>Many reasons that make Delta Lake better than data lakes for large tables also apply to small tables!</p>"},{"location":"why-use-delta-lake/","title":"Why use Delta Lake","text":"<p>This page explains why Delta Lake is a better storage format for most tabular data analyses than data lake alternatives.</p> <p>Delta Lake provides developer-friendly features, reliable transactions, and fast performance compared with alternatives like Parquet or CSV.</p>"},{"location":"why-use-delta-lake/#fast-performance","title":"Fast performance","text":"<p>Delta tables store data in Parquet files and persist file-level metadata in the transaction log.</p> <p>This offers two main performance advantages:</p> <ul> <li>File skipping based on metadata that\u2019s quickly accessible</li> <li>Easy identification of all file paths for the table, compared to file listing operations that can be slow, especially on cloud object stores</li> </ul> <p>Delta Lake stores min/max values for each column of each file in the table.  Certain queries can skip entire files based on the metadata.  File skipping can be a massive performance optimization.</p> <p>Delta Lake also makes it easy to rearrange data in the table, so more file skipping is possible.  For example, the table can be partitioned or Z Ordered, so that similar data is colocated in the same files and data skipping is optimal for your query patterns.</p> <p>For data lakes, you need to run file listing operations to get the file paths before you can actually read the data.  Listing all the files in a data lake can take a long time, especially if there are a lot of files and they are stored in Hive-style partitions.</p> <p>Delta Lake stores all the file paths in the transaction log.  So you can quickly get the file paths directly from the log and then run your query.  Delta Lake also stores the file-level metadata in the transaction log which is quicker than opening all the files in the data lake and grabbing the metadata from the file footer.</p>"},{"location":"why-use-delta-lake/#developer-friendly-features","title":"Developer friendly features","text":"<p>Many basic data operations are hard in data lakes but quite easy with Delta Lake.  The only data operation that\u2019s easy with a data lake is appending data.  Delta Lake makes all data operations easy including the following:</p> <ul> <li>Appends</li> <li>Upserts</li> <li>Deletes</li> <li>Replace where</li> </ul> <p>Even deleting a few rows of data from a data lake is hard.  It\u2019s even harder if you want to run the operation in a performant manner.</p> <p>Delta Lake makes it easy to run common data operations and executes them performantly under the hood.</p> <p>Delta Lake also executes write operations as transactions, which makes data operations safer and prevents downtime.  Write operations will cause data lakes to be in an unstable state while the computations is running.  For example, if you read a data lake while a delete operation is running, then you may get the wrong data.</p> <p>Let\u2019s explore the benefits of reliable transactions in more detail.</p>"},{"location":"why-use-delta-lake/#reliable-transactions","title":"Reliable transactions","text":"<p>Delta Lake supports transactions which means that write operations have the following characteristics:</p> <ul> <li>They either finish completely or don\u2019t run at all</li> <li>They are executed in a serial manner and don\u2019t conflict with other transactions</li> <li>They don\u2019t corrupt a table or violate table constraints</li> </ul> <p>Data lakes don\u2019t support transactions, so the write operations can cause the following errors:</p> <ul> <li>There is no schema enforcement, so you can append data to a data lake with a mismatching schema</li> <li>Reading the data lake often yields incorrect results while write transactions are performed</li> <li>Data lakes can be corrupted for invalid write operations or computations that error-out</li> <li>Concurrent transactions that conflict can cause data loss</li> </ul> <p>Production data systems should rely on storage systems like Delta Lake that support transactions.</p>"},{"location":"why-use-delta-lake/#interoperability","title":"Interoperability","text":"<p>Delta Lake tables are interoperable and can be read/written by multiple different query engines.</p> <p>For example, you can create a Delta table with Spark, append to it with pandas, and then read it with Polars.</p> <p></p> <p>Delta tables are powerful because they are interoperable with various query engines and computation runtimes.</p> <p>Suppose you have a Delta table that\u2019s updated with an AWS Lambda function every 5 minutes.  There is only a small amount of data collected every 5 minutes, so a lightweight runtime like AWS Lambda is sufficient.</p> <p>Further suppose that the overall table is quite large.  So when you want to perform DML operations or query the whole table, your team uses a Spark cluster.</p> <p>Delta Lake is flexible to allow these types of operations from multiple readers and writers.  This provides teams with the flexibility to choose the right tool for the job.</p>"},{"location":"why-use-delta-lake/#support-for-many-languages","title":"Support for many languages","text":"<p>Delta tables can be queried with a variety of different languages.  This project provides APIs for Rust and Python users and does not depend on Java or Scala.  This project is a great alternative for pandas, Polars, DuckDB, or DataFusion.</p> <p>Delta Lake supports many languages and even more language support is coming soon!</p>"},{"location":"why-use-delta-lake/#support-on-multiple-clouds","title":"Support on multiple clouds","text":"<p>Delta Lake supports multiple clouds including GCP, AWS, and Azure.</p> <p>You can also use Delta Lake on your local machine or in an on-prem environment.</p> <p>Delta Lake is quite portable.</p>"},{"location":"why-use-delta-lake/#conclusion","title":"Conclusion","text":"<p>Delta Lake is a mature table format that offers users tons of advantages over a data lake with virtually no downsides.</p> <p>Once you start using Delta Lake, you will never want to go back to data lakes that expose you to a variety of dangerous bugs, poor performance, and reliability issues.</p> <p>The Delta Lake community is also welcome and open.  We gladly accept new contributors and help users with their questions.</p>"},{"location":"api/delta_writer/","title":"Writer","text":"","boost":10},{"location":"api/delta_writer/#write-to-delta-tables","title":"Write to Delta Tables","text":"","boost":10},{"location":"api/delta_writer/#deltalake.write_deltalake","title":"deltalake.write_deltalake","text":"<pre><code>write_deltalake(table_or_uri: str | Path | DeltaTable, data: ArrowStreamExportable | ArrowArrayExportable | Sequence[ArrowArrayExportable], *, partition_by: list[str] | str | None = None, mode: Literal['error', 'append', 'overwrite', 'ignore'] = 'error', name: str | None = None, description: str | None = None, configuration: Mapping[str, str | None] | None = None, schema_mode: Literal['merge', 'overwrite'] | None = None, storage_options: dict[str, str] | None = None, predicate: str | None = None, target_file_size: int | None = None, writer_properties: WriterProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None) -&gt; None\n</code></pre> <p>Write to a Delta Lake table</p> <p>If the table does not already exist, it will be created.</p> <p>Parameters:</p> Name Type Description Default <code>table_or_uri</code> <code>str | Path | DeltaTable</code> <p>URI of a table or a DeltaTable object.</p> required <code>data</code> <code>ArrowStreamExportable | ArrowArrayExportable | Sequence[ArrowArrayExportable]</code> <p>Data to write. If passing iterable, the schema must also be given.</p> required <code>partition_by</code> <code>list[str] | str | None</code> <p>List of columns to partition the table by. Only required when creating a new table.</p> <code>None</code> <code>mode</code> <code>Literal['error', 'append', 'overwrite', 'ignore']</code> <p>How to handle existing data. Default is to error if table already exists. If 'append', will add new data. If 'overwrite', will replace table with new data. If 'ignore', will not write anything if table already exists.</p> <code>'error'</code> <code>name</code> <code>str | None</code> <p>User-provided identifier for this table.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>User-provided description for this table.</p> <code>None</code> <code>configuration</code> <code>Mapping[str, str | None] | None</code> <p>A map containing configuration options for the metadata action.</p> <code>None</code> <code>schema_mode</code> <code>Literal['merge', 'overwrite'] | None</code> <p>If set to \"overwrite\", allows replacing the schema of the table. Set to \"merge\" to merge with existing schema.</p> <code>None</code> <code>storage_options</code> <code>dict[str, str] | None</code> <p>options passed to the native delta filesystem.</p> <code>None</code> <code>predicate</code> <code>str | None</code> <p>When using <code>Overwrite</code> mode, replace data that matches a predicate. Only used in rust engine.'</p> <code>None</code> <code>target_file_size</code> <code>int | None</code> <p>Override for target file size for data files written to the delta table. If not passed, it's taken from <code>delta.targetFileSize</code>.</p> <code>None</code> <code>writer_properties</code> <code>WriterProperties | None</code> <p>Pass writer properties to the Rust parquet writer.</p> <code>None</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code>","boost":10},{"location":"api/delta_writer/#deltalake.BloomFilterProperties","title":"deltalake.BloomFilterProperties  <code>dataclass</code>","text":"<pre><code>BloomFilterProperties(set_bloom_filter_enabled: bool | None, fpp: float | None = None, ndv: int | None = None)\n</code></pre> <p>The Bloom Filter Properties instance for the Rust parquet writer.</p> <p>Create a Bloom Filter Properties instance for the Rust parquet writer:</p> <p>Parameters:</p> Name Type Description Default <code>set_bloom_filter_enabled</code> <code>bool | None</code> <p>If True and no fpp or ndv are provided, the default values will be used.</p> required <code>fpp</code> <code>float | None</code> <p>The false positive probability for the bloom filter. Must be between 0 and 1 exclusive.</p> <code>None</code> <code>ndv</code> <code>int | None</code> <p>The number of distinct values for the bloom filter.</p> <code>None</code>","boost":10},{"location":"api/delta_writer/#deltalake.ColumnProperties","title":"deltalake.ColumnProperties  <code>dataclass</code>","text":"<pre><code>ColumnProperties(dictionary_enabled: bool | None = None, statistics_enabled: Literal['NONE', 'CHUNK', 'PAGE'] | None = None, bloom_filter_properties: BloomFilterProperties | None = None)\n</code></pre> <p>The Column Properties instance for the Rust parquet writer.</p> <p>Create a Column Properties instance for the Rust parquet writer:</p> <p>Parameters:</p> Name Type Description Default <code>dictionary_enabled</code> <code>bool | None</code> <p>Enable dictionary encoding for the column.</p> <code>None</code> <code>statistics_enabled</code> <code>Literal['NONE', 'CHUNK', 'PAGE'] | None</code> <p>Statistics level for the column.</p> <code>None</code> <code>bloom_filter_properties</code> <code>BloomFilterProperties | None</code> <p>Bloom Filter Properties for the column.</p> <code>None</code>","boost":10},{"location":"api/delta_writer/#deltalake.WriterProperties","title":"deltalake.WriterProperties  <code>dataclass</code>","text":"<pre><code>WriterProperties(data_page_size_limit: int | None = None, dictionary_page_size_limit: int | None = None, data_page_row_count_limit: int | None = None, write_batch_size: int | None = None, max_row_group_size: int | None = None, compression: Literal['UNCOMPRESSED', 'SNAPPY', 'GZIP', 'BROTLI', 'LZ4', 'ZSTD', 'LZ4_RAW'] | None = None, compression_level: int | None = None, statistics_truncate_length: int | None = None, default_column_properties: ColumnProperties | None = None, column_properties: dict[str, ColumnProperties] | None = None)\n</code></pre> <p>A Writer Properties instance for the Rust parquet writer.</p> <p>Create a Writer Properties instance for the Rust parquet writer:</p> <p>Parameters:</p> Name Type Description Default <code>data_page_size_limit</code> <code>int | None</code> <p>Limit DataPage size to this in bytes.</p> <code>None</code> <code>dictionary_page_size_limit</code> <code>int | None</code> <p>Limit the size of each DataPage to store dicts to this amount in bytes.</p> <code>None</code> <code>data_page_row_count_limit</code> <code>int | None</code> <p>Limit the number of rows in each DataPage.</p> <code>None</code> <code>write_batch_size</code> <code>int | None</code> <p>Splits internally to smaller batch size.</p> <code>None</code> <code>max_row_group_size</code> <code>int | None</code> <p>Max number of rows in row group.</p> <code>None</code> <code>compression</code> <code>Literal['UNCOMPRESSED', 'SNAPPY', 'GZIP', 'BROTLI', 'LZ4', 'ZSTD', 'LZ4_RAW'] | None</code> <p>compression type.</p> <code>None</code> <code>compression_level</code> <code>int | None</code> <p>If none and compression has a level, the default level will be used, only relevant for GZIP: levels (1-9), BROTLI: levels (1-11), ZSTD: levels (1-22),</p> <code>None</code> <code>statistics_truncate_length</code> <code>int | None</code> <p>maximum length of truncated min/max values in statistics.</p> <code>None</code> <code>default_column_properties</code> <code>ColumnProperties | None</code> <p>Default Column Properties for the Rust parquet writer.</p> <code>None</code> <code>column_properties</code> <code>dict[str, ColumnProperties] | None</code> <p>Column Properties for the Rust parquet writer.</p> <code>None</code>","boost":10},{"location":"api/delta_writer/#convert-to-delta-tables","title":"Convert to Delta Tables","text":"","boost":10},{"location":"api/delta_writer/#deltalake.convert_to_deltalake","title":"deltalake.convert_to_deltalake","text":"<pre><code>convert_to_deltalake(uri: str | Path, mode: Literal['error', 'ignore'] = 'error', partition_by: Schema | None = None, partition_strategy: Literal['hive'] | None = None, name: str | None = None, description: str | None = None, configuration: Mapping[str, str | None] | None = None, storage_options: dict[str, str] | None = None, commit_properties: CommitProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None) -&gt; None\n</code></pre> <p><code>Convert</code> parquet tables <code>to delta</code> tables.</p> <p>Currently only HIVE partitioned tables are supported. <code>Convert to delta</code> creates a transaction log commit with add actions, and additional properties provided such as configuration, name, and description.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str | Path</code> <p>URI of a table.</p> required <code>partition_by</code> <code>Schema | None</code> <p>Optional partitioning schema if table is partitioned.</p> <code>None</code> <code>partition_strategy</code> <code>Literal['hive'] | None</code> <p>Optional partition strategy to read and convert</p> <code>None</code> <code>mode</code> <code>Literal['error', 'ignore']</code> <p>How to handle existing data. Default is to error if table already exists. If 'ignore', will not convert anything if table already exists.</p> <code>'error'</code> <code>name</code> <code>str | None</code> <p>User-provided identifier for this table.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>User-provided description for this table.</p> <code>None</code> <code>configuration</code> <code>Mapping[str, str | None] | None</code> <p>A map containing configuration options for the metadata action.</p> <code>None</code> <code>storage_options</code> <code>dict[str, str] | None</code> <p>options passed to the native delta filesystem. Unused if 'filesystem' is defined.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code>","boost":10},{"location":"api/exceptions/","title":"Exceptions","text":"","boost":2},{"location":"api/exceptions/#deltalake.exceptions.DeltaError","title":"deltalake.exceptions.DeltaError","text":"<p>             Bases: <code>builtins.Exception</code></p> <p>The base class for Delta-specific errors.</p>","boost":2},{"location":"api/exceptions/#deltalake.exceptions.DeltaProtocolError","title":"deltalake.exceptions.DeltaProtocolError","text":"<p>             Bases: <code>_internal.DeltaError</code></p> <p>Raised when a violation with the Delta protocol specs occurred.</p>","boost":2},{"location":"api/exceptions/#deltalake.exceptions.TableNotFoundError","title":"deltalake.exceptions.TableNotFoundError","text":"<p>             Bases: <code>_internal.DeltaError</code></p> <p>Raised when a Delta table cannot be loaded from a location.</p>","boost":2},{"location":"api/exceptions/#deltalake.exceptions.CommitFailedError","title":"deltalake.exceptions.CommitFailedError","text":"<p>             Bases: <code>_internal.DeltaError</code></p> <p>Raised when a commit to a Delta table fails.</p>","boost":2},{"location":"api/exceptions/#deltalake.exceptions.SchemaMismatchError","title":"deltalake.exceptions.SchemaMismatchError","text":"<p>             Bases: <code>_internal.DeltaError</code></p> <p>Raised when a schema mismatch is detected.</p>","boost":2},{"location":"api/query/","title":"Query","text":""},{"location":"api/query/#deltalake.QueryBuilder","title":"deltalake.QueryBuilder","text":"<pre><code>QueryBuilder()\n</code></pre> <p>QueryBuilder is an API which exposes Apache DataFusion SQL to Python users of the deltalake library.</p> <p>qb = QueryBuilder()</p>"},{"location":"api/query/#deltalake.QueryBuilder.execute","title":"execute","text":"<pre><code>execute(sql: str) -&gt; RecordBatchReader\n</code></pre> <p>Prepares the sql query to be executed.</p> <p>For example: <pre><code>from deltalake import DeltaTable, QueryBuilder\ndt = DeltaTable(\"my_table\")\ndata = QueryBuilder().register('test', dt).execute(\"select * from my_table\").read_all()\n</code></pre></p>"},{"location":"api/query/#deltalake.QueryBuilder.register","title":"register","text":"<pre><code>register(table_name: str, delta_table: DeltaTable) -&gt; QueryBuilder\n</code></pre> <p>Add a table to the query builder instance by name. The <code>table_name</code> will be how the referenced <code>DeltaTable</code> can be referenced in SQL queries.</p> <p>For example:</p> <pre><code>from deltalake import DeltaTable, QueryBuilder\ndt = DeltaTable(\"my_table\")\nqb = QueryBuilder().register('test', dt)\n</code></pre>"},{"location":"api/schema/","title":"Schema","text":"","boost":2},{"location":"api/schema/#schema-and-field","title":"Schema and field","text":"<p>Schemas, fields, and data types are provided in the <code>deltalake.schema</code> submodule.</p>","boost":2},{"location":"api/schema/#deltalake.Schema","title":"deltalake.Schema","text":"<pre><code>Schema(fields: list[Field])\n</code></pre> <p>             Bases: <code>deltalake._internal.StructType</code></p> <p>A Delta Lake schema</p> <p>Create using a list of :class:<code>Field</code>:</p> <p>Schema([Field(\"x\", \"integer\"), Field(\"y\", \"string\")]) Schema([Field(x, PrimitiveType(\"integer\"), nullable=True), Field(y, PrimitiveType(\"string\"), nullable=True)])</p> <p>Or create from a PyArrow schema:</p> <p>from arro3.core import DateType, Schema as ArrowSchema Schema.from_pyarrow(ArrowSchema({\"x\": DateType.int32(), \"y\": DateType.string()})) Schema([Field(x, PrimitiveType(\"integer\"), nullable=True), Field(y, PrimitiveType(\"string\"), nullable=True)])</p>","boost":2},{"location":"api/schema/#deltalake.Schema.invariants","title":"invariants","text":"<pre><code>invariants: list[tuple[str, str]] = &lt;attribute 'invariants' of 'deltalake._internal.Schema' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.Schema.from_arrow","title":"from_arrow  <code>staticmethod</code>","text":"<pre><code>from_arrow(data_type) -&gt; Schema\n</code></pre> <p>Create a Schema from a schema that implements Arrow C Data Interface.</p> <p>Will raise <code>TypeError</code> if one of the Arrow type is not a primitive type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>ArrowSchemaExportable</code> <p>an object that is <code>ArrowSchemaExportable</code></p> required <p>Returns:</p> Type Description <code>Schema</code> <p>a Schema</p>","boost":2},{"location":"api/schema/#deltalake.Schema.from_json","title":"from_json  <code>staticmethod</code>","text":"<pre><code>from_json(schema_json) -&gt; Schema\n</code></pre> <p>Create a new Schema from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>str</code> <p>a JSON string</p> required Example <p>A schema has the same JSON format as a StructType. <pre><code>Schema.from_json('''{\n    \"type\": \"struct\",\n    \"fields\": [{\"name\": \"x\", \"type\": \"integer\", \"nullable\": true, \"metadata\": {}}]\n    }\n)'''\n# Returns Schema([Field(x, PrimitiveType(\"integer\"), nullable=True)])\n</code></pre></p>","boost":2},{"location":"api/schema/#deltalake.Schema.to_arrow","title":"to_arrow  <code>method descriptor</code>","text":"<pre><code>to_arrow(as_large_types: bool = False) -&gt; ArrowSchema\n</code></pre> <p>Return equivalent arro3 schema</p> <p>Parameters:</p> Name Type Description Default <code>as_large_types</code> <code>bool</code> <p>get schema with all variable size types (list, binary, string) as large variants (with int64 indices). This is for compatibility with systems like Polars that only support the large versions of Arrow types.</p> <code>False</code> <p>Returns:</p> Type Description <code>Schema</code> <p>an arro3 Schema</p>","boost":2},{"location":"api/schema/#deltalake.Schema.to_json","title":"to_json  <code>method descriptor</code>","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Get the JSON string representation of the Schema.</p> <p>Returns:</p> Type Description <code>str</code> <p>a JSON string</p> Example <p>A schema has the same JSON format as a StructType. <pre><code>Schema([Field(\"x\", \"integer\")]).to_json()\n# Returns '{\"type\":\"struct\",\"fields\":[{\"name\":\"x\",\"type\":\"integer\",\"nullable\":true,\"metadata\":{}}]}'\n</code></pre></p>","boost":2},{"location":"api/schema/#deltalake.Field","title":"deltalake.Field","text":"<pre><code>Field(name: str, type: DataType, *, nullable: bool = True, metadata: dict[str, Any] | None = None)\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.Field.metadata","title":"metadata","text":"<pre><code>metadata: dict[str, Any] = &lt;attribute 'metadata' of 'deltalake._internal.Field' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.Field.name","title":"name","text":"<pre><code>name: str = &lt;attribute 'name' of 'deltalake._internal.Field' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.Field.nullable","title":"nullable","text":"<pre><code>nullable: bool = &lt;attribute 'nullable' of 'deltalake._internal.Field' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.Field.type","title":"type","text":"<pre><code>type: DataType = &lt;attribute 'type' of 'deltalake._internal.Field' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.Field.from_arrow","title":"from_arrow  <code>staticmethod</code>","text":"<pre><code>from_arrow(field: ArrowSchemaExportable) -&gt; Field\n</code></pre> <p>Create a Field from an object with an <code>ArrowSchemaExportable</code> field</p> <p>Note: This currently doesn't preserve field metadata.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>ArrowSchemaExportable</code> <p>a Field object that is <code>ArrowSchemaExportable</code></p> required <p>Returns:</p> Type Description <code>Field</code> <p>a Field</p>","boost":2},{"location":"api/schema/#deltalake.Field.from_json","title":"from_json  <code>staticmethod</code>","text":"<pre><code>from_json(field_json) -&gt; Field\n</code></pre> <p>Create a Field from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>str</code> <p>the JSON string.</p> required <p>Returns:</p> Type Description <code>Field</code> <p>Field</p> Example <pre><code>Field.from_json('''{\n        \"name\": \"col\",\n        \"type\": \"integer\",\n        \"nullable\": true,\n        \"metadata\": {}\n    }'''\n)\n# Returns Field(col, PrimitiveType(\"integer\"), nullable=True)\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.Field.to_arrow","title":"to_arrow  <code>method descriptor</code>","text":"<pre><code>to_arrow() -&gt; ArrowField\n</code></pre> <p>Convert to an equivalent arro3 field Note: This currently doesn't preserve field metadata.</p> <p>Returns:</p> Type Description <code>Field</code> <p>a arro3 Field</p>","boost":2},{"location":"api/schema/#deltalake.Field.to_json","title":"to_json  <code>method descriptor</code>","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Get the field as JSON string.</p> <p>Returns:</p> Type Description <code>str</code> <p>a JSON string</p> Example <pre><code>Field(\"col\", \"integer\").to_json()\n# Returns '{\"name\":\"col\",\"type\":\"integer\",\"nullable\":true,\"metadata\":{}}'\n</code></pre>","boost":2},{"location":"api/schema/#data-types","title":"Data types","text":"","boost":2},{"location":"api/schema/#deltalake.schema.PrimitiveType","title":"deltalake.schema.PrimitiveType","text":"<pre><code>PrimitiveType(data_type: str)\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.PrimitiveType.type","title":"type","text":"<pre><code>type: str = &lt;attribute 'type' of 'deltalake._internal.PrimitiveType' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.PrimitiveType.from_arrow","title":"from_arrow  <code>staticmethod</code>","text":"<pre><code>from_arrow(data_type) -&gt; PrimitiveType\n</code></pre> <p>Create a PrimitiveType from an <code>ArrowSchemaExportable</code> datatype</p> <p>Will raise <code>TypeError</code> if the arrow type is not a primitive type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>ArrowSchemaExportable</code> <p>an object that is <code>ArrowSchemaExportable</code></p> required <p>Returns:</p> Type Description <code>PrimitiveType</code> <p>a PrimitiveType</p>","boost":2},{"location":"api/schema/#deltalake.schema.PrimitiveType.from_json","title":"from_json  <code>staticmethod</code>","text":"<pre><code>from_json(type_json) -&gt; PrimitiveType\n</code></pre> <p>Create a PrimitiveType from a JSON string</p> <p>The JSON representation for a primitive type is just a quoted string: <code>PrimitiveType.from_json('\"integer\"')</code></p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>str</code> <p>a JSON string</p> required <p>Returns:</p> Type Description <code>PrimitiveType</code> <p>a PrimitiveType type</p>","boost":2},{"location":"api/schema/#deltalake.schema.PrimitiveType.to_arrow","title":"to_arrow  <code>method descriptor</code>","text":"<pre><code>to_arrow() -&gt; ArrowDataType\n</code></pre> <p>Get the equivalent arro3 DataType (arro3.core.DataType)</p>","boost":2},{"location":"api/schema/#deltalake.schema.ArrayType","title":"deltalake.schema.ArrayType","text":"<pre><code>ArrayType(element_type: DataType, *, contains_null: bool = True)\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.ArrayType.contains_null","title":"contains_null","text":"<pre><code>contains_null: bool = &lt;attribute 'contains_null' of 'deltalake._internal.ArrayType' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.ArrayType.element_type","title":"element_type","text":"<pre><code>element_type: DataType = &lt;attribute 'element_type' of 'deltalake._internal.ArrayType' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.ArrayType.type","title":"type","text":"<pre><code>type: Literal['array'] = &lt;attribute 'type' of 'deltalake._internal.ArrayType' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.ArrayType.from_arrow","title":"from_arrow  <code>staticmethod</code>","text":"<pre><code>from_arrow(data_type) -&gt; ArrayType\n</code></pre> <p>Create an ArrayType from an <code>ArrowSchemaExportable</code> datatype.</p> <p>Will raise <code>TypeError</code> if a different arrow DataType is provided.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>ArrowSchemaExportable</code> <p>an object that is <code>ArrowSchemaExportable</code></p> required <p>Returns:</p> Type Description <code>ArrayType</code> <p>an ArrayType</p>","boost":2},{"location":"api/schema/#deltalake.schema.ArrayType.from_json","title":"from_json  <code>staticmethod</code>","text":"<pre><code>from_json(type_json) -&gt; ArrayType\n</code></pre> <p>Create an ArrayType from a JSON string</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>str</code> <p>a JSON string</p> required <p>Returns:</p> Type Description <code>ArrayType</code> <p>an ArrayType</p> Example <p>The JSON representation for an array type is an object with <code>type</code> (set to <code>\"array\"</code>), <code>elementType</code>, and <code>containsNull</code>. <pre><code>ArrayType.from_json(\n    '''{\n        \"type\": \"array\",\n        \"elementType\": \"integer\",\n        \"containsNull\": false\n    }'''\n)\n# Returns ArrayType(PrimitiveType(\"integer\"), contains_null=False)\n</code></pre></p>","boost":2},{"location":"api/schema/#deltalake.schema.ArrayType.to_arrow","title":"to_arrow  <code>method descriptor</code>","text":"<pre><code>to_arrow() -&gt; ArrowDataType\n</code></pre> <p>Get the equivalent arro3 type.</p>","boost":2},{"location":"api/schema/#deltalake.schema.ArrayType.to_json","title":"to_json  <code>method descriptor</code>","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Get the JSON string representation of the type.</p>","boost":2},{"location":"api/schema/#deltalake.schema.MapType","title":"deltalake.schema.MapType","text":"<pre><code>MapType(key_type: DataType, value_type: DataType, *, value_contains_null: bool = True)\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.MapType.key_type","title":"key_type","text":"<pre><code>key_type: DataType = &lt;attribute 'key_type' of 'deltalake._internal.MapType' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.MapType.type","title":"type","text":"<pre><code>type: Literal['map'] = &lt;attribute 'type' of 'deltalake._internal.MapType' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.MapType.value_contains_null","title":"value_contains_null","text":"<pre><code>value_contains_null: bool = &lt;attribute 'value_contains_null' of 'deltalake._internal.MapType' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.MapType.value_type","title":"value_type","text":"<pre><code>value_type: DataType = &lt;attribute 'value_type' of 'deltalake._internal.MapType' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.MapType.from_arrow","title":"from_arrow  <code>staticmethod</code>","text":"<pre><code>from_arrow(data_type) -&gt; MapType\n</code></pre> <p>Create a MapType from an <code>ArrowSchemaExportable</code> datatype</p> <p>Will raise <code>TypeError</code> if passed a different type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>ArrowSchemaExportable</code> <p>an object that is <code>ArrowSchemaExportable</code></p> required <p>Returns:</p> Type Description <code>MapType</code> <p>a MapType</p>","boost":2},{"location":"api/schema/#deltalake.schema.MapType.from_json","title":"from_json  <code>staticmethod</code>","text":"<pre><code>from_json(type_json) -&gt; MapType\n</code></pre> <p>Create a MapType from a JSON string</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>str</code> <p>a JSON string</p> required <p>Returns:</p> Type Description <code>MapType</code> <p>an ArrayType</p> Example <p>The JSON representation for a map type is an object with <code>type</code> (set to <code>map</code>), <code>keyType</code>, <code>valueType</code>, and <code>valueContainsNull</code>:</p> <pre><code>MapType.from_json(\n    '''{\n        \"type\": \"map\",\n        \"keyType\": \"integer\",\n        \"valueType\": \"string\",\n        \"valueContainsNull\": true\n    }'''\n)\n# Returns MapType(PrimitiveType(\"integer\"), PrimitiveType(\"string\"), value_contains_null=True)\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.MapType.to_arrow","title":"to_arrow  <code>method descriptor</code>","text":"<pre><code>to_arrow() -&gt; ArrowDataType\n</code></pre> <p>Get the equivalent arro3 data type.</p>","boost":2},{"location":"api/schema/#deltalake.schema.MapType.to_json","title":"to_json  <code>method descriptor</code>","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Get JSON string representation of map type.</p> <p>Returns:</p> Type Description <code>str</code> <p>a JSON string</p>","boost":2},{"location":"api/schema/#deltalake.schema.StructType","title":"deltalake.schema.StructType","text":"<pre><code>StructType(fields: list[Field])\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.StructType.fields","title":"fields","text":"<pre><code>fields: list[Field] = &lt;attribute 'fields' of 'deltalake._internal.StructType' objects&gt;\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.StructType.type","title":"type","text":"<pre><code>type: Literal['struct'] = &lt;attribute 'type' of 'deltalake._internal.StructType' objects&gt;\n</code></pre> <p>The string \"struct\"</p>","boost":2},{"location":"api/schema/#deltalake.schema.StructType.from_arrow","title":"from_arrow  <code>staticmethod</code>","text":"<pre><code>from_arrow(data_type) -&gt; StructType\n</code></pre> <p>Create a new StructType from an <code>ArrowSchemaExportable</code> datatype</p> <p>Will raise <code>TypeError</code> if a different data type is provided.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>ArrowSchemaExportable</code> <p>a struct type object that is <code>ArrowSchemaExportable</code></p> required <p>Returns:</p> Type Description <code>StructType</code> <p>a StructType</p>","boost":2},{"location":"api/schema/#deltalake.schema.StructType.from_json","title":"from_json  <code>staticmethod</code>","text":"<pre><code>from_json(type_json) -&gt; StructType\n</code></pre> <p>Create a new StructType from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>str</code> <p>a JSON string</p> required <p>Returns:</p> Type Description <code>StructType</code> <p>a StructType</p> Example <pre><code>StructType.from_json(\n    '''{\n        \"type\": \"struct\",\n        \"fields\": [{\"name\": \"x\", \"type\": \"integer\", \"nullable\": true, \"metadata\": {}}]\n    }'''\n)\n# Returns StructType([Field(x, PrimitiveType(\"integer\"), nullable=True)])\n</code></pre>","boost":2},{"location":"api/schema/#deltalake.schema.StructType.to_arrow","title":"to_arrow  <code>method descriptor</code>","text":"<pre><code>to_arrow() -&gt; ArrowDataType\n</code></pre> <p>Get the equivalent arro3 DataType (arro3.core.DataType)</p>","boost":2},{"location":"api/schema/#deltalake.schema.StructType.to_json","title":"to_json  <code>method descriptor</code>","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Get the JSON representation of the type.</p> <p>Returns:</p> Type Description <code>str</code> <p>a JSON string</p> Example <pre><code>StructType([Field(\"x\", \"integer\")]).to_json()\n# Returns '{\"type\":\"struct\",\"fields\":[{\"name\":\"x\",\"type\":\"integer\",\"nullable\":true,\"metadata\":{}}]}'\n</code></pre>","boost":2},{"location":"api/storage/","title":"Storage","text":"<p>The delta filesystem handler for the pyarrow engine writer.</p>","boost":2},{"location":"api/storage/#deltalake.fs.DeltaStorageHandler","title":"deltalake.fs.DeltaStorageHandler","text":"<pre><code>DeltaStorageHandler(table_uri: str, options: dict[str, str] | None = None, known_sizes: dict[str, int] | None = None)\n</code></pre> <p>             Bases: <code>BaseDeltaStorageHandler</code></p> <p>DeltaStorageHandler is a concrete implementations of a PyArrow FileSystemHandler.</p>","boost":2},{"location":"api/transaction/","title":"Transaction","text":"","boost":2},{"location":"api/transaction/#commitproperties-and-postcommithookproperties","title":"CommitProperties and PostCommitHookProperties","text":"","boost":2},{"location":"api/transaction/#deltalake.CommitProperties","title":"deltalake.CommitProperties  <code>dataclass</code>","text":"<pre><code>CommitProperties(custom_metadata: dict[str, str] | None = None, max_commit_retries: int | None = None, app_transactions: list[Transaction] | None = None)\n</code></pre> <p>The commit properties. Controls the behaviour of the commit.</p> <p>Custom metadata to be stored in the commit. Controls the number of retries for the commit.</p> <p>Parameters:</p> Name Type Description Default <code>custom_metadata</code> <code>dict[str, str] | None</code> <p>custom metadata that will be added to the transaction commit.</p> <code>None</code> <code>max_commit_retries</code> <code>int | None</code> <p>maximum number of times to retry the transaction commit.</p> <code>None</code>","boost":2},{"location":"api/transaction/#deltalake.PostCommitHookProperties","title":"deltalake.PostCommitHookProperties  <code>dataclass</code>","text":"<pre><code>PostCommitHookProperties(create_checkpoint: bool = True, cleanup_expired_logs: bool | None = None)\n</code></pre> <p>The post commit hook properties, only required for advanced usecases where you need to control this.</p> <p>Checkpoints are by default created based on the delta.checkpointInterval config setting. cleanup_expired_logs can be set to override the delta.enableExpiredLogCleanup, otherwise the config setting will be used to decide whether to clean up logs automatically by taking also the delta.logRetentionDuration into account.</p> <p>Parameters:</p> Name Type Description Default <code>create_checkpoint</code> <code>bool</code> <p>to create checkpoints based on checkpoint interval. Defaults to True.</p> <code>True</code> <code>cleanup_expired_logs</code> <code>Optional[bool]</code> <p>to clean up logs based on interval. Defaults to None.</p> <code>None</code>","boost":2},{"location":"api/transaction/#create-write-transactions","title":"Create write transactions","text":"","boost":2},{"location":"api/transaction/#deltalake.transaction.AddAction","title":"deltalake.transaction.AddAction  <code>dataclass</code>","text":"<pre><code>AddAction(path: str, size: int, partition_values: Mapping[str, str | None], modification_time: int, data_change: bool, stats: str)\n</code></pre>","boost":2},{"location":"api/transaction/#deltalake.transaction.create_table_with_add_actions","title":"deltalake.transaction.create_table_with_add_actions","text":"<pre><code>create_table_with_add_actions(table_uri: str, schema: Schema, add_actions: list[AddAction], mode: Literal['error', 'append', 'overwrite', 'ignore'] = 'error', partition_by: list[str] | str | None = None, name: str | None = None, description: str | None = None, configuration: Mapping[str, str | None] | None = None, storage_options: dict[str, str] | None = None, commit_properties: CommitProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None) -&gt; None\n</code></pre>","boost":2},{"location":"api/transaction/#deltalake.DeltaTable.create_write_transaction","title":"deltalake.DeltaTable.create_write_transaction","text":"<pre><code>create_write_transaction(actions: list[AddAction], mode: str, schema: DeltaSchema | ArrowSchemaExportable, partition_by: list[str] | str | None = None, partition_filters: FilterType | None = None, commit_properties: CommitProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None) -&gt; None\n</code></pre>","boost":2},{"location":"api/delta_table/","title":"DeltaTable","text":"","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable","title":"deltalake.DeltaTable  <code>dataclass</code>","text":"<pre><code>DeltaTable(table_uri: str | Path | os.PathLike[str], version: int | None = None, storage_options: dict[str, str] | None = None, without_files: bool = False, log_buffer_size: int | None = None)\n</code></pre> <p>Represents a Delta Table</p> <p>Create the Delta Table from a path with an optional version. Multiple StorageBackends are currently supported: AWS S3, Azure Data Lake Storage Gen2, Google Cloud Storage (GCS) and local URI. Depending on the storage backend used, you could provide options values using the <code>storage_options</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>table_uri</code> <code>str | Path | PathLike[str]</code> <p>the path of the DeltaTable</p> required <code>version</code> <code>int | None</code> <p>version of the DeltaTable</p> <code>None</code> <code>storage_options</code> <code>dict[str, str] | None</code> <p>a dictionary of the options to use for the storage backend</p> <code>None</code> <code>without_files</code> <code>bool</code> <p>If True, will load table without tracking files.                 Some append-only applications might have no need of tracking any files. So, the                 DeltaTable will be loaded with a significant memory reduction.</p> <code>False</code> <code>log_buffer_size</code> <code>int | None</code> <p>Number of files to buffer when reading the commit log. A positive integer.                 Setting a value greater than 1 results in concurrent calls to the storage api.                 This can decrease latency if there are many files in the log since the last checkpoint,                 but will also increase memory usage. Possible rate limits of the storage backend should                 also be considered for optimal performance. Defaults to 4 * number of cpus.</p> <code>None</code>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.alter","title":"alter  <code>property</code>","text":"<pre><code>alter: TableAlterer\n</code></pre> <p>Namespace for all table alter related methods.</p> <p>Returns:</p> Name Type Description <code>TableAlterer</code> <code>TableAlterer</code> <p>TableAlterer Object</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.optimize","title":"optimize  <code>property</code>","text":"<pre><code>optimize: TableOptimizer\n</code></pre> <p>Namespace for all table optimize related methods.</p> <p>Returns:</p> Name Type Description <code>TableOptimizer</code> <code>TableOptimizer</code> <p>TableOptimizer Object</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.cleanup_metadata","title":"cleanup_metadata","text":"<pre><code>cleanup_metadata() -&gt; None\n</code></pre> <p>Delete expired log files before current version from table. The table log retention is based on the <code>delta.logRetentionDuration</code> value, 30 days by default.</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(table_uri: str | Path, schema: DeltaSchema | ArrowSchemaExportable, mode: Literal['error', 'append', 'overwrite', 'ignore'] = 'error', partition_by: list[str] | str | None = None, name: str | None = None, description: str | None = None, configuration: Mapping[str, str | None] | None = None, storage_options: dict[str, str] | None = None, commit_properties: CommitProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None, raise_if_key_not_exists: bool = True) -&gt; DeltaTable\n</code></pre> <p><code>CREATE</code> or <code>CREATE_OR_REPLACE</code> a delta table given a table_uri.</p> <p>Parameters:</p> Name Type Description Default <code>table_uri</code> <code>str | Path</code> <p>URI of a table</p> required <code>schema</code> <code>Schema | ArrowSchemaExportable</code> <p>Table schema</p> required <code>mode</code> <code>Literal['error', 'append', 'overwrite', 'ignore']</code> <p>How to handle existing data. Default is to error if table already exists. If 'append', returns not support error if table exists. If 'overwrite', will <code>CREATE_OR_REPLACE</code> table. If 'ignore', will not do anything if table already exists. Defaults to \"error\".</p> <code>'error'</code> <code>partition_by</code> <code>list[str] | str | None</code> <p>List of columns to partition the table by.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>User-provided identifier for this table.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>User-provided description for this table.</p> <code>None</code> <code>configuration</code> <code>Mapping[str, str | None] | None</code> <p>A map containing configuration options for the metadata action.</p> <code>None</code> <code>storage_options</code> <code>dict[str, str] | None</code> <p>Options passed to the object store crate.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>raise_if_key_not_exists</code> <code>bool</code> <p>Whether to raise an error if the configuration uses keys that are not Delta keys</p> <code>True</code> <p>Returns:</p> Name Type Description <code>DeltaTable</code> <code>DeltaTable</code> <p>created delta table</p> Example <pre><code>import pyarrow as pa\n\nfrom deltalake import DeltaTable\n\ndt = DeltaTable.create(\n    table_uri=\"my_local_table\",\n    schema=pa.schema(\n        [pa.field(\"foo\", pa.string()), pa.field(\"bar\", pa.string())]\n    ),\n    mode=\"error\",\n    partition_by=\"bar\",\n)\n</code></pre>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.create_checkpoint","title":"create_checkpoint","text":"<pre><code>create_checkpoint() -&gt; None\n</code></pre> <p>Create a checkpoint at the current table version.</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.delete","title":"delete","text":"<pre><code>delete(predicate: str | None = None, writer_properties: WriterProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Delete records from a Delta Table that satisfy a predicate.</p> <p>When a predicate is not provided then all records are deleted from the Delta Table. Otherwise a scan of the Delta table is performed to mark any files that contain records that satisfy the predicate. Once files are determined they are rewritten without the records.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>str | None</code> <p>a SQL where clause. If not passed, will delete all rows.</p> <code>None</code> <code>writer_properties</code> <code>WriterProperties | None</code> <p>Pass writer properties to the Rust parquet writer.</p> <code>None</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>the metrics from delete.</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.file_uris","title":"file_uris","text":"<pre><code>file_uris(partition_filters: FilterConjunctionType | None = None) -&gt; list[str]\n</code></pre> <p>Get the list of files as absolute URIs, including the scheme (e.g. \"s3://\").</p> <p>Local files will be just plain absolute paths, without a scheme. (That is, no 'file://' prefix.)</p> <p>Use the partition_filters parameter to retrieve a subset of files that match the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>partition_filters</code> <code>FilterConjunctionType | None</code> <p>the partition filters that will be used for getting the matched files</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of the .parquet files with an absolute URI referenced for the current version of the DeltaTable</p> <p>Predicates are expressed in disjunctive normal form (DNF), like [(\"x\", \"=\", \"a\"), ...]. DNF allows arbitrary boolean logical combinations of single partition predicates. The innermost tuples each describe a single partition predicate. The list of inner predicates is interpreted as a conjunction (AND), forming a more selective and multiple partition predicates. Each tuple has format: (key, op, value) and compares the key with the value. The supported op are: <code>=</code>, <code>!=</code>, <code>in</code>, and <code>not in</code>. If the op is in or not in, the value must be a collection such as a list, a set or a tuple. The supported type for value is str. Use empty string <code>''</code> for Null partition value.</p> Example <pre><code>(\"x\", \"=\", \"a\")\n(\"x\", \"!=\", \"a\")\n(\"y\", \"in\", [\"a\", \"b\", \"c\"])\n(\"z\", \"not in\", [\"a\",\"b\"])\n</code></pre>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.files","title":"files","text":"<pre><code>files(partition_filters: list[tuple[str, str, Any]] | None = None) -&gt; list[str]\n</code></pre> <p>Get the .parquet files of the DeltaTable.</p> <p>The paths are as they are saved in the delta log, which may either be relative to the table root or absolute URIs.</p> <p>Parameters:</p> Name Type Description Default <code>partition_filters</code> <code>list[tuple[str, str, Any]] | None</code> <p>the partition filters that will be used for                 getting the matched files</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of the .parquet files referenced for the current version of the DeltaTable</p> <p>Predicates are expressed in disjunctive normal form (DNF), like [(\"x\", \"=\", \"a\"), ...]. DNF allows arbitrary boolean logical combinations of single partition predicates. The innermost tuples each describe a single partition predicate. The list of inner predicates is interpreted as a conjunction (AND), forming a more selective and multiple partition predicates. Each tuple has format: (key, op, value) and compares the key with the value. The supported op are: <code>=</code>, <code>!=</code>, <code>in</code>, and <code>not in</code>. If the op is in or not in, the value must be a collection such as a list, a set or a tuple. The supported type for value is str. Use empty string <code>''</code> for Null partition value.</p> Example <pre><code>(\"x\", \"=\", \"a\")\n(\"x\", \"!=\", \"a\")\n(\"y\", \"in\", [\"a\", \"b\", \"c\"])\n(\"z\", \"not in\", [\"a\",\"b\"])\n</code></pre>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.files_by_partitions","title":"files_by_partitions","text":"<pre><code>files_by_partitions(partition_filters: PartitionFilterType) -&gt; list[str]\n</code></pre> <p>Get the files for each partition</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.get_add_actions","title":"get_add_actions","text":"<pre><code>get_add_actions(flatten: bool = False) -&gt; RecordBatch\n</code></pre> <p>Return a dataframe with all current add actions.</p> <p>Add actions represent the files that currently make up the table. This data is a low-level representation parsed from the transaction log.</p> <p>Parameters:</p> Name Type Description Default <code>flatten</code> <code>bool</code> <p>whether to flatten the schema. Partition values columns are         given the prefix <code>partition.</code>, statistics (null_count, min, and max) are         given the prefix <code>null_count.</code>, <code>min.</code>, and <code>max.</code>, and tags the         prefix <code>tags.</code>. Nested field names are concatenated with <code>.</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>RecordBatch</code> <p>a PyArrow RecordBatch containing the add action data.</p> Example <pre><code>from pprint import pprint\nfrom deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\ndata = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", data, partition_by=[\"x\"])\ndt = DeltaTable(\"tmp\")\ndf = dt.get_add_actions().to_pandas()\ndf[\"path\"].sort_values(ignore_index=True)\n0    x=1/0\n1    x=2/0\n2    x=3/0\n</code></pre> <pre><code>df = dt.get_add_actions(flatten=True).to_pandas()\ndf[\"partition.x\"].sort_values(ignore_index=True)\n0    1\n1    2\n2    3\n</code></pre>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.history","title":"history","text":"<pre><code>history(limit: int | None = None) -&gt; list[dict[str, Any]]\n</code></pre> <p>Run the history command on the DeltaTable. The operations are returned in reverse chronological order.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>the commit info limit to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list of the commit infos registered in the transaction log</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.is_deltatable","title":"is_deltatable  <code>staticmethod</code>","text":"<pre><code>is_deltatable(table_uri: str, storage_options: dict[str, str] | None = None) -&gt; bool\n</code></pre> <p>Returns True if a Delta Table exists at specified path. Returns False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>table_uri</code> <code>str</code> <p>the path of the DeltaTable</p> required <code>storage_options</code> <code>dict[str, str] | None</code> <p>a dictionary of the options to use for the storage backend</p> <code>None</code>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.load_as_version","title":"load_as_version","text":"<pre><code>load_as_version(version: int | str | datetime) -&gt; None\n</code></pre> <p>Load/time travel a DeltaTable to a specified version number, or a timestamp version of the table. If a string is passed then the argument should be an RFC 3339 and ISO 8601 date and time string format. If a datetime object without a timezone is passed, the UTC timezone will be assumed.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>int | str | datetime</code> <p>the identifier of the version of the DeltaTable to load</p> required Example <p>Use a version number <pre><code>dt = DeltaTable(\"test_table\")\ndt.load_as_version(1)\n</code></pre></p> <p>Use a datetime object <pre><code>dt.load_as_version(datetime(2023, 1, 1))\ndt.load_as_version(datetime(2023, 1, 1, tzinfo=timezone.utc))\n</code></pre></p> <p>Use a datetime in string format <pre><code>dt.load_as_version(\"2018-01-26T18:30:09Z\")\ndt.load_as_version(\"2018-12-19T16:39:57-08:00\")\ndt.load_as_version(\"2018-01-26T18:30:09.453+00:00\")\n</code></pre></p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.load_cdf","title":"load_cdf","text":"<pre><code>load_cdf(starting_version: int = 0, ending_version: int | None = None, starting_timestamp: str | None = None, ending_timestamp: str | None = None, columns: list[str] | None = None, predicate: str | None = None, allow_out_of_range: bool = False) -&gt; RecordBatchReader\n</code></pre> <p>Load the Change Data Feed (CDF) from the Delta table as a stream of record batches.</p> <p>Parameters:</p> Name Type Description Default <code>starting_version</code> <code>int</code> <p>The version of the Delta table to start reading CDF from.</p> <code>0</code> <code>ending_version</code> <code>int | None</code> <p>The version to stop reading CDF at. If None, reads up to the latest version.</p> <code>None</code> <code>starting_timestamp</code> <code>str | None</code> <p>An ISO 8601 timestamp to start reading CDF from. Ignored if starting_version is provided.</p> <code>None</code> <code>ending_timestamp</code> <code>str | None</code> <p>An ISO 8601 timestamp to stop reading CDF at. Ignored if ending_version is provided.</p> <code>None</code> <code>columns</code> <code>list[str] | None</code> <p>A list of column names to include in the output. If None, all columns are included.</p> <code>None</code> <code>predicate</code> <code>str | None</code> <p>An optional SQL predicate to filter the output rows.</p> <code>None</code> <code>allow_out_of_range</code> <code>bool</code> <p>If True, does not raise an error when specified versions or timestamps are outside the table's history.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RecordBatchReader</code> <code>RecordBatchReader</code> <p>An Arrow RecordBatchReader that streams the resulting change data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are invalid or if the specified range is not found (unless allow_out_of_range is True).</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.merge","title":"merge","text":"<pre><code>merge(source: ArrowStreamExportable | ArrowArrayExportable, predicate: str, source_alias: str | None = None, target_alias: str | None = None, merge_schema: bool = False, error_on_type_mismatch: bool = True, writer_properties: WriterProperties | None = None, streamed_exec: bool = True, post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None) -&gt; TableMerger\n</code></pre> <p>Pass the source data which you want to merge on the target delta table, providing a predicate in SQL query like format. You can also specify on what to do when the underlying data types do not match the underlying table.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ArrowStreamExportable | ArrowArrayExportable</code> <p>source data</p> required <code>predicate</code> <code>str</code> <p>SQL like predicate on how to merge</p> required <code>source_alias</code> <code>str | None</code> <p>Alias for the source table</p> <code>None</code> <code>target_alias</code> <code>str | None</code> <p>Alias for the target table</p> <code>None</code> <code>merge_schema</code> <code>bool</code> <p>Enable merge schema evolution for mismatch schema between source and target tables</p> <code>False</code> <code>error_on_type_mismatch</code> <code>bool</code> <p>specify if merge will return error if data types are mismatching :default = True</p> <code>True</code> <code>writer_properties</code> <code>WriterProperties | None</code> <p>Pass writer properties to the Rust parquet writer</p> <code>None</code> <code>streamed_exec</code> <code>bool</code> <p>Will execute MERGE using a LazyMemoryExec plan, this improves memory pressure for large source tables. Enabling streamed_exec implicitly disables source table stats to derive an early_pruning_predicate</p> <code>True</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties for the commit. If None, default values are used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TableMerger</code> <code>TableMerger</code> <p>TableMerger Object</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.metadata","title":"metadata","text":"<pre><code>metadata() -&gt; Metadata\n</code></pre> <p>Get the current metadata of the DeltaTable.</p> <p>Returns:</p> Type Description <code>Metadata</code> <p>the current Metadata registered in the transaction log</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.partitions","title":"partitions","text":"<pre><code>partitions(partition_filters: list[tuple[str, str, Any]] | None = None) -&gt; list[dict[str, str]]\n</code></pre> <p>Returns the partitions as a list of dicts. Example: <code>[{'month': '1', 'year': '2020', 'day': '1'}, ...]</code></p> <p>Parameters:</p> Name Type Description Default <code>partition_filters</code> <code>list[tuple[str, str, Any]] | None</code> <p>The partition filters that will be used for getting the matched partitions, defaults to <code>None</code> (no filtering).</p> <code>None</code>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.protocol","title":"protocol","text":"<pre><code>protocol() -&gt; ProtocolVersions\n</code></pre> <p>Get the reader and writer protocol versions of the DeltaTable.</p> <p>Returns:</p> Type Description <code>ProtocolVersions</code> <p>the current ProtocolVersions registered in the transaction log</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.repair","title":"repair","text":"<pre><code>repair(dry_run: bool = False, post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Repair the Delta Table by auditing active files that do not exist in the underlying filesystem and removes them. This can be useful when there are accidental deletions or corrupted files.</p> <p>Active files are ones that have an add action in the log, but no corresponding remove action. This operation creates a new FSCK transaction containing a remove action for each of the missing or corrupted files.</p> <p>Parameters:</p> Name Type Description Default <code>dry_run</code> <code>bool</code> <p>when activated, list only the files, otherwise add remove actions to transaction log. Defaults to False.</p> <code>False</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The metrics from repair (FSCK) action.</p> Example <p><pre><code>from deltalake import DeltaTable\ndt = DeltaTable('TEST')\ndt.repair(dry_run=False)\n</code></pre> Results in <pre><code>{'dry_run': False, 'files_removed': ['6-0d084325-6885-4847-b008-82c1cf30674c-0.parquet', 5-4fba1d3e-3e20-4de1-933d-a8e13ac59f53-0.parquet']}\n</code></pre></p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.restore","title":"restore","text":"<pre><code>restore(target: int | datetime | str, *, ignore_missing_files: bool = False, protocol_downgrade_allowed: bool = False, commit_properties: CommitProperties | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Run the Restore command on the Delta Table: restore table to a given version or datetime.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>int | datetime | str</code> <p>the expected version will restore, which represented by int, date str or datetime.</p> required <code>ignore_missing_files</code> <code>bool</code> <p>whether the operation carry on when some data files missing.</p> <code>False</code> <code>protocol_downgrade_allowed</code> <code>bool</code> <p>whether the operation when protocol version upgraded.</p> <code>False</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>the metrics from restore.</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.schema","title":"schema","text":"<pre><code>schema() -&gt; DeltaSchema\n</code></pre> <p>Get the current schema of the DeltaTable.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>the current Schema registered in the transaction log</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas(partitions: list[tuple[str, str, Any]] | None = None, columns: list[str] | None = None, filesystem: str | pa_fs.FileSystem | None = None, filters: FilterType | Expression | None = None, types_mapper: Callable[[pyarrow.DataType], Any] | None = None) -&gt; 'pd.DataFrame'\n</code></pre> <p>Build a pandas dataframe using data from the DeltaTable.</p> <p>Parameters:</p> Name Type Description Default <code>partitions</code> <code>list[tuple[str, str, Any]] | None</code> <p>A list of partition filters, see help(DeltaTable.files_by_partitions) for filter syntax</p> <code>None</code> <code>columns</code> <code>list[str] | None</code> <p>The columns to project. This can be a list of column names to include (order and duplicates will be preserved)</p> <code>None</code> <code>filesystem</code> <code>str | FileSystem | None</code> <p>A concrete implementation of the Pyarrow FileSystem or a fsspec-compatible interface. If None, the first file path will be used to determine the right FileSystem</p> <code>None</code> <code>filters</code> <code>FilterType | Expression | None</code> <p>A disjunctive normal form (DNF) predicate for filtering rows, or directly a pyarrow.dataset.Expression. If you pass a filter you do not need to pass <code>partitions</code></p> <code>None</code>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.to_pyarrow_dataset","title":"to_pyarrow_dataset","text":"<pre><code>to_pyarrow_dataset(partitions: FilterConjunctionType | None = None, filesystem: str | pa_fs.FileSystem | None = None, parquet_read_options: ParquetReadOptions | None = None, schema: pyarrow.Schema | None = None, as_large_types: bool = False) -&gt; 'pyarrow.dataset.Dataset'\n</code></pre> <p>Build a PyArrow Dataset using data from the DeltaTable.</p> <p>Parameters:</p> Name Type Description Default <code>partitions</code> <code>FilterConjunctionType | None</code> <p>A list of partition filters, see help(DeltaTable.files_by_partitions) for filter syntax</p> <code>None</code> <code>filesystem</code> <code>str | FileSystem | None</code> <p>A concrete implementation of the Pyarrow FileSystem or a fsspec-compatible interface. If None, the first file path will be used to determine the right FileSystem</p> <code>None</code> <code>parquet_read_options</code> <code>ParquetReadOptions | None</code> <p>Optional read options for Parquet. Use this to handle INT96 to timestamp conversion for edge cases like 0001-01-01 or 9999-12-31</p> <code>None</code> <code>schema</code> <code>Schema | None</code> <p>The schema to use for the dataset. If None, the schema of the DeltaTable will be used. This can be used to force reading of Parquet/Arrow datatypes that DeltaLake can't represent in it's schema (e.g. LargeString). If you only need to read the schema with large types (e.g. for compatibility with Polars) you may want to use the <code>as_large_types</code> parameter instead.</p> <code>None</code> <code>as_large_types</code> <code>bool</code> <p>get schema with all variable size types (list, binary, string) as large variants (with int64 indices). This is for compatibility with systems like Polars that only support the large versions of Arrow types. If <code>schema</code> is passed it takes precedence over this option.</p> <code>False</code> <p>More info: https://arrow.apache.org/docs/python/generated/pyarrow.dataset.ParquetReadOptions.html</p> Example <p><code>deltalake</code> will work with any storage compliant with :class:<code>pyarrow.fs.FileSystem</code>, however the root of the filesystem has to be adjusted to point at the root of the Delta table. We can achieve this by wrapping the custom filesystem into a :class:<code>pyarrow.fs.SubTreeFileSystem</code>. <pre><code>import pyarrow.fs as fs\nfrom deltalake import DeltaTable\n\ntable_uri = \"s3://&lt;bucket&gt;/&lt;path&gt;\"\nraw_fs, normalized_path = fs.FileSystem.from_uri(table_uri)\nfilesystem = fs.SubTreeFileSystem(normalized_path, raw_fs)\n\ndt = DeltaTable(table_uri)\nds = dt.to_pyarrow_dataset(filesystem=filesystem)\n</code></pre></p> <p>Returns:</p> Type Description <code>'pyarrow.dataset.Dataset'</code> <p>the PyArrow dataset in PyArrow</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.to_pyarrow_table","title":"to_pyarrow_table","text":"<pre><code>to_pyarrow_table(partitions: list[tuple[str, str, Any]] | None = None, columns: list[str] | None = None, filesystem: str | pa_fs.FileSystem | None = None, filters: FilterType | Expression | None = None) -&gt; 'pyarrow.Table'\n</code></pre> <p>Build a PyArrow Table using data from the DeltaTable.</p> <p>Parameters:</p> Name Type Description Default <code>partitions</code> <code>list[tuple[str, str, Any]] | None</code> <p>A list of partition filters, see help(DeltaTable.files_by_partitions) for filter syntax</p> <code>None</code> <code>columns</code> <code>list[str] | None</code> <p>The columns to project. This can be a list of column names to include (order and duplicates will be preserved)</p> <code>None</code> <code>filesystem</code> <code>str | FileSystem | None</code> <p>A concrete implementation of the Pyarrow FileSystem or a fsspec-compatible interface. If None, the first file path will be used to determine the right FileSystem</p> <code>None</code> <code>filters</code> <code>FilterType | Expression | None</code> <p>A disjunctive normal form (DNF) predicate for filtering rows, or directly a pyarrow.dataset.Expression. If you pass a filter you do not need to pass <code>partitions</code></p> <code>None</code>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.transaction_version","title":"transaction_version","text":"<pre><code>transaction_version(app_id: str) -&gt; int | None\n</code></pre> <p>Retrieve the latest transaction versions for the given application ID.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>The application ID for which to retrieve the latest transaction version.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: The latest transaction version for the given application ID if it exists, otherwise None.</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.update","title":"update","text":"<pre><code>update(updates: dict[str, str] | None = None, new_values: dict[str, int | float | str | datetime | bool | list[Any]] | None = None, predicate: str | None = None, writer_properties: WriterProperties | None = None, error_on_type_mismatch: bool = True, post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None) -&gt; dict[str, Any]\n</code></pre> <p><code>UPDATE</code> records in the Delta Table that matches an optional predicate. Either updates or new_values needs to be passed for it to execute.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict[str, str] | None</code> <p>a mapping of column name to update SQL expression.</p> <code>None</code> <code>new_values</code> <code>dict[str, int | float | str | datetime | bool | list[Any]] | None</code> <p>a mapping of column name to python datatype.</p> <code>None</code> <code>predicate</code> <code>str | None</code> <p>a logical expression.</p> <code>None</code> <code>writer_properties</code> <code>WriterProperties | None</code> <p>Pass writer properties to the Rust parquet writer.</p> <code>None</code> <code>error_on_type_mismatch</code> <code>bool</code> <p>specify if update will return error if data types are mismatching :default = True</p> <code>True</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <p>Returns:     the metrics from update</p> Example <p>Update some row values with SQL predicate</p> <p>This is equivalent to <code>UPDATE table SET deleted = true WHERE id = '3'</code> <pre><code>from deltalake import write_deltalake, DeltaTable\nimport pandas as pd\ndf = pd.DataFrame(\n    {\"id\": [\"1\", \"2\", \"3\"],\n    \"deleted\": [False, False, False],\n    \"price\": [10., 15., 20.]\n    })\nwrite_deltalake(\"tmp\", df)\ndt = DeltaTable(\"tmp\")\ndt.update(predicate=\"id = '3'\", updates = {\"deleted\": 'True'})\n\n{'num_added_files': 1, 'num_removed_files': 1, 'num_updated_rows': 1, 'num_copied_rows': 2, 'execution_time_ms': ..., 'scan_time_ms': ...}\n</code></pre></p> <p>Update all row values</p> <p>This is equivalent to <code>UPDATE table SET deleted = true, id = concat(id, '_old')</code>. <pre><code>dt.update(updates = {\"deleted\": 'True', \"id\": \"concat(id, '_old')\"})\n\n{'num_added_files': 1, 'num_removed_files': 1, 'num_updated_rows': 3, 'num_copied_rows': 0, 'execution_time_ms': ..., 'scan_time_ms': ...}\n</code></pre></p> <p>Use Python objects instead of SQL strings</p> <p>Use the <code>new_values</code> parameter instead of the <code>updates</code> parameter. For example, this is equivalent to <code>UPDATE table SET price = 150.10 WHERE id = '1'</code> <pre><code>dt.update(predicate=\"id = '1_old'\", new_values = {\"price\": 150.10})\n\n{'num_added_files': 1, 'num_removed_files': 1, 'num_updated_rows': 1, 'num_copied_rows': 2, 'execution_time_ms': ..., 'scan_time_ms': ...}\n</code></pre></p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.update_incremental","title":"update_incremental","text":"<pre><code>update_incremental() -&gt; None\n</code></pre> <p>Updates the DeltaTable to the latest version by incrementally applying newer versions.</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.vacuum","title":"vacuum","text":"<pre><code>vacuum(retention_hours: int | None = None, dry_run: bool = True, enforce_retention_duration: bool = True, post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None, full: bool = False) -&gt; list[str]\n</code></pre> <p>Run the Vacuum command on the Delta Table: list and delete files no longer referenced by the Delta table and are older than the retention threshold.</p> <p>Parameters:</p> Name Type Description Default <code>retention_hours</code> <code>int | None</code> <p>the retention threshold in hours, if none then the value from <code>delta.deletedFileRetentionDuration</code> is used or default of 1 week otherwise.</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>when activated, list only the files, delete otherwise</p> <code>True</code> <code>enforce_retention_duration</code> <code>bool</code> <p>when disabled, accepts retention hours smaller than the value from <code>delta.deletedFileRetentionDuration</code>.</p> <code>True</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <code>full</code> <code>bool</code> <p>when set to True, will perform a \"full\" vacuum and remove all files not referenced in the transaction log</p> <code>False</code> <p>Returns:     the list of files no longer referenced by the Delta Table and are older than the retention threshold.</p>","boost":2},{"location":"api/delta_table/#deltalake.DeltaTable.version","title":"version","text":"<pre><code>version() -&gt; int\n</code></pre> <p>Get the version of the DeltaTable.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current version of the DeltaTable</p>","boost":2},{"location":"api/delta_table/delta_table_alterer/","title":"TableAlterer","text":"","boost":10},{"location":"api/delta_table/delta_table_alterer/#deltalake.table.TableAlterer","title":"deltalake.table.TableAlterer","text":"<pre><code>TableAlterer(table: DeltaTable)\n</code></pre> <p>API for various table alteration commands.</p>","boost":10},{"location":"api/delta_table/delta_table_alterer/#deltalake.table.TableAlterer.add_columns","title":"add_columns","text":"<pre><code>add_columns(fields: DeltaField | list[DeltaField], commit_properties: CommitProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None) -&gt; None\n</code></pre> <p>Add new columns and/or update the fields of a stuctcolumn</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Field | list[Field]</code> <p>fields to merge into schema</p> required <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> Example <pre><code>from deltalake.schema import Field, PrimitiveType, StructType\ndt = DeltaTable(\"test_table\")\nnew_fields = [\n    Field(\"baz\", StructType([Field(\"bar\", PrimitiveType(\"integer\"))])),\n    Field(\"bar\", PrimitiveType(\"integer\"))\n]\ndt.alter.add_columns(\n    new_fields\n)\n</code></pre>","boost":10},{"location":"api/delta_table/delta_table_alterer/#deltalake.table.TableAlterer.add_constraint","title":"add_constraint","text":"<pre><code>add_constraint(constraints: dict[str, str], post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None) -&gt; None\n</code></pre> <p>Add constraints to the table. Limited to <code>single constraint</code> at once.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>dict[str, str]</code> <p>mapping of constraint name to SQL-expression to evaluate on write</p> required <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> Example <pre><code>from deltalake import DeltaTable\ndt = DeltaTable(\"test_table_constraints\")\ndt.alter.add_constraint({\n    \"value_gt_5\": \"value &gt; 5\",\n})\n</code></pre> <p>Check configuration <pre><code>dt.metadata().configuration\n{'delta.constraints.value_gt_5': 'value &gt; 5'}\n</code></pre></p>","boost":10},{"location":"api/delta_table/delta_table_alterer/#deltalake.table.TableAlterer.add_feature","title":"add_feature","text":"<pre><code>add_feature(feature: TableFeatures | list[TableFeatures], allow_protocol_versions_increase: bool = False, commit_properties: CommitProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None) -&gt; None\n</code></pre> <p>Enable a table feature.</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>TableFeatures | list[TableFeatures]</code> <p>Table Feature e.g. Deletion Vectors, Change Data Feed</p> required <code>allow_protocol_versions_increase</code> <code>bool</code> <p>Allow the protocol to be implicitly bumped to reader 3 or writer 7</p> <code>False</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> Example <pre><code>from deltalake import DeltaTable\ndt = DeltaTable(\"test_table\")\ndt.alter.add_feature(TableFeatures.AppendOnly)\n</code></pre> <p>Check protocol <pre><code>dt.protocol()\nProtocolVersions(min_reader_version=1, min_writer_version=7, writer_features=['appendOnly'], reader_features=None)\n</code></pre></p>","boost":10},{"location":"api/delta_table/delta_table_alterer/#deltalake.table.TableAlterer.drop_constraint","title":"drop_constraint","text":"<pre><code>drop_constraint(name: str, raise_if_not_exists: bool = True, post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None) -&gt; None\n</code></pre> <p>Drop constraints from a table. Limited to <code>single constraint</code> at once.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>constraint name which to drop.</p> required <code>raise_if_not_exists</code> <code>bool</code> <p>set if should raise if not exists.</p> <code>True</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> Example <pre><code>from deltalake import DeltaTable\ndt = DeltaTable(\"test_table_constraints\")\ndt.metadata().configuration\n{'delta.constraints.value_gt_5': 'value &gt; 5'}\n</code></pre> <p>Drop the constraint <pre><code>dt.alter.drop_constraint(name = \"value_gt_5\")\n</code></pre></p> <p>Configuration after dropping <pre><code>dt.metadata().configuration\n{}\n</code></pre></p>","boost":10},{"location":"api/delta_table/delta_table_alterer/#deltalake.table.TableAlterer.set_column_metadata","title":"set_column_metadata","text":"<pre><code>set_column_metadata(column: str, metadata: dict[str, str], commit_properties: CommitProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None) -&gt; None\n</code></pre> <p>Update a field's metadata in a schema. If the metadata key does not exist, the entry is inserted.</p> <p>If the column name doesn't exist in the schema - an error is raised.</p> <p>:param column: name of the column to update metadata for. :param metadata: the metadata to be added or modified on the column. :param commit_properties: properties of the transaction commit. If None, default values are used. :param post_commithook_properties: properties for the post commit hook. If None, default values are used. :return:</p>","boost":10},{"location":"api/delta_table/delta_table_alterer/#deltalake.table.TableAlterer.set_table_description","title":"set_table_description","text":"<pre><code>set_table_description(description: str, commit_properties: CommitProperties | None = None) -&gt; None\n</code></pre> <p>Set the description of the table.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>the description of the table</p> required <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.               Note: This parameter is not yet implemented and will be ignored.</p> <code>None</code> Example <pre><code>from deltalake import DeltaTable\ndt = DeltaTable(\"test_table\")\ndt.alter.set_table_description(\"new_table_description\")\n</code></pre>","boost":10},{"location":"api/delta_table/delta_table_alterer/#deltalake.table.TableAlterer.set_table_name","title":"set_table_name","text":"<pre><code>set_table_name(name: str, commit_properties: CommitProperties | None = None) -&gt; None\n</code></pre> <p>Set the name of the table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the table</p> required <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.               Note: This parameter is not yet implemented and will be ignored.</p> <code>None</code> Example <pre><code>from deltalake import DeltaTable\ndt = DeltaTable(\"test_table\")\ndt.alter.set_table_name(\"new_table_name\")\n</code></pre>","boost":10},{"location":"api/delta_table/delta_table_alterer/#deltalake.table.TableAlterer.set_table_properties","title":"set_table_properties","text":"<pre><code>set_table_properties(properties: dict[str, str], raise_if_not_exists: bool = True, commit_properties: CommitProperties | None = None) -&gt; None\n</code></pre> <p>Set properties from the table.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>dict[str, str]</code> <p>properties which set</p> required <code>raise_if_not_exists</code> <code>bool</code> <p>set if should raise if not exists.</p> <code>True</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> Example <pre><code>from deltalake import write_deltalake, DeltaTable\nimport pandas as pd\ndf = pd.DataFrame(\n    {\"id\": [\"1\", \"2\", \"3\"],\n    \"deleted\": [False, False, False],\n    \"price\": [10., 15., 20.]\n    })\nwrite_deltalake(\"tmp\", df)\n\ndt = DeltaTable(\"tmp\")\ndt.alter.set_table_properties({\"delta.enableChangeDataFeed\": \"true\"})\n</code></pre>","boost":10},{"location":"api/delta_table/delta_table_merger/","title":"TableMerger","text":"","boost":2},{"location":"api/delta_table/delta_table_merger/#deltalake.table.TableMerger","title":"deltalake.table.TableMerger","text":"<pre><code>TableMerger(builder: PyMergeBuilder, table: RawDeltaTable)\n</code></pre> <p>API for various table <code>MERGE</code> commands.</p>","boost":2},{"location":"api/delta_table/delta_table_merger/#deltalake.table.TableMerger.execute","title":"execute","text":"<pre><code>execute() -&gt; dict[str, Any]\n</code></pre> <p>Executes <code>MERGE</code> with the previously provided settings in Rust with Apache Datafusion query engine.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>dict[str, Any]</code> <p>metrics</p>","boost":2},{"location":"api/delta_table/delta_table_merger/#deltalake.table.TableMerger.when_matched_delete","title":"when_matched_delete","text":"<pre><code>when_matched_delete(predicate: str | None = None) -&gt; TableMerger\n</code></pre> <p>Delete a matched row from the table only if the given <code>predicate</code> (if specified) is true for the matched row. If not specified it deletes all matches.</p> Note <p>Column names with special characters, such as numbers or spaces should be encapsulated in backticks: \"target.<code>123column</code>\" or \"target.<code>my column</code>\"</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>(str | None, Optional)</code> <p>SQL like predicate on when to delete.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TableMerger</code> <code>TableMerger</code> <p>TableMerger Object</p> Example <p>Delete on a predicate</p> <pre><code>from deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\n\ndata = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", data)\ndt = DeltaTable(\"tmp\")\nnew_data = pa.table({\"x\": [2, 3], \"deleted\": [False, True]})\n\n(\n    dt.merge(\n        source=new_data,\n        predicate='target.x = source.x',\n        source_alias='source',\n        target_alias='target')\n    .when_matched_delete(\n        predicate=\"source.deleted = true\")\n    .execute()\n)\n{'num_source_rows': 2, 'num_target_rows_inserted': 0, 'num_target_rows_updated': 0, 'num_target_rows_deleted': 1, 'num_target_rows_copied': 2, 'num_output_rows': 2, 'num_target_files_added': 1, 'num_target_files_removed': 1, 'execution_time_ms': ..., 'scan_time_ms': ..., 'rewrite_time_ms': ...}\n\ndt.to_pandas().sort_values(\"x\", ignore_index=True)\n   x  y\n0  1  4\n1  2  5\n</code></pre> <p>Delete all records that were matched <pre><code>dt = DeltaTable(\"tmp\")\n(\n    dt.merge(\n        source=new_data,\n        predicate='target.x = source.x',\n        source_alias='source',\n        target_alias='target')\n    .when_matched_delete()\n    .execute()\n)\n{'num_source_rows': 2, 'num_target_rows_inserted': 0, 'num_target_rows_updated': 0, 'num_target_rows_deleted': 1, 'num_target_rows_copied': 1, 'num_output_rows': 1, 'num_target_files_added': 1, 'num_target_files_removed': 1, 'execution_time_ms': ..., 'scan_time_ms': ..., 'rewrite_time_ms': ...}\n\ndt.to_pandas()\n   x  y\n0  1  4\n</code></pre></p>","boost":2},{"location":"api/delta_table/delta_table_merger/#deltalake.table.TableMerger.when_matched_update","title":"when_matched_update","text":"<pre><code>when_matched_update(updates: dict[str, str], predicate: str | None = None) -&gt; TableMerger\n</code></pre> <p>Update a matched table row based on the rules defined by <code>updates</code>. If a <code>predicate</code> is specified, then it must evaluate to true for the row to be updated.</p> Note <p>Column names with special characters, such as numbers or spaces should be encapsulated in backticks: \"target.<code>123column</code>\" or \"target.<code>my column</code>\"</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict[str, str]</code> <p>a mapping of column name to update SQL expression.</p> required <code>predicate</code> <code>str | None</code> <p>SQL like predicate on when to update.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TableMerger</code> <code>TableMerger</code> <p>TableMerger Object</p> Example <pre><code>from deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\n\ndata = pa.table({\"x\": [1, 2, 3], \"1y\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", data)\ndt = DeltaTable(\"tmp\")\nnew_data = pa.table({\"x\": [1], \"1y\": [7]})\n\n(\n     dt.merge(\n         source=new_data,\n         predicate=\"target.x = source.x\",\n         source_alias=\"source\",\n         target_alias=\"target\")\n     .when_matched_update(updates={\"x\": \"source.x\", \"`1y`\": \"source.`1y`\"})\n     .execute()\n)\n{'num_source_rows': 1, 'num_target_rows_inserted': 0, 'num_target_rows_updated': 1, 'num_target_rows_deleted': 0, 'num_target_rows_copied': 2, 'num_output_rows': 3, 'num_target_files_added': 1, 'num_target_files_removed': 1, 'execution_time_ms': ..., 'scan_time_ms': ..., 'rewrite_time_ms': ...}\n\ndt.to_pandas()\n   x  y\n0  1  7\n1  2  5\n2  3  6\n</code></pre>","boost":2},{"location":"api/delta_table/delta_table_merger/#deltalake.table.TableMerger.when_matched_update_all","title":"when_matched_update_all","text":"<pre><code>when_matched_update_all(predicate: str | None = None, except_cols: list[str] | None = None) -&gt; TableMerger\n</code></pre> <p>Updating all source fields to target fields, source and target are required to have the same field names. If a <code>predicate</code> is specified, then it must evaluate to true for the row to be updated. If <code>except_cols</code> is specified, then the columns in the exclude list will not be updated.</p> Note <p>Column names with special characters, such as numbers or spaces should be encapsulated in backticks: \"target.<code>123column</code>\" or \"target.<code>my column</code>\"</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>str | None</code> <p>SQL like predicate on when to update all columns.</p> <code>None</code> <code>except_cols</code> <code>list[str] | None</code> <p>List of columns to exclude from update.</p> <code>None</code> <p>Returns:     TableMerger: TableMerger Object</p> Example <p>** Update all columns **</p> <pre><code>from deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\n\ndata = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", data)\ndt = DeltaTable(\"tmp\")\nnew_data = pa.table({\"x\": [1], \"y\": [7]})\n\n(\n    dt.merge(\n        source=new_data,\n        predicate=\"target.x = source.x\",\n        source_alias=\"source\",\n        target_alias=\"target\")\n    .when_matched_update_all()\n    .execute()\n)\n{'num_source_rows': 1, 'num_target_rows_inserted': 0, 'num_target_rows_updated': 1, 'num_target_rows_deleted': 0, 'num_target_rows_copied': 2, 'num_output_rows': 3, 'num_target_files_added': 1, 'num_target_files_removed': 1, 'execution_time_ms': ..., 'scan_time_ms': ..., 'rewrite_time_ms': ...}\n\ndt.to_pandas()\n   x  y\n0  1  7\n1  2  5\n2  3  6\n</code></pre> <p>** Update all columns except <code>bar</code> **</p> <pre><code>from deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\n\ndata = pa.table({\"foo\": [1, 2, 3], \"bar\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", data)\ndt = DeltaTable(\"tmp\")\nnew_data = pa.table({\"foo\": [1], \"bar\": [7]})\n\n(\n    dt.merge(\n        source=new_data,\n        predicate=\"target.foo = source.foo\",\n        source_alias=\"source\",\n        target_alias=\"target\")\n    .when_matched_update_all(except_cols=[\"bar\"])\n    .execute()\n)\n{'num_source_rows': 1, 'num_target_rows_inserted': 0, 'num_target_rows_updated': 1, 'num_target_rows_deleted': 0, 'num_target_rows_copied': 2, 'num_output_rows': 3, 'num_target_files_added': 1, 'num_target_files_removed': 1, 'execution_time_ms': ..., 'scan_time_ms': ..., 'rewrite_time_ms': ...}\n\ndt.to_pandas()\n   foo  bar\n0  1    4\n1  2    5\n2  3    6\n</code></pre>","boost":2},{"location":"api/delta_table/delta_table_merger/#deltalake.table.TableMerger.when_not_matched_by_source_delete","title":"when_not_matched_by_source_delete","text":"<pre><code>when_not_matched_by_source_delete(predicate: str | None = None) -&gt; TableMerger\n</code></pre> <p>Delete a target row that has no matches in the source from the table only if the given <code>predicate</code> (if specified) is true for the target row.</p> Note <p>Column names with special characters, such as numbers or spaces should be encapsulated in backticks: \"target.<code>123column</code>\" or \"target.<code>my column</code>\"</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>str | None</code> <p>SQL like predicate on when to delete when not matched by source.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TableMerger</code> <code>TableMerger</code> <p>TableMerger Object</p>","boost":2},{"location":"api/delta_table/delta_table_merger/#deltalake.table.TableMerger.when_not_matched_by_source_update","title":"when_not_matched_by_source_update","text":"<pre><code>when_not_matched_by_source_update(updates: dict[str, str], predicate: str | None = None) -&gt; TableMerger\n</code></pre> <p>Update a target row that has no matches in the source based on the rules defined by <code>updates</code>. If a <code>predicate</code> is specified, then it must evaluate to true for the row to be updated.</p> Note <p>Column names with special characters, such as numbers or spaces should be encapsulated in backticks: \"target.<code>123column</code>\" or \"target.<code>my column</code>\"</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict[str, str]</code> <p>a mapping of column name to update SQL expression.</p> required <code>predicate</code> <code>str | None</code> <p>SQL like predicate on when to update.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TableMerger</code> <code>TableMerger</code> <p>TableMerger Object</p> Example <pre><code>from deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\n\ndata = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", data)\ndt = DeltaTable(\"tmp\")\nnew_data = pa.table({\"x\": [2, 3, 4]})\n\n(\n   dt.merge(\n       source=new_data,\n       predicate='target.x = source.x',\n       source_alias='source',\n       target_alias='target')\n   .when_not_matched_by_source_update(\n       predicate = \"y &gt; 3\",\n       updates = {\"y\": \"0\"})\n   .execute()\n)\n{'num_source_rows': 3, 'num_target_rows_inserted': 0, 'num_target_rows_updated': 1, 'num_target_rows_deleted': 0, 'num_target_rows_copied': 2, 'num_output_rows': 3, 'num_target_files_added': 1, 'num_target_files_removed': 1, 'execution_time_ms': ..., 'scan_time_ms': ..., 'rewrite_time_ms': ...}\n\ndt.to_pandas().sort_values(\"x\", ignore_index=True)\n   x  y\n0  1  0\n1  2  5\n2  3  6\n</code></pre>","boost":2},{"location":"api/delta_table/delta_table_merger/#deltalake.table.TableMerger.when_not_matched_insert","title":"when_not_matched_insert","text":"<pre><code>when_not_matched_insert(updates: dict[str, str], predicate: str | None = None) -&gt; TableMerger\n</code></pre> <p>Insert a new row to the target table based on the rules defined by <code>updates</code>. If a <code>predicate</code> is specified, then it must evaluate to true for the new row to be inserted.</p> Note <p>Column names with special characters, such as numbers or spaces should be encapsulated in backticks: \"target.<code>123column</code>\" or \"target.<code>my column</code>\"</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict</code> <p>a mapping of column name to insert SQL expression.</p> required <code>predicate</code> <code>(str | None, Optional)</code> <p>SQL like predicate on when to insert.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TableMerger</code> <code>TableMerger</code> <p>TableMerger Object</p> Example <pre><code>from deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\n\ndata = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", data)\ndt = DeltaTable(\"tmp\")\nnew_data = pa.table({\"x\": [4], \"y\": [7]})\n\n(\n    dt.merge(\n        source=new_data,\n        predicate=\"target.x = source.x\",\n        source_alias=\"source\",\n        target_alias=\"target\",)\n    .when_not_matched_insert(\n        updates={\n            \"x\": \"source.x\",\n            \"y\": \"source.y\",\n        })\n    .execute()\n)\n{'num_source_rows': 1, 'num_target_rows_inserted': 1, 'num_target_rows_updated': 0, 'num_target_rows_deleted': 0, 'num_target_rows_copied': 3, 'num_output_rows': 4, 'num_target_files_added': 1, 'num_target_files_removed': 1, 'execution_time_ms': ..., 'scan_time_ms': ..., 'rewrite_time_ms': ...}\n\ndt.to_pandas().sort_values(\"x\", ignore_index=True)\n   x  y\n0  1  4\n1  2  5\n2  3  6\n3  4  7\n</code></pre>","boost":2},{"location":"api/delta_table/delta_table_merger/#deltalake.table.TableMerger.when_not_matched_insert_all","title":"when_not_matched_insert_all","text":"<pre><code>when_not_matched_insert_all(predicate: str | None = None, except_cols: list[str] | None = None) -&gt; TableMerger\n</code></pre> <p>Insert a new row to the target table, updating all source fields to target fields. Source and target are required to have the same field names. If a <code>predicate</code> is specified, then it must evaluate to true for the new row to be inserted. If <code>except_cols</code> is specified, then the columns in the exclude list will not be inserted.</p> Note <p>Column names with special characters, such as numbers or spaces should be encapsulated in backticks: \"target.<code>123column</code>\" or \"target.<code>my column</code>\"</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>str | None</code> <p>SQL like predicate on when to insert.</p> <code>None</code> <code>except_cols</code> <code>list[str] | None</code> <p>List of columns to exclude from insert.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TableMerger</code> <code>TableMerger</code> <p>TableMerger Object</p> Example <p>** Insert all columns **</p> <pre><code>from deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\n\ndata = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", data)\ndt = DeltaTable(\"tmp\")\nnew_data = pa.table({\"x\": [4], \"y\": [7]})\n\n(\n   dt.merge(\n       source=new_data,\n       predicate='target.x = source.x',\n       source_alias='source',\n       target_alias='target')\n   .when_not_matched_insert_all()\n   .execute()\n)\n{'num_source_rows': 1, 'num_target_rows_inserted': 1, 'num_target_rows_updated': 0, 'num_target_rows_deleted': 0, 'num_target_rows_copied': 3, 'num_output_rows': 4, 'num_target_files_added': 1, 'num_target_files_removed': 1, 'execution_time_ms': ..., 'scan_time_ms': ..., 'rewrite_time_ms': ...}\n\ndt.to_pandas().sort_values(\"x\", ignore_index=True)\n   x  y\n0  1  4\n1  2  5\n2  3  6\n3  4  7\n</code></pre> <p>** Insert all columns except <code>bar</code> **</p> <pre><code>from deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\n\ndata = pa.table({\"foo\": [1, 2, 3], \"bar\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", data)\ndt = DeltaTable(\"tmp\")\nnew_data = pa.table({\"foo\": [4], \"bar\": [7]})\n\n(\n   dt.merge(\n       source=new_data,\n       predicate='target.foo = source.foo',\n       source_alias='source',\n       target_alias='target')\n   .when_not_matched_insert_all(except_cols=[\"bar\"])\n   .execute()\n)\n{'num_source_rows': 1, 'num_target_rows_inserted': 1, 'num_target_rows_updated': 0, 'num_target_rows_deleted': 0, 'num_target_rows_copied': 3, 'num_output_rows': 4, 'num_target_files_added': 1, 'num_target_files_removed': 1, 'execution_time_ms': ..., 'scan_time_ms': ..., 'rewrite_time_ms': ...}\n\ndt.to_pandas().sort_values(\"foo\", ignore_index=True)\n   foo  bar\n0  1    4\n1  2    5\n2  3    6\n3  4    NaN\n</code></pre>","boost":2},{"location":"api/delta_table/delta_table_optimizer/","title":"TableOptimizer","text":"","boost":10},{"location":"api/delta_table/delta_table_optimizer/#deltalake.table.TableOptimizer","title":"deltalake.table.TableOptimizer","text":"<pre><code>TableOptimizer(table: DeltaTable)\n</code></pre> <p>API for various table optimization commands.</p>","boost":10},{"location":"api/delta_table/delta_table_optimizer/#deltalake.table.TableOptimizer.compact","title":"compact","text":"<pre><code>compact(partition_filters: FilterConjunctionType | None = None, target_size: int | None = None, max_concurrent_tasks: int | None = None, min_commit_interval: int | timedelta | None = None, writer_properties: WriterProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Compacts small files to reduce the total number of files in the table.</p> <p>This operation is idempotent; if run twice on the same table (assuming it has not been updated) it will do nothing the second time.</p> <p>If this operation happens concurrently with any operations other than append, it will fail.</p> <p>Parameters:</p> Name Type Description Default <code>partition_filters</code> <code>FilterConjunctionType | None</code> <p>the partition filters that will be used for getting the matched files</p> <code>None</code> <code>target_size</code> <code>int | None</code> <p>desired file size after bin-packing files, in bytes. If not             provided, will attempt to read the table configuration value <code>delta.targetFileSize</code>.             If that value isn't set, will use default value of 100MB.</p> <code>None</code> <code>max_concurrent_tasks</code> <code>int | None</code> <p>the maximum number of concurrent tasks to use for                     file compaction. Defaults to number of CPUs. More concurrent tasks can make compaction                     faster, but will also use more memory.</p> <code>None</code> <code>min_commit_interval</code> <code>int | timedelta | None</code> <p>minimum interval in seconds or as timedeltas before a new commit is                     created. Interval is useful for long running executions. Set to 0 or timedelta(0), if you                     want a commit per partition.</p> <code>None</code> <code>writer_properties</code> <code>WriterProperties | None</code> <p>Pass writer properties to the Rust parquet writer.</p> <code>None</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>the metrics from optimize</p> Example <p>Use a timedelta object to specify the seconds, minutes or hours of the interval. <pre><code>from deltalake import DeltaTable, write_deltalake\nfrom datetime import timedelta\nimport pyarrow as pa\n\nwrite_deltalake(\"tmp\", pa.table({\"x\": [1], \"y\": [4]}))\nwrite_deltalake(\"tmp\", pa.table({\"x\": [2], \"y\": [5]}), mode=\"append\")\n\ndt = DeltaTable(\"tmp\")\ntime_delta = timedelta(minutes=10)\ndt.optimize.compact(min_commit_interval=time_delta)\n{'numFilesAdded': 1, 'numFilesRemoved': 2, 'filesAdded': ..., 'filesRemoved': ..., 'partitionsOptimized': 1, 'numBatches': 2, 'totalConsideredFiles': 2, 'totalFilesSkipped': 0, 'preserveInsertionOrder': True}\n</code></pre></p>","boost":10},{"location":"api/delta_table/delta_table_optimizer/#deltalake.table.TableOptimizer.z_order","title":"z_order","text":"<pre><code>z_order(columns: Iterable[str], partition_filters: FilterConjunctionType | None = None, target_size: int | None = None, max_concurrent_tasks: int | None = None, max_spill_size: int = 20 * 1024 * 1024 * 1024, min_commit_interval: int | timedelta | None = None, writer_properties: WriterProperties | None = None, post_commithook_properties: PostCommitHookProperties | None = None, commit_properties: CommitProperties | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Reorders the data using a Z-order curve to improve data skipping.</p> <p>This also performs compaction, so the same parameters as compact() apply.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Iterable[str]</code> <p>the columns to use for Z-ordering. There must be at least one column.</p> required <code>partition_filters</code> <code>FilterConjunctionType | None</code> <p>the partition filters that will be used for getting the matched files</p> <code>None</code> <code>target_size</code> <code>int | None</code> <p>desired file size after bin-packing files, in bytes. If not             provided, will attempt to read the table configuration value <code>delta.targetFileSize</code>.             If that value isn't set, will use default value of 100MB.</p> <code>None</code> <code>max_concurrent_tasks</code> <code>int | None</code> <p>the maximum number of concurrent tasks to use for                     file compaction. Defaults to number of CPUs. More concurrent tasks can make compaction                     faster, but will also use more memory.</p> <code>None</code> <code>max_spill_size</code> <code>int</code> <p>the maximum number of bytes allowed in memory before spilling to disk. Defaults to 20GB.</p> <code>20 * 1024 * 1024 * 1024</code> <code>min_commit_interval</code> <code>int | timedelta | None</code> <p>minimum interval in seconds or as timedeltas before a new commit is                     created. Interval is useful for long running executions. Set to 0 or timedelta(0), if you                     want a commit per partition.</p> <code>None</code> <code>writer_properties</code> <code>WriterProperties | None</code> <p>Pass writer properties to the Rust parquet writer.</p> <code>None</code> <code>post_commithook_properties</code> <code>PostCommitHookProperties | None</code> <p>properties for the post commit hook. If None, default values are used.</p> <code>None</code> <code>commit_properties</code> <code>CommitProperties | None</code> <p>properties of the transaction commit. If None, default values are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>the metrics from optimize</p> Example <p>Use a timedelta object to specify the seconds, minutes or hours of the interval. <pre><code>from deltalake import DeltaTable, write_deltalake\nfrom datetime import timedelta\nimport pyarrow as pa\n\nwrite_deltalake(\"tmp\", pa.table({\"x\": [1], \"y\": [4]}))\nwrite_deltalake(\"tmp\", pa.table({\"x\": [2], \"y\": [5]}), mode=\"append\")\n\ndt = DeltaTable(\"tmp\")\ntime_delta = timedelta(minutes=10)\ndt.optimize.z_order([\"x\"], min_commit_interval=time_delta)\n{'numFilesAdded': 1, 'numFilesRemoved': 2, 'filesAdded': ..., 'filesRemoved': ..., 'partitionsOptimized': 0, 'numBatches': 1, 'totalConsideredFiles': 2, 'totalFilesSkipped': 0, 'preserveInsertionOrder': True}\n</code></pre></p>","boost":10},{"location":"api/delta_table/metadata/","title":"Metadata","text":"","boost":2},{"location":"api/delta_table/metadata/#deltalake.Metadata","title":"deltalake.Metadata  <code>dataclass</code>","text":"<pre><code>Metadata(table: RawDeltaTable)\n</code></pre> <p>Create a Metadata instance.</p>","boost":2},{"location":"api/delta_table/metadata/#deltalake.Metadata.configuration","title":"configuration  <code>property</code>","text":"<pre><code>configuration: dict[str, str]\n</code></pre> <p>Return the DeltaTable properties.</p>","boost":2},{"location":"api/delta_table/metadata/#deltalake.Metadata.created_time","title":"created_time  <code>property</code>","text":"<pre><code>created_time: int\n</code></pre> <p>Return The time when this metadata action is created, in milliseconds since the Unix epoch of the DeltaTable.</p>","boost":2},{"location":"api/delta_table/metadata/#deltalake.Metadata.description","title":"description  <code>property</code>","text":"<pre><code>description: str\n</code></pre> <p>Return the user-provided description of the DeltaTable.</p>","boost":2},{"location":"api/delta_table/metadata/#deltalake.Metadata.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>Return the unique identifier of the DeltaTable.</p>","boost":2},{"location":"api/delta_table/metadata/#deltalake.Metadata.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Return the user-provided identifier of the DeltaTable.</p>","boost":2},{"location":"api/delta_table/metadata/#deltalake.Metadata.partition_columns","title":"partition_columns  <code>property</code>","text":"<pre><code>partition_columns: list[str]\n</code></pre> <p>Return an array containing the names of the partitioned columns of the DeltaTable.</p>","boost":2},{"location":"how-delta-lake-works/architecture-of-delta-table/","title":"Architecture of a Delta Lake table","text":"<p>A Delta table consists of Parquet files that contain data and a transaction log that stores metadata about the transactions.</p> <p></p> <p>Let's create a Delta table, perform some operations, and inspect the files that are created.</p>"},{"location":"how-delta-lake-works/architecture-of-delta-table/#delta-lake-transaction-examples","title":"Delta Lake transaction examples","text":"<p>Start by creating a pandas DataFrame and writing it out to a Delta table.</p> <pre><code>import pandas as pd\nfrom deltalake import write_deltalake\n\ndf = pd.DataFrame({\"num\": [1, 2, 3], \"letter\": [\"a\", \"b\", \"c\"]})\nwrite_deltalake(\"tmp/some-table\", df)\n</code></pre> <p>Now inspect the files created in storage:</p> <pre><code>tmp/some-table\n\u251c\u2500\u2500 0-62dffa23-bbe1-4496-8fb5-bff6724dc677-0.parquet\n\u2514\u2500\u2500 _delta_log\n    \u2514\u2500\u2500 00000000000000000000.json\n</code></pre> <p>The Parquet file stores the data that was written. The <code>_delta_log</code> directory stores metadata about the transactions. Let's inspect the <code>_delta_log/00000000000000000000.json</code> file.</p> <pre><code>{\n  \"protocol\": {\n    \"minReaderVersion\": 1,\n    \"minWriterVersion\": 1\n  }\n}\n{\n  \"metaData\": {\n    \"id\": \"b96ea1a2-1830-4da2-8827-5334cc6104ed\",\n    \"name\": null,\n    \"description\": null,\n    \"format\": {\n      \"provider\": \"parquet\",\n      \"options\": {}\n    },\n    \"schemaString\": \"{\\\"type\\\":\\\"struct\\\",\\\"fields\\\":[{\\\"name\\\":\\\"num\\\",\\\"type\\\":\\\"long\\\",\\\"nullable\\\":true,\\\"metadata\\\":{}},{\\\"name\\\":\\\"letter\\\",\\\"type\\\":\\\"string\\\",\\\"nullable\\\":true,\\\"metadata\\\":{}}]}\",\n    \"partitionColumns\": [],\n    \"createdTime\": 1701740315599,\n    \"configuration\": {}\n  }\n}\n{\n  \"add\": {\n    \"path\": \"0-62dffa23-bbe1-4496-8fb5-bff6724dc677-0.parquet\",\n    \"size\": 2208,\n    \"partitionValues\": {},\n    \"modificationTime\": 1701740315597,\n    \"dataChange\": true,\n    \"stats\": \"{\\\"numRecords\\\": 3, \\\"minValues\\\": {\\\"num\\\": 1, \\\"letter\\\": \\\"a\\\"}, \\\"maxValues\\\": {\\\"num\\\": 3, \\\"letter\\\": \\\"c\\\"}, \\\"nullCount\\\": {\\\"num\\\": 0, \\\"letter\\\": 0}}\"\n  }\n}\n{\n  \"commitInfo\": {\n    \"timestamp\": 1701740315602,\n    \"operation\": \"CREATE TABLE\",\n    \"operationParameters\": {\n      \"location\": \"file:///Users/matthew.powers/Documents/code/delta/delta-examples/notebooks/python-deltalake/tmp/some-table\",\n      \"metadata\": \"{\\\"configuration\\\":{},\\\"created_time\\\":1701740315599,\\\"description\\\":null,\\\"format\\\":{\\\"options\\\":{},\\\"provider\\\":\\\"parquet\\\"},\\\"id\\\":\\\"b96ea1a2-1830-4da2-8827-5334cc6104ed\\\",\\\"name\\\":null,\\\"partition_columns\\\":[],\\\"schema\\\":{\\\"fields\\\":[{\\\"metadata\\\":{},\\\"name\\\":\\\"num\\\",\\\"nullable\\\":true,\\\"type\\\":\\\"long\\\"},{\\\"metadata\\\":{},\\\"name\\\":\\\"letter\\\",\\\"nullable\\\":true,\\\"type\\\":\\\"string\\\"}],\\\"type\\\":\\\"struct\\\"}}\",\n      \"protocol\": \"{\\\"minReaderVersion\\\":1,\\\"minWriterVersion\\\":1}\",\n      \"mode\": \"ErrorIfExists\"\n    },\n    \"clientVersion\": \"delta-rs.0.17.0\"\n  }\n}\n</code></pre> <p>The transaction log file contains the following information:</p> <ul> <li>the files added to the Delta table</li> <li>schema of the files</li> <li>column level metadata including the min/max value for each file</li> </ul> <p>Create another pandas DataFrame and append it to the Delta table to see how this transaction is recorded.</p> <pre><code>df = pd.DataFrame({\"num\": [8, 9], \"letter\": [\"dd\", \"ee\"]})\nwrite_deltalake(\"tmp/some-table\", df, mode=\"append\")\n</code></pre> <p>Here are the files in storage:</p> <pre><code>tmp/some-table\n\u251c\u2500\u2500 0-62dffa23-bbe1-4496-8fb5-bff6724dc677-0.parquet\n\u251c\u2500\u2500 1-57abb6fb-2249-43ba-a7be-cf09bcc230de-0.parquet\n\u2514\u2500\u2500 _delta_log\n    \u251c\u2500\u2500 00000000000000000000.json\n    \u2514\u2500\u2500 00000000000000000001.json\n</code></pre> <p>Here are the contents of the <code>_delta_log/00000000000000000001.json</code> file:</p> <pre><code>{\n  \"add\": {\n    \"path\": \"1-57abb6fb-2249-43ba-a7be-cf09bcc230de-0.parquet\",\n    \"size\": 2204,\n    \"partitionValues\": {},\n    \"modificationTime\": 1701740386169,\n    \"dataChange\": true,\n    \"stats\": \"{\\\"numRecords\\\": 2, \\\"minValues\\\": {\\\"num\\\": 8, \\\"letter\\\": \\\"dd\\\"}, \\\"maxValues\\\": {\\\"num\\\": 9, \\\"letter\\\": \\\"ee\\\"}, \\\"nullCount\\\": {\\\"num\\\": 0, \\\"letter\\\": 0}}\"\n  }\n}\n{\n  \"commitInfo\": {\n    \"timestamp\": 1701740386169,\n    \"operation\": \"WRITE\",\n    \"operationParameters\": {\n      \"partitionBy\": \"[]\",\n      \"mode\": \"Append\"\n    },\n    \"clientVersion\": \"delta-rs.0.17.0\"\n  }\n}\n</code></pre> <p>The transaction log records that the second file has been persisted in the Delta table.</p> <p>Now create a third pandas DataFrame and overwrite the Delta table with the new data.</p> <pre><code>df = pd.DataFrame({\"num\": [11, 22], \"letter\": [\"aa\", \"bb\"]})\nwrite_deltalake(\"tmp/some-table\", df, mode=\"overwrite\")\n</code></pre> <p>Here are the files in storage:</p> <pre><code>tmp/some-table\n\u251c\u2500\u2500 0-62dffa23-bbe1-4496-8fb5-bff6724dc677-0.parquet\n\u251c\u2500\u2500 1-57abb6fb-2249-43ba-a7be-cf09bcc230de-0.parquet\n\u251c\u2500\u2500 2-95ef2108-480c-4b89-96f0-ff9185dab9ad-0.parquet\n\u2514\u2500\u2500 _delta_log\n    \u251c\u2500\u2500 00000000000000000000.json\n    \u251c\u2500\u2500 00000000000000000001.json\n    \u2514\u2500\u2500 00000000000000000002.json\n</code></pre> <p>Here are the contents of the <code>_delta_log/0002.json</code> file:</p> <pre><code>{\n  \"add\": {\n    \"path\": \"2-95ef2108-480c-4b89-96f0-ff9185dab9ad-0.parquet\",\n    \"size\": 2204,\n    \"partitionValues\": {},\n    \"modificationTime\": 1701740465102,\n    \"dataChange\": true,\n    \"stats\": \"{\\\"numRecords\\\": 2, \\\"minValues\\\": {\\\"num\\\": 11, \\\"letter\\\": \\\"aa\\\"}, \\\"maxValues\\\": {\\\"num\\\": 22, \\\"letter\\\": \\\"bb\\\"}, \\\"nullCount\\\": {\\\"num\\\": 0, \\\"letter\\\": 0}}\"\n  }\n}\n{\n  \"remove\": {\n    \"path\": \"0-62dffa23-bbe1-4496-8fb5-bff6724dc677-0.parquet\",\n    \"deletionTimestamp\": 1701740465102,\n    \"dataChange\": true,\n    \"extendedFileMetadata\": false,\n    \"partitionValues\": {},\n    \"size\": 2208\n  }\n}\n{\n  \"remove\": {\n    \"path\": \"1-57abb6fb-2249-43ba-a7be-cf09bcc230de-0.parquet\",\n    \"deletionTimestamp\": 1701740465102,\n    \"dataChange\": true,\n    \"extendedFileMetadata\": false,\n    \"partitionValues\": {},\n    \"size\": 2204\n  }\n}\n{\n  \"commitInfo\": {\n    \"timestamp\": 1701740465102,\n    \"operation\": \"WRITE\",\n    \"operationParameters\": {\n      \"mode\": \"Overwrite\",\n      \"partitionBy\": \"[]\"\n    },\n    \"clientVersion\": \"delta-rs.0.17.0\"\n  }\n}\n</code></pre> <p>This transaction adds a data file and marks the two existing data files for removal. Marking a file for removal in the transaction log is known as \"tombstoning the file\" or a \"logical delete\". This is different from a \"physical delete\" which actually removes the data file from storage.</p>"},{"location":"how-delta-lake-works/architecture-of-delta-table/#how-delta-table-operations-differ-from-data-lakes","title":"How Delta table operations differ from data lakes","text":"<p>Data lakes consist of data files persisted in storage. They don't have a transaction log that retain metadata about the transactions.</p> <p>Data lakes perform transactions differently than Delta tables.</p> <p>When you perform an overwrite transaction with a Delta table, you logically delete the exiting data without physically removing it.</p> <p>Data lakes don't support logical deletes, so you have to physically delete the data from storage.</p> <p>Logical data operations are safer because they can be rolled back if they don't complete successfully. Physically removing data from storage can be dangerous, especially if it's before a transaction is complete.</p> <p>We're now ready to look into Delta Lake ACID transactions in more detail.</p>"},{"location":"how-delta-lake-works/delta-lake-acid-transactions/","title":"Delta Lake Transactions","text":"<p>This page teaches you about Delta Lake transactions and why transactions are important in production data settings. Data lakes don\u2019t support transactions and this is a huge downside because they offer a poor user experience, lack functionality, and can easily be corrupted.</p> <p>Transactions on Delta Lake tables are operations that change the state of table and record descriptive entries (metadata) of those changes to the Delta Lake transaction log. Here are some examples of transactions:</p> <ul> <li>Deleting rows</li> <li>Appending to the table</li> <li>Compacting small files</li> <li>Upserting</li> <li>Overwriting rows</li> </ul> <p>All Delta Lake write operations are transactions in Delta tables. Reads actually aren\u2019t technically transactions because they don\u2019t result in new entries being appended to the transaction log.</p>"},{"location":"how-delta-lake-works/delta-lake-acid-transactions/#what-are-transactions","title":"What are transactions?","text":"<p>Transactions are any Delta operation that change the underlying files of a Delta table and result in new entries metadata entries in the transaction log. Some Delta operations rearrange data in the existing table (like Z Ordering the table or compacting the small files) and these are also transactions. Let\u2019s look at a simple example.</p> <p>Suppose you have a Delta table with the following data:</p> <pre><code>num animal\n1   cat\n2   dog\n3   snake\n</code></pre> <p>Here\u2019s how to create this Delta table:</p> <pre><code>import pandas as pd\nfrom deltalake import write_deltalake, DeltaTable\n\ndf = pd.DataFrame({\"num\": [1, 2, 3], \"animal\": [\"cat\", \"dog\", \"snake\"]})\nwrite_deltalake(\"tmp/my-delta-table\", df)\n</code></pre> <p>Here are the files created in storage.</p> <pre><code>tmp/my-delta-table\n\u251c\u2500\u2500 0-fea2de92-861a-423e-9708-a9e91dafb27b-0.parquet\n\u2514\u2500\u2500 _delta_log\n    \u2514\u2500\u2500 00000000000000000000.json\n</code></pre> <p>Let\u2019s perform an operation to delete every animal from the Delta table that is a cat.</p> <pre><code>dt = DeltaTable(\"tmp/my-delta-table\")\ndt.delete(\"animal = 'cat'\")\n</code></pre> <p>Let\u2019s take a look at the contents of the Delta table now that the transaction is complete:</p> <pre><code>tmp/my-delta-table\n\u251c\u2500\u2500 0-fea2de92-861a-423e-9708-a9e91dafb27b-0.parquet\n\u251c\u2500\u2500 _delta_log\n\u2502   \u251c\u2500\u2500 00000000000000000000.json\n\u2502   \u2514\u2500\u2500 00000000000000000001.json\n\u2514\u2500\u2500 part-00001-90312b96-b487-4a8f-9edc-1b9b3963f136-c000.snappy.parquet\n</code></pre> <p>Notice the <code>00000000000000000001.json</code> file that was added to the transaction log to record this transaction. Let\u2019s inspect the content of the file.</p> <pre><code>{\n  \"add\": {\n    \"path\": \"part-00001-90312b96-b487-4a8f-9edc-1b9b3963f136-c000.snappy.parquet\",\n    \"partitionValues\": {},\n    \"size\": 858,\n    \"modificationTime\": 1705070631953,\n    \"dataChange\": true,\n    \"stats\": \"{\\\"numRecords\\\":2,\\\"minValues\\\":{\\\"num\\\":2,\\\"animal\\\":\\\"dog\\\"},\\\"maxValues\\\":{\\\"num\\\":3,\\\"animal\\\":\\\"snake\\\"},\\\"nullCount\\\":{\\\"num\\\":0,\\\"animal\\\":0}}\",\n    \"tags\": null,\n    \"deletionVector\": null,\n    \"baseRowId\": null,\n    \"defaultRowCommitVersion\": null,\n    \"clusteringProvider\": null\n  }\n}\n{\n  \"remove\": {\n    \"path\": \"0-fea2de92-861a-423e-9708-a9e91dafb27b-0.parquet\",\n    \"dataChange\": true,\n    \"deletionTimestamp\": 1705070631953,\n    \"extendedFileMetadata\": true,\n    \"partitionValues\": {},\n    \"size\": 895\n  }\n}\n{\n  \"commitInfo\": {\n    \"timestamp\": 1705070631953,\n    \"operation\": \"DELETE\",\n    \"operationParameters\": {\n      \"predicate\": \"animal = 'cat'\"\n    },\n    \"readVersion\": 0,\n    \"operationMetrics\": {\n      \"execution_time_ms\": 8013,\n      \"num_added_files\": 1,\n      \"num_copied_rows\": 2,\n      \"num_deleted_rows\": 1,\n      \"num_removed_files\": 1,\n      \"rewrite_time_ms\": 2,\n      \"scan_time_ms\": 5601\n    },\n    \"clientVersion\": \"delta-rs.0.17.0\"\n  }\n}\n</code></pre> <p>We can see that this transaction includes two components:</p> <ul> <li>Remove file <code>0-fea2de92-861a-423e-9708-a9e91dafb27b-0.parquet</code></li> <li>Add file <code>part-00001-90312b96-b487-4a8f-9edc-1b9b3963f136-c000.snappy.parquet</code></li> </ul> <p>Transactions are recorded in the transaction log. The transaction log is also referred to as the table metadata and is the <code>_delta_log</code> directory in storage.</p> <p>Let\u2019s see how Delta Lake implements transactions.</p>"},{"location":"how-delta-lake-works/delta-lake-acid-transactions/#how-delta-lake-implements-transactions","title":"How Delta Lake implements transactions","text":"<p>Here is how Delta Lake implements transactions:</p> <ol> <li>Read the existing metadata</li> <li>Read the existing Parquet data files</li> <li>Write the Parquet files for the current transaction</li> <li>Record the new transaction in the transaction log (if there are no conflicts)</li> </ol> <p>Let\u2019s recall our delete operation from the prior section and see how it fits into this transaction model:</p> <ol> <li>We read the existing metadata to find the file paths for the existing Parquet files</li> <li>We read the existing Parquet files and identify the files that contains data that should be removed</li> <li>We write new Parquet files with the deleted data filtered out</li> <li>Once the new Parquet files are written, we check for conflicts and then make an entry in the transaction log. The next section will discuss transaction conflicts in more detail.</li> </ol> <p>Blind append operations can skip a few steps and are executed as follows:</p> <ol> <li>Write the Parquet files for the current transaction</li> <li>Record the new transaction in the metadata</li> </ol> <p>Delta implements a non locking MVCC (multi version concurrency control) so writers optimistically write new data and simply abandon the transaction if it conflicts at the end. The alternative would be getting a lock at the start thereby guaranteeing the transaction immediately.</p> <p>Let\u2019s look at the case when a Delta Lake transaction conflicts.</p>"},{"location":"how-delta-lake-works/delta-lake-acid-transactions/#how-delta-lake-transactions-can-conflict","title":"How Delta Lake transactions can conflict","text":"<p>Suppose you have a transaction that deletes a row of data that\u2019s stored in FileA (Transaction 1). While this job is running, there is another transaction that deletes some other rows in FileA (Transaction 2). Transaction 1 finishes running first and is recorded in the metadata.</p> <p>Before Transaction 2 is recorded as a transaction, it will check the metadata, find that Transaction 2 conflicts with a transaction that was already recorded (from Transaction 1), and error without recording a new transaction.</p> <p>Transactions 2 will write Parquet data files, but will not be recorded as a transaction, so the data files will be ignored. The zombie Parquet files can be easily cleaned up via subsequent vacuum operations.</p> <p>Transaction 2 must fail otherwise it would cause the data to be incorrect.</p> <p>Delta Lake transactions prevent users from making changes that would corrupt the table. Transaction conflict behavior can differ based on isolation level, which controls the degree to which a transaction must be isolated from modifications made by other concurrent transactions. More about this in the concurrency section.</p>"},{"location":"how-delta-lake-works/delta-lake-acid-transactions/#transactions-rely-on-atomic-primitives-storage-guarantees","title":"Transactions rely on atomic primitives storage guarantees","text":"<p>Suppose you have two transactions that are finishishing at the same exact time. Both of these transactions look at the existing Delta Lake transaction log, see that the latest transaction was <code>003.json</code> and determine that the next entry should be <code>004.json</code>.</p> <p>If both transactions are recorded in the <code>004.json</code> file, then one of them will be clobbered, and the transaction log entry for the clobbered metadata entry will be lost.</p> <p>Delta tables rely on storage systems that provide atomic primitives for safe concurrency. The storage system must allow Delta Lake to write the file, only if it does not exist already, and error out otherwise. The storage system must NOT permit concurrent writers to overwrite existing metadata entries.</p> <p>Some clouds have filesystems that don\u2019t explicitly support these atomic primitives, and therefore must be coupled with other services to provide the necessary guarantees.</p>"},{"location":"how-delta-lake-works/delta-lake-acid-transactions/#delta-lake-transactions-are-only-for-a-single-table","title":"Delta Lake transactions are only for a single table","text":"<p>Delta Lake transactions are only valid for a single table.</p> <p>Some databases offer transaction support for operations that impact multiple tables. Delta Lake does not support multi-table transactions.</p>"},{"location":"how-delta-lake-works/delta-lake-acid-transactions/#data-lakes-dont-support-transactions","title":"Data lakes don\u2019t support transactions","text":"<p>Data lakes consist of many files in a storage system (e.g. a cloud storage system) and don\u2019t support transactions.</p> <p>Data lakes don\u2019t have a metadata layer, conflict resolution, or any way to store information about transactions.</p> <p>Data lakes are prone to multiple types of errors because they don\u2019t support transactions:</p> <ul> <li>Easy to corrupt</li> <li>Downtime/unstable state while jobs are running</li> <li>Operations can conflict</li> </ul> <p>Data lakes have many downsides and it\u2019s almost always better to use a lakehouse storage system like Delta Lake compared to a data lake.</p>"},{"location":"how-delta-lake-works/delta-lake-acid-transactions/#acid-transactions","title":"ACID Transactions","text":"<p>We\u2019ve already explored how Delta Lake supports transactions. This section explains how Delta Lake transactions have the Atomic, Consistent, Isolated and Durable (ACID transaction) properties. Reading this section is optional.</p> <p>ACID transactions are commonplace in databases but notably absent for data lakes.</p> <p>Delta Lake\u2019s ACID transaction support is one of the major reasons it is almost always a better option than a data lake.</p> <p>Let\u2019s explore how Delta Lake allows for ACID transactions.</p> <p>Atomic transactions</p> <p>An atomic transaction either fully completes or fully fails, with nothing in between.</p> <p>Delta Lake transactions are atomic, unlike data lake transactions that are not atomic.</p> <p>Suppose you have a job that\u2019s writing 100 files to a table. Further suppose that the job errors out and the cluster dies after writing 40 files:</p> <ul> <li>For a Delta table, no additional data will be added to the table. Parquet files were written to the table, but the job errored, so no transaction log entry was added and no data was added to the table.</li> <li>For a data lake, the 40 files are added and the transaction \u201cpartially succeeds\u201d.</li> </ul> <p>For data tables, it\u2019s almost always preferable to have a transaction that \u201cfully fails\u201d instead of one that \u201cpartially succeeds\u201d because partial writes are hard to unwind and debug.</p> <p>Delta Lake implements atomic transactions by writing data files first before making a new entry in the Delta transaction log.</p> <p>These guarantees are provided at the protocol level through the \"transaction\" abstraction. We\u2019ve already discussed what constitutes a transaction for Delta Lake.</p> <p>If there is an error with the transaction and some files don\u2019t get written, then no metadata entry is made and the partial data write is ignored. The zombie Parquet files can be easily cleaned up via subsequent vacuum operations.</p> <p>Now let\u2019s look at how Delta Lake also provides consistent transactions.</p> <p>Consistent transactions</p> <p>Consistency means that transactions won\u2019t violate integrity constraints on the Delta table.</p> <p>Delta Lake has two types of consistency checks:</p> <ul> <li>Schema enforcement checks</li> <li>Column constraints</li> </ul> <p>Schema enforcement checks verify that new data appended to a Delta table matches the schema of the existing table. You cannot append data with a different schema, unless you enable schema evolution.</p> <p>Delta Lake column constraints allow users to specify the requirements of data that\u2019s added to a Delta table. For example, if you have an age column with a constraint that requires the value to be positive, then Delta Lake will reject appends of any data that doesn\u2019t meet the constraint.</p> <p>Data lakes don\u2019t support schema enforcement or column constraints. That\u2019s another reason why data lakes are not ACID-compliant.</p> <p>Isolated transactions</p> <p>Isolation means that transactions are applied to a Delta table sequentially.</p> <p>Delta Lake transactions are persisted in monotonically increasing transaction files, as we saw in the previous example. First <code>00000000000000000000.json</code>, then <code>00000000000000000001.json</code>, then <code>00000000000000000002.json</code>, and so on.</p> <p>Delta Lake uses concurrency control to ensure that transactions are executed sequentially, even when user operations are performed concurrently. The next page of this guide explains concurrency in Delta Lake in detail.</p> <p>Durable transactions</p> <p>Delta tables are generally persisted in cloud object stores which provide durability guarantees.</p> <p>Durability means that all transactions that are successfully completed will always remain persisted, even if there are service outages or program crashes.</p> <p>Suppose you have a Delta table that\u2019s persisted in Azure blob storage. The Delta table transactions that are committed will always remain available, even in these circumstances:</p> <ul> <li>When there are Azure service outages</li> <li>If a computation cluster that\u2019s writing the Delta table crashes for some reason</li> <li>Two operations are running concurrently and one of them fails</li> </ul> <p>Successful transactions are always registered in the Delta table and persisted no matter what.</p>"},{"location":"how-delta-lake-works/delta-lake-acid-transactions/#conclusion","title":"Conclusion","text":"<p>Delta Lake supports transactions which provide necessary reliability guarantees for production data systems.</p> <p>Vanilla data lakes don\u2019t provide transactions and this can cause nasty bugs and a bad user experience. Let\u2019s look at a couple of scenarios when the lack of transactions cause a poor user experience:</p> <ul> <li>While running a compaction operation on a data lake, newly compacted \u201cright sized\u201d files are added before the small files are deleted. If you read the data lake while this operation is running, you will see duplicate data.</li> <li>While writing to a data lake, a job might fail, which leaves behind partially written files. These files are corrupt, which means that the data lake cannot be read until the corrupt files are manually removed.</li> <li>Users want to run a simple DML operation like deleting a few rows of data which require a few files to be rewritten. This operation renders the data lake unusable until it\u2019s done running.</li> </ul> <p>Transactions are a key advantage of Delta Lake vs. data lakes. There are many other advantages, but proper transactions are necessary in production data environments.</p> <p>Let's take a look at File Skipping in the next section.</p>"},{"location":"how-delta-lake-works/delta-lake-file-skipping/","title":"Delta Lake File Skipping","text":"<p>Delta tables store file-level metadata information, which allows for a powerful optimization called file skipping.</p> <p>This page explains how Delta Lake implements file skipping, how to optimize your tables to maximize file skipping, and the benefits of file skipping.</p> <p>Let\u2019s start by looking at the file-level metadata in Delta tables.</p>"},{"location":"how-delta-lake-works/delta-lake-file-skipping/#delta-lake-file-metadata","title":"Delta Lake file metadata","text":"<p>Delta Lake stores metadata about each file's min/max values in the table.  Query engines can skip entire files when they don\u2019t contain data that\u2019s relevant to the query.</p> <p>Suppose you have a Delta table with data stored in two files and has the following metadata.</p> <pre><code>filename    min_name    max_name    min_age max_age\nfileA       alice       joy         12      46  \nfileB       allan       linda       34      78\n</code></pre> <p>Suppose you want to run the following query: <code>select * from the_table where age &amp;lt; 20</code>.</p> <p>The engine only needs to read <code>fileA</code> to execute this query.  <code>fileB</code> has a <code>min_age</code> of 34, so we know there aren\u2019t any rows of data with an <code>age</code> less than 20.</p> <p>The benefit of file skipping depends on the query and the data layout of the Delta table.  Some queries cannot take advantage of any file skipping.  Here\u2019s an example query that does not benefit from file skipping: <code>select * from the_table group by age</code>.</p> <p>Let\u2019s recreate this example with Polars to drive the point home.</p> <p>Start by writing out one file of data:</p> <pre><code>import polars as pl\nfrom deltalake import DeltaTable\n\ndf = pl.DataFrame({\"name\": [\"alice\", \"cat\", \"joy\"], \"age\": [12, 35, 46]})\ndf.write_delta(\"tmp/a_table\")\n</code></pre> <p>Now, write out another file of data:</p> <pre><code>df = pl.DataFrame({\"name\": [\"allan\", \"brian\", \"linda\"], \"age\": [34, 35, 78]})\ndf.write_delta(\"tmp/a_table\", mode=\"append\")\n</code></pre> <p>Here are the contents of the Delta table:</p> <pre><code>tmp/a_table\n\u251c\u2500\u2500 0-7d414a88-a634-4c2f-9c5b-c29b6ee5f524-0.parquet\n\u251c\u2500\u2500 1-0617ef60-b17b-46a5-9b0f-c7dda1b73eee-0.parquet\n\u2514\u2500\u2500 _delta_log\n    \u251c\u2500\u2500 00000000000000000000.json\n    \u2514\u2500\u2500 00000000000000000001.json\n</code></pre> <p>Now run a query to fetch all the records where the age is less than 20:</p> <pre><code>pl.scan_delta(\"tmp/a_table\").filter(pl.col(\"age\") &lt; 20).collect()\n</code></pre> <pre><code>+-------+-----+\n| name  | age |\n| ---   | --- |\n| str   | i64 |\n+=============+\n| alice | 12  |\n+-------+-----+\n</code></pre> <p>Polars can use the Delta table metadata to skip the file that does not contain data relevant to the query.</p>"},{"location":"how-delta-lake-works/delta-lake-file-skipping/#how-delta-lake-implements-file-skipping","title":"How Delta Lake implements file skipping","text":"<p>Here\u2019s how engines execute queries on Delta tables:</p> <ul> <li>Start by reading the transaction log to get the file paths, file sizes, and min/max value for each column</li> <li>Parse the query and push down the predicates to skip files</li> <li>Read the minimal subset of the files needed for the query</li> </ul> <p>Some file formats don\u2019t allow for file skipping.  For example, CSV files don\u2019t have file-level metadata, so query engines can\u2019t read a minimal subset of the data.  The query engine has to check all the files, even if they don\u2019t contain any relevant data.</p> <p>When data is in Parquet files, the query engine can open up all the files, read the footers, build the file-level metadata, and perform file skipping.  Fetching metadata in each file is slower than grabbing the pre-built file-level metadata from the transaction log.</p> <p>Now, let\u2019s see how to structure your tables to allow for more file skipping.</p>"},{"location":"how-delta-lake-works/delta-lake-file-skipping/#file-skipping-for-different-file-sizes","title":"File skipping for different file sizes","text":"<p>Delta tables store data in files.  Smaller files allow for more file skipping compared to bigger files.</p> <p>However, an excessive number of small files isn\u2019t good because it creates I/O overhead and slows down queries.</p> <p>Your Delta tables should have files that are \u201cright-sized\u201d.  For a table with 150 GB of data, 5 GB files would probably be too large, and 10 KB files would be too small.  It\u2019s generally best to store data in files that are between 100 MB and 1 GB.</p> <p>Delta Lake has an optimize function that performs small file compaction, so you don\u2019t need to program this logic yourself.</p> <p>Now, let's investigate how to store data in files to maximize the file skipping opportunities.</p>"},{"location":"how-delta-lake-works/delta-lake-file-skipping/#how-to-maximize-file-skipping","title":"How to maximize file skipping","text":"<p>You can maximize file-skipping by colocating similar data in the same files.</p> <p>Suppose you have a table with test scores and frequently run queries that filter based on the <code>test_score</code> column.</p> <pre><code>filename    min_test_score  max_test_score\nfileA       45              100\nfileB       65              98\nfileC       50              96\n</code></pre> <p>Suppose you want to run the following query: <code>select * from exams where test_score &gt; 90</code>.</p> <p>This query cannot skip files, given the current organization of the data.  You can rearrange the data to colocate similar test scores in the same files to allow for file skipping.  Here\u2019s the new layout: </p> <pre><code>filename    min_test_score  max_test_score\nfileD       45              70\nfileE       55              80\nfileF       78              100\n</code></pre> <p>The query (<code>select * from exams where test_score &gt; 90</code>) can skip two of the three files with the new Delta table layout.  The query engine only has to read <code>fileF</code> for this query.</p> <p>Now, let\u2019s look at how file skipping works with string values.</p>"},{"location":"how-delta-lake-works/delta-lake-file-skipping/#how-file-skipping-works-with-strings","title":"How file skipping works with strings","text":"<p>File skipping is also effective when filtering on string values.</p> <p>Suppose you have a table with <code>person_name</code> and <code>country</code> columns.  There are millions of rows of data.  Here are the first three rows of data:</p> <pre><code>person_name country\nperson1     angola\nperson2     china\nperson3     mexico\n</code></pre> <p>The Delta table contains three files with the following metadata:</p> <pre><code>filename    min_country max_country\nfileA       albania     mali\nfileB       libia       paraguay\nfileC       oman        zimbabwe\n</code></pre> <p>Suppose you want to run the following query: <code>select * from some_people where country = 'austria'</code>.</p> <p>You only need to read the data in <code>fileA</code> to run this query.  The <code>min_country</code> value for <code>fileB</code> and <code>fileC</code> are greater than \u201caustria\u201d, so we know those files don\u2019t contain any data relevant to the query.</p> <p>File skipping can also be a robust optimization for string values.  Now, let\u2019s see how file skipping works for partitioned tables.</p>"},{"location":"how-delta-lake-works/delta-lake-file-skipping/#file-skipping-for-partitioned-tables","title":"File skipping for partitioned tables","text":"<p>You can partition Delta tables for file skipping as well.  Suppose we have the same data as in the previous section, but the table is partitioned by <code>country</code>.</p> <p>Here\u2019s the Delta table:</p> <pre><code>filename    partition\nfileA       albania\nfileB       libia\nfileC       oman\nfileD       jamaica\nfileE       albania\nfileF       oman\n</code></pre> <p>Suppose you want to run the following query on this partitioned table: <code>select * from some_partitioned_table where country = 'albania'</code>.</p> <p>You only need to read <code>fileA</code> and <code>fileE</code> to execute this query.  Delta Lake provides the file-level partition metadata in the transaction log so that this query will run quickly.</p>"},{"location":"how-delta-lake-works/delta-lake-file-skipping/#conclusion","title":"Conclusion","text":"<p>Delta Lake allows for file skipping, which is a powerful performance optimization.</p> <p>Delta Lake also provides built-in utilities to colocate data in the same files like partitioning, Z Ordering, and compaction to improve file skipping.</p> <p>Delta Lake users need to know how to assess the tradeoffs of these techniques to optimize file skipping.  Users also need to understand the most frequent query patterns of their tables to best allow for file maximal file skipping.</p>"},{"location":"integrations/delta-lake-arrow/","title":"Delta Lake Arrow Integrations","text":"<p>Delta Lake tables can be exposed as Arrow tables and Arrow datasets, which allows for interoperability with a variety of query engines.</p> <p>This page shows you how to convert Delta tables to Arrow data structures and teaches you the difference between Arrow tables and Arrow datasets.  Tables are \"eager\" and datasets are \"lazy\", which has important performance implications, keep reading to learn more!</p>"},{"location":"integrations/delta-lake-arrow/#delta-lake-to-arrow-dataset","title":"Delta Lake to Arrow Dataset","text":"<p>Delta tables can easily be exposed as Arrow datasets.  This makes it easy for any query engine that can read Arrow datasets to read a Delta table.</p> <p>Let's take a look at the h2o groupby dataset that contains 9 columns of data.  Here are three representative rows of data:</p> <pre><code>+-------+-------+--------------+-------+-------+--------+------+------+---------+\n| id1   | id2   | id3          |   id4 |   id5 |    id6 |   v1 |   v2 |      v3 |\n|-------+-------+--------------+-------+-------+--------+------+------+---------|\n| id016 | id046 | id0000109363 |    88 |    13 | 146094 |    4 |    6 | 18.8377 |\n| id039 | id087 | id0000466766 |    14 |    30 | 111330 |    4 |   14 | 46.7973 |\n| id047 | id098 | id0000307804 |    85 |    23 | 187639 |    3 |    5 | 47.5773 |\n+-------+-------+--------------+-------+-------+--------+------+------+---------+\n</code></pre> <p>Here's how to expose the Delta table as a PyArrow dataset and run a query with DuckDB:</p> <pre><code>import duckdb\nfrom deltalake import DeltaTable\n\ntable = DeltaTable(\"delta/G1_1e9_1e2_0_0\")\ndataset = table.to_pyarrow_dataset()\nquack = duckdb.arrow(dataset)\nquack.filter(\"id1 = 'id016' and v2 &gt; 10\")\n</code></pre> <p>Here's the result:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   id1   \u2502   id2   \u2502     id3      \u2502  id4  \u2502  id5  \u2502   id6   \u2502  v1   \u2502  v2   \u2502    v3     \u2502\n\u2502 varchar \u2502 varchar \u2502   varchar    \u2502 int32 \u2502 int32 \u2502  int32  \u2502 int32 \u2502 int32 \u2502  double   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 id016   \u2502 id054   \u2502 id0002309114 \u2502    62 \u2502    95 \u2502 7180859 \u2502     4 \u2502    13 \u2502  7.750173 \u2502\n\u2502 id016   \u2502 id044   \u2502 id0003968533 \u2502    63 \u2502    98 \u2502 2356363 \u2502     4 \u2502    14 \u2502  3.942417 \u2502\n\u2502 id016   \u2502 id034   \u2502 id0001082839 \u2502    58 \u2502    73 \u2502 8039808 \u2502     5 \u2502    12 \u2502 76.820135 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ? rows (&gt;9999 rows, 3 shown)                                                 9 columns \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Arrow datasets allow for the predicates to get pushed down to the query engine, so the query is executed quickly.</p>"},{"location":"integrations/delta-lake-arrow/#delta-lake-to-arrow-table","title":"Delta Lake to Arrow Table","text":"<p>You can also run the same query with DuckDB on an Arrow table:</p> <pre><code>quack = duckdb.arrow(table.to_pyarrow_table())\nquack.filter(\"id1 = 'id016' and v2 &gt; 10\")\n</code></pre> <p>This returns the same result, but it runs slower.</p>"},{"location":"integrations/delta-lake-arrow/#difference-between-arrow-dataset-and-arrow-table","title":"Difference between Arrow Dataset and Arrow Table","text":"<p>Arrow Datasets are lazy and allow for full predicate pushdown unlike Arrow tables which are eagerly loaded into memory.</p> <p>The previous DuckDB queries were run on a 1 billion row dataset that's roughly 50 GB when stored as an uncompressed CSV file.  Here are the runtimes when the data is stored in a Delta table and the queries are executed on a 2021 Macbook M1 with 64 GB of RAM:</p> <ul> <li>Arrow table: 17.1 seconds</li> <li>Arrow dataset: 0.01 seconds</li> </ul> <p>The query runs much faster on an Arrow dataset because the predicates can be pushed down to the query engine and lots of data can be skipped.</p> <p>Arrow tables are eagerly materialized in memory and don't allow for the same amount of data skipping.</p>"},{"location":"integrations/delta-lake-arrow/#multiple-query-engines-can-query-arrow-datasets","title":"Multiple query engines can query Arrow Datasets","text":"<p>Other query engines like DataFusion can also query Arrow datasets, see the following example:</p> <pre><code>from datafusion import SessionContext\n\nctx = SessionContext()\nctx.register_dataset(\"my_dataset\", table.to_pyarrow_dataset())\nctx.sql(\"select * from my_dataset where v2 &gt; 5\")\n</code></pre> <p>Here's the result:</p> <pre><code>+-------+-------+--------------+-----+-----+--------+----+----+-----------+\n| id1   | id2   | id3          | id4 | id5 | id6    | v1 | v2 | v3        |\n+-------+-------+--------------+-----+-----+--------+----+----+-----------+\n| id082 | id049 | id0000022715 | 97  | 55  | 756924 | 2  | 11 | 74.161136 |\n| id053 | id052 | id0000113549 | 19  | 56  | 139048 | 1  | 10 | 95.178444 |\n| id090 | id043 | id0000637409 | 94  | 50  | 12448  | 3  | 12 | 60.21896  |\n+-------+-------+--------------+-----+-----+--------+----+----+-----------+\n</code></pre> <p>Any query engine that's capable of reading an Arrow table/dataset can read a Delta table.</p>"},{"location":"integrations/delta-lake-arrow/#conclusion","title":"Conclusion","text":"<p>Delta tables can easily be exposed as Arrow tables/datasets.</p> <p>Therefore any query engine that can read an Arrow table/dataset can also read a Delta table.</p> <p>Arrow datasets allow for more predicates to be pushed down to the query engine, so they can perform better performance than Arrow tables.</p>"},{"location":"integrations/delta-lake-daft/","title":"Using Delta Lake with Daft","text":"<p>Daft is a framework for ETL, analytics, and ML/AI at scale with a familiar Python dataframe API, implemented in Rust.</p> <p>Daft and Delta Lake work really well together. Daft provides unified compute for Delta Lake\u2019s unified storage. Together, Delta Lake and Daft give you high-performance query optimization and distributed compute on massive datasets.</p> <p>Delta Lake is a great storage format for Daft workloads. Delta gives Daft users:</p> <ul> <li>Query optimization via file-skipping and column pruning</li> <li>Versioning for easy time travel functionality</li> <li>Faster reads via Z-ordering</li> <li>ACID transactions and schema enforcement for more reliable reads and writes</li> </ul> <p>For Delta Lake users, Daft is a great data processing tool because it gives you the following features:</p> <ul> <li>Multimodal Dataframes: read, write and transform multimodal data incl. images, JSON, PDF, audio, etc.</li> <li>Parallel + Distributed Reads: Daft parallelizes Delta Lake table reads over all cores of your machine, if using the default multithreading runner, or all cores + machines of your Ray cluster, if using the distributed Ray runner.</li> <li>Skipping Filtered Data: Daft implements automatic partition pruning and stats-based file pruning for filter predicates, skipping data that doesn\u2019t need to be read.</li> </ul> <p>Let's look at how to use Delta Lake with Daft.</p>"},{"location":"integrations/delta-lake-daft/#installing-daft-for-delta-lake","title":"Installing Daft for Delta Lake","text":"<p>The easiest way to use the Delta Lake table format with Daft DataFrames is to install Daft with the <code>[deltalake]</code> extras using <code>pip</code>:</p> <pre><code>!pip install -U \"getdaft[deltalake]\"\n</code></pre> <p>This adds the <code>deltalake</code> Python package to your install. This package is used to fetch metadata about the Delta Lake table, such as paths to the underlying Parquet files and table statistics. You can of course also install the <code>deltalake</code> manually.</p>"},{"location":"integrations/delta-lake-daft/#read-delta-lake-into-a-daft-dataframe","title":"Read Delta Lake into a Daft DataFrame","text":"<p>You can easily read Delta Lake tables into a Daft DataFrame using the <code>read_delta_lake</code> method. Let's use it to read some data stored in a Delta Lake on disk. You can access the data stored as a Delta Lake on Github</p> <pre><code>import daft\n\n# read delta table into Daft DataFrame\ndf = daft.read_delta_lake(\"path/to/delta_table\")\n</code></pre> <p>You can also read in Delta Lake data from remote sources like S3:</p> <pre><code># table_uri = (\n#     \"s3://daft-public-datasets/red-pajamas/\"\n#     \"stackexchange-sample-north-germanic-deltalake\"\n# )\n# df = daft.read_delta_lake(table_uri)\n</code></pre> <pre><code>df\n</code></pre> first_nameUtf8last_nameUtf8countryUtf8continentUtf8 (No data to display: Dataframe not materialized) <p>Daft DataFrames are lazy by default. This means that the contents will not be computed (\"materialized\") unless you explicitly tell Daft to do so. This is best practice for working with larger-than-memory datasets and parallel/distributed architectures.</p> <p>The Delta table we have just loaded only has 5 rows. You can materialize it in memory using the <code>.collect</code> method:</p> <pre><code>&gt; df.collect()\n\n|    | first_name   | last_name   | country   | continent   |\n|---:|:-------------|:------------|:----------|:------------|\n|  0 | Ernesto      | Guevara     | Argentina | NaN         |\n|  1 | Bruce        | Lee         | China     | Asia        |\n|  2 | Jack         | Ma          | China     | Asia        |\n|  3 | Wolfgang     | Manche      | Germany   | NaN         |\n|  4 | Soraya       | Jala        | Germany   | NaN         |\n</code></pre>"},{"location":"integrations/delta-lake-daft/#write-to-delta-lake","title":"Write to Delta Lake","text":"<p>You can use <code>write_deltalake</code> to write a Daft DataFrame to a Delta table:</p> <pre><code>df.write_deltalake(\"tmp/daft-table\", mode=\"overwrite\")\n</code></pre> <p>Daft supports multiple write modes. See the Daft documentation for more information.</p>"},{"location":"integrations/delta-lake-daft/#what-can-i-do-with-a-daft-dataframe","title":"What can I do with a Daft DataFrame?","text":"<p>Daft gives you full-featured DataFrame functionality, similar to what you might be used to from pandas, Dask or PySpark.</p> <p>On top of this, Daft also gives you:</p> <ul> <li>Multimodal data type support to work with Images, URLs, Tensors and more</li> <li>Expressions API for easy column transformations</li> <li>UDFs for multi-column transformation, incl. ML applications</li> </ul> <p>Check out the Daft User Guide for a complete list of DataFrame operations.</p>"},{"location":"integrations/delta-lake-daft/#data-skipping-optimizations","title":"Data Skipping Optimizations","text":"<p>Delta Lake and Daft work together to give you highly-optimized query performance.</p> <p>Delta Lake stores your data in Parquet files. Parquet is a columnar row format that natively supports column pruning. If your query only needs to read data from a specific column or set of columns, you don't need to read in the entire file. This can save you lots of time and compute.</p> <p>Delta Lake goes beyond the basic Parquet features by also giving you:</p> <ul> <li>partitioned reads</li> <li>file skipping via z-ordering.</li> </ul> <p>This is great for Daft users who want to run efficient queries on large-scale data.</p> <p>Let's look at how this works.</p>"},{"location":"integrations/delta-lake-daft/#partitioned-reads","title":"Partitioned Reads","text":"<p>You may have noticed the Delta Lake warning at the top when we first called <code>collect()</code> on our DataFrame:</p> <p><code>WARNING: has partitioning keys = [PartitionField(country#Utf8)], but no partition filter was specified. This will result in a full table scan.</code></p> <p>Delta Lake is informing us that the data is partitioned on the <code>country</code> column.</p> <p>Daft does some nice magic here to help you out. The Daft query optimizer has access to all of the Delta Lake metadata. This means it can optimize your query by skipping the partitions that are not relevant for this query. Instead of having to read all 3 partitions, we can read only 1 and get the same result, just faster!</p> <pre><code># Filter on partition columns will result in efficient partition pruning; non-matching partitions will be skipped.\n&gt; df.where(df[\"country\"] == \"Germany\").show()\n\n|    | first_name   | last_name   | country   |   continent |\n|---:|:-------------|:------------|:----------|------------:|\n|  0 | Wolfgang     | Manche      | Germany   |         nan |\n|  1 | Soraya       | Jala        | Germany   |         nan |\n</code></pre> <p>You can use the <code>explain()</code> method to see how Daft is optimizing your query.</p> <p>Since we've already called <code>collect</code> on our DataFrame, it is already in memory. So below we copy the output of <code>explain(show_all=True)</code> before calling <code>collect</code>:</p> <p>Running <code>df.where(df[\"continent\"] == \"Asia\").explain(True)</code> returns:</p> <pre><code>(...)\n\n== Optimized Logical Plan ==\n\n* PythonScanOperator: DeltaLakeScanOperator(None)\n|   File schema = first_name#Utf8, last_name#Utf8, country#Utf8, continent#Utf8\n|   Partitioning keys = [PartitionField(country#Utf8)]\n|   Filter pushdown = col(continent) == lit(\"Asia\")\n|   Output schema = first_name#Utf8, last_name#Utf8, country#Utf8, continent#Utf8\n\n\n== Physical Plan ==\n\n* TabularScan:\n|   Num Scan Tasks = 3\n|   Estimated Scan Bytes = 3045\n|   Clustering spec = { Num partitions = 3 }\n</code></pre> <p>Whereas running <code>df.where(df[\"country\"] == \"Germany\").explain(True)</code> returns:</p> <pre><code>(...)\n\n== Optimized Logical Plan ==\n\n* PythonScanOperator: DeltaLakeScanOperator(None)\n|   File schema = first_name#Utf8, last_name#Utf8, country#Utf8, continent#Utf8\n|   Partitioning keys = [PartitionField(country#Utf8)]\n|   Partition Filter = col(country) == lit(\"Germany\")\n|   Output schema = first_name#Utf8, last_name#Utf8, country#Utf8, continent#Utf8\n\n\n== Physical Plan ==\n\n* TabularScan:\n|   Num Scan Tasks = 1\n|   Estimated Scan Bytes = 1025\n|   Clustering spec = { Num partitions = 1 }\n</code></pre> <p>Running a query on a non-partitioned column like <code>continent</code> will require reading in all partitions, totalling 3045 bytes in the case of this toy example.</p> <p>Instead, running a query on a partitioned column (<code>country</code> in this case) means Daft only has to read only the relevant partition, saving us a ~60% of the compute. This has huge impacts when you're working at scale.</p>"},{"location":"integrations/delta-lake-daft/#z-ordering-for-enhanced-file-skipping","title":"Z-Ordering for enhanced file skipping","text":"<p>Z-ordering stores similar data close together to optimize query performance. This is especially useful when you're querying on one or multiple columns.</p> <p>Using Z-Ordered Delta tables instead of regular Parquet can give Daft users significant speed-ups.</p> <p>Read High-Performance Querying on Massive Delta Lake Tables with Daft for an in-depth benchmarking of query optimization with Delta Lake and Daft using partitioning and Z-ordering.</p>"},{"location":"integrations/delta-lake-daft/#daft-gives-you-multimodal-data-type-support","title":"Daft gives you Multimodal Data Type Support","text":"<p>Daft has a rich multimodal type-system with support for Python objects, Images, URLs, Tensors and more.</p> <p>The Expressions API provides useful tools to work with these data types. By combining multimodal data support with the User-Defined Functions API you can run ML workloads right within your DataFrame.</p> <p>Take a look at the notebook in the <code>delta-examples</code> Github repository for a closer look at how Daft handles URLs, images and ML applications.</p>"},{"location":"integrations/delta-lake-daft/#contribute-to-daft","title":"Contribute to <code>daft</code>","text":"<p>Excited about Daft and want to contribute? Join them on Github \ud83d\ude80</p> <p>Like many technologies, Daft collects some non-identifiable telemetry to improve the product. This is strictly non-identifiable metadata. You can disable telemetry by setting the following environment variable: <code>DAFT_ANALYTICS_ENABLED=0</code>. Read more in the Daft documentation.</p>"},{"location":"integrations/delta-lake-dagster/","title":"Using Delta Lake with Dagster\u00b6","text":"<p>Delta Lake is a great storage format for Dagster workflows. This page will explain why and how to use Delta Lake with Dagster.</p> <p>You will learn how to use the Delta Lake I/O Manager to read and write your Dagster Software-Defined Assets (SDAs). You will also learn about the unique advantages Delta Lake offers the Dagster community.</p> <p>Here are some of the benefits that Delta Lake provides Dagster users:</p> <ul> <li>native PyArrow integration for lazy computation of large datasets,</li> <li>more efficient querying with file skipping via Z Ordering and liquid clustering</li> <li>built-in vacuuming to remove unnecessary files and versions</li> <li>ACID transactions for reliable writes</li> <li>smooth versioning integration so that versions can be use to trigger downstream updates.</li> <li>surfacing table stats based on the file statistics</li> </ul>"},{"location":"integrations/delta-lake-dagster/#dagster-io-managers","title":"Dagster I/O Managers","text":"<p>Dagster uses I/O Managers to simplify data reads and writes. I/O Managers help you reduce boilerplate code by storing Dagster Asset and Op outputs and loading them as inputs to downstream objects. They make it easy to change where and how your data is stored.</p> <p>You only need to define your I/O Manager and its settings (such as storage location and schema) once and the I/O Manager will take care of correctly reading and writing all your Dagster Assets automatically.</p> <p>If you need lower-level access than the Dagster I/O Managers provide, take a look at the Delta Table Resource.</p>"},{"location":"integrations/delta-lake-dagster/#the-delta-lake-io-manager","title":"The Delta Lake I/O Manager","text":"<p>You can easily read and write Delta Lake Tables from Dagster by using the <code>DeltaLakeIOManager()</code>.</p> <p>Install the DeltaLakeIOManager:</p> <pre><code>pip install dagster-deltalake\n</code></pre> <p>Next, configure the following settings in your project\u2019s <code>__init__.py</code> file:</p> <ul> <li><code>io_manager</code>: set this to <code>DeltaLakeIOManager()</code>, this sets the default I/O Manager for all your Assets</li> </ul> <p>Within the DeltaLakeIOManager, define:</p> <ul> <li><code>root_uri</code>: the root path where your Delta Tables will be created</li> <li><code>storage_options</code>: configuration for accessing storage location</li> <li><code>schema</code>: name of schema to use (optional, defaults to public)</li> </ul> <pre><code>defs = Definitions(\n   assets=all_assets,\n   resources={\n        \"io_manager\": DeltaLakePyarrowIOManager(\n            root_uri=\"path/to/deltalake\",\n            storage_options=LocalConfig(),\n            schema=\"dagster_deltalake\",\n        ),\n   },\n)\n</code></pre> <p>Now, when you materialize an Asset, it will be saved as a Delta Lake in a folder <code>dagster_deltalake/asset_name</code> under the root directory <code>path/to/deltalake</code>.</p> <p>The default Delta Lake I/O Manager supports Arrow reads and writes. You can also use the Delta Lake I/O Manager with pandas or polars.</p>"},{"location":"integrations/delta-lake-dagster/#creating-delta-lake-tables-with-dagster","title":"Creating Delta Lake Tables with Dagster","text":"<p>You don\u2019t need to do anything else to store your Dagster Assets as Delta Lake tables. The I/O Manager will handle storing and loading your Assets as Delta Lake tables from now on.</p> <p>You can proceed to write Dagster code as you normally would. For example, you can create an Asset that reads in some toy data about animals and writes it out to an Arrow Table:</p> <pre><code>import pyarrow as pa\nfrom pyarrow import csv\n\nfrom dagster import asset\n\n@asset\ndef raw_dataset() -&gt; pa.Table:\n   n_legs = pa.array([2, 4, None, 100])\n   animals = pa.array([\"Flamingo\", \"Horse\", \"Brittle stars\", \"Centipede\"])\n   data = {'n_legs': n_legs, 'animals': animals}\n\n   return pa.Table.from_pydict(data)\n</code></pre> <p>When you materialize the Asset defined above (using the config settings defined earlier), the Delta Lake I/O Manager will create the table <code>dagster_deltalake/iris_dataset</code> if it doesn\u2019t exist yet.</p>"},{"location":"integrations/delta-lake-dagster/#overwrites-when-rematerializing-assets","title":"Overwrites when Rematerializing Assets","text":"<p>If the table does already exist at the specified location, the Delta Lake I/O Manager will perform an overwrite. Delta Lake\u2019s transaction log maintains a record of all changes to your Delta Lake tables. You can inspect the record of changes to your Delta Lake tables by taking a look at these transaction logs.</p>"},{"location":"integrations/delta-lake-dagster/#loading-delta-lake-tables-in-downstream-assets","title":"Loading Delta Lake Tables in Downstream Assets","text":"<p>You can use Assets stored as Delta Lake tables as input to downstream Assets. Dagster and the Delta Lake I/O Manager make this easy for you.</p> <p>You can write Dagster code as you normally would. Pass the upstream Asset as an argument to the downstream object to set up the dependency. Make sure to define the correct data type.</p> <p>The Delta Lake I/O Manager will handle reading and writing the data from your Delta Lake.</p> <pre><code>import pyarrow as pa\nfrom dagster import asset\n\n# ... raw_dataset asset is defined here ...\n\n@asset\ndef clean_dataset(raw_dataset: pa.Table) -&gt; pa.Table:\n   return raw_dataset.drop_null()\n</code></pre>"},{"location":"integrations/delta-lake-dagster/#reading-existing-delta-lake-tables-into-dagster","title":"Reading Existing Delta Lake Tables into Dagster","text":"<p>You can make existing Delta Lake tables (that were not created in Dagster) available to your Dagster assets. Use the <code>SourceAsset</code> object and pass the table name as the key argument:</p> <pre><code>from dagster import SourceAsset\n\niris_harvest_data = SourceAsset(key=\"more_animal_data\")\n</code></pre> <p>This will load a table <code>more_animal_data</code> located at <code>&lt;root_uri&gt;/&lt;schema&gt;</code> as configured in the Definitions object above (see Delta Lake I/O Manager section).</p>"},{"location":"integrations/delta-lake-dagster/#column-pruning","title":"Column Pruning","text":"<p>You can often improve the efficiency of your computations by only loading specific columns of your Delta table. This is called column pruning.</p> <p>With the Delta Lake I/O manager, you can select specific columns to load defining the <code>columns</code> in the <code>metadata</code> parameter of the <code>AssetIn</code> that loads the upstream Asset:</p> <pre><code>import pyarrow as pa\nfrom dagster import AssetIn, asset\n\n# this example uses the clean_dataset Asset defined earlier\n\n@asset(\n       ins={\n           \"mammal_bool\": AssetIn(\n               key=\"clean_dataset\",\n               metadata={\"columns\": [\"is_mammal\", \"animals\"]},\n           )\n       }\n)\ndef mammal_data(mammal_bool: pa.Table) -&gt; pa.Table:\n   mammals = mammal_bool[\"is_mammal\"].cast(\"bool\")\n   animals = mammal_bool[\"animals\"]\n   data = {\"mammal_bool\": mammals, \"animals\": animals}\n   return pa.Table.from_pydict(data)\n</code></pre> <p>Here, we select only the <code>sepal_length_cm</code> and <code>sepal_width_cm</code> columns from the <code>iris_dataset</code> table and load them into an <code>AssetIn</code> object called <code>iris_sepal</code>. This AssetIn object is used to create a new Asset <code>sepal_data</code>, containing only the selected columns.</p>"},{"location":"integrations/delta-lake-dagster/#working-with-partitioned-assets","title":"Working with Partitioned Assets","text":"<p>Partitioning is an important feature of Delta Lake that can make your computations more efficient. The Delta Lake I/O manager helps you read and write partitioned data easily. You can work with static partitions, time-based partitions, multi-partitions, and dynamic partitions.</p> <p>For example, you can partition the Iris dataset on the <code>species</code> column as follows:</p> <pre><code>import pyarrow as pa\n\nfrom dagster import StaticPartitionsDefinition, asset\n\n@asset(\n  partitions_def=StaticPartitionsDefinition(\n      [\"Human\", \"Horse\",]\n  ),\n  metadata={\"partition_expr\": \"n_legs\"},\n)\ndef dataset_partitioned(\n   context,\n   clean_dataset: pa.Table,\n   ) -&gt; pa.Table:\n   animals = context.asset_partition_key_for_output()\n   table = clean_dataset\n\n   return table.filter(pc.field(\"animals\") == animals)\n</code></pre> <p>To partition your data, make sure to include the relevant <code>partitions_def</code> and <code>metadata</code> arguments to the <code>@asset</code> decorator. Refer to the Dagster documentation on partitioning assets for more information.</p>"},{"location":"integrations/delta-lake-dagster/#using-delta-lake-and-dagster-with-pandas","title":"Using Delta Lake and Dagster with Pandas","text":"<p>To read and write data to Delta Lake using pandas, use the <code>DeltaLakePandasIOManager()</code>.</p> <p>You will need to install it using:</p> <pre><code>pip install dagster-deltalake-pandas\n</code></pre> <p>In your <code>Definitions</code> object, change the <code>io_manager</code> to <code>DeltaLakePandasIOManager()</code>:</p> <pre><code>from dagster_deltalake_pandas import DeltaLakePandasIOManager\n\n\ndefs = Definitions(\n   assets=all_assets,\n   resources={\n        \"io_manager\": DeltaLakePandasIOManager(\n            root_uri=\"path/to/deltalake\",\n            storage_options=LocalConfig(),\n            schema=\"dagster_deltalake\",\n        ),\n   },\n)\n</code></pre> <p>Now you can read and write Dagster Assets defined as pandas DataFrames in Delta Lake format. For example:</p> <pre><code>import pandas as pd\nfrom dagster import asset\n\n@asset\ndef iris_dataset() -&gt; pd.DataFrame:\n   return pd.read_csv(\n       \"https://docs.dagster.io/assets/iris.csv\",\n       names=[\n           \"sepal_length_cm\",\n           \"sepal_width_cm\",\n           \"petal_length_cm\",\n           \"petal_width_cm\",\n           \"species\",\n       ],\n   )\n</code></pre>"},{"location":"integrations/delta-lake-dagster/#using-delta-lake-and-dagster-with-polars","title":"Using Delta Lake and Dagster with Polars","text":"<p>To read and write data to Delta Lake using polars, use the <code>DeltaLakePolarsIOManager()</code>.</p> <p>You will need to install it using:</p> <pre><code>pip install dagster-deltalake-polars\n</code></pre> <p>In your <code>Definitions</code> object, change the <code>io_manager</code> to <code>DeltaLakePolarsIOManager()</code>:</p> <pre><code>from dagster_deltalake_polars import DeltaLakePolarsIOManager\n\ndefs = Definitions(\n   assets=all_assets,\n   resources={\n        \"io_manager\": DeltaLakePolarsIOManager(\n            root_uri=\"path/to/deltalake\",\n            storage_options=LocalConfig(),\n            schema=\"dagster_deltalake\",\n        ),\n   },\n)\n</code></pre> <p>Now you can read and write Dagster Assets defined as Polars DataFrames in Delta Lake format. For example:</p> <pre><code>import polars as pl\nfrom dagster import asset\n\n\n@asset\ndef iris_dataset() -&gt; pl.DataFrame:\n   return pl.read_csv(\n       \"https://docs.dagster.io/assets/iris.csv\",\n       new_columns=[\n          \"sepal_length_cm\",\n          \"sepal_width_cm\",\n          \"petal_length_cm\",\n          \"petal_width_cm\",\n          \"species\",\n      ],\n   has_header=False\n)\n</code></pre>"},{"location":"integrations/delta-lake-dagster/#delta-lake-table-resource","title":"Delta Lake Table Resource","text":"<p>I/O managers are a helpful tool in many common usage situations. But when you need lower-level access, the I/O Manager might not be the right tool to use. In these cases you may want to use the Delta Lake Table Resource.</p> <p>The Delta Lake Table Resource is a low-level access method to the table object. It gives you more fine-grained control and allows for modeling of more complex data. You can also use the Table Resource to run optimization and vacuuming jobs.</p>"},{"location":"integrations/delta-lake-dagster/#schema-and-constraint-enforcement","title":"Schema and Constraint Enforcement","text":"<p>Delta Lake provides built-in checks to ensure schema consistency when appending data to a table, as well as the ability to evolve the schema. This is a great feature for the Dagster community as it prevents bad data from being appended to tables, ensuring data consistency and accuracy.</p> <p>Read more about how to add constraints to a table in the Delta Lake documentation.</p>"},{"location":"integrations/delta-lake-dagster/#z-ordering","title":"Z-Ordering","text":"<p>Delta Lake offers Z-ordering functionality to colocate similar data in the same files. This can make your Delta Table queries much more efficient via file skipping. Dagster users can now benefit from this great feature through the Delta Lake I/O Manager.</p> <p>Read more about Z-Ordering on the Delta Lake blog.</p>"},{"location":"integrations/delta-lake-dagster/#contribute","title":"Contribute","text":"<p>To contribute to the Delta Lake and Dagster integration, go to [link]</p>"},{"location":"integrations/delta-lake-dask/","title":"Using Delta Lake with Dask","text":"<p>Delta Lake is a great storage format for Dask analyses. This page explains why and how to use Delta Lake with Dask.</p> <p>You will learn how to read Delta Lakes into Dask DataFrames, how to query Delta tables with Dask, and the unique advantages Delta Lake offers the Dask community.</p> <p>Here are some of the benefits that Delta Lake provides Dask users:</p> <ul> <li>better performance with file skipping</li> <li>enhanced file skipping via Z Ordering</li> <li>ACID transactions for reliable writes</li> <li>easy time-travel functionality</li> </ul> <p>\u2757\ufe0f dask-deltatable currently works with deltalake&lt;=13.0. See https://github.com/dask-contrib/dask-deltatable/issues/65</p>"},{"location":"integrations/delta-lake-dask/#install-dask-deltatable","title":"Install Dask-Deltatable","text":"<p>To use Delta Lake with Dask, first install the library using</p> <pre><code>pip install dask-deltatable\n</code></pre>"},{"location":"integrations/delta-lake-dask/#reading-delta-tables-into-a-dask-dataframe","title":"Reading Delta Tables into a Dask DataFrame","text":"<p>You can read data stored in a Delta Lake into a Dask DataFrame using <code>dask-deltatable.read_deltalake</code>.</p> <p>Let's read in a toy dataset to see what we can do with Delta Lake and Dask. You can access the data stored as a Delta Lake on Github</p> <pre><code>import dask_deltatable as ddt\n\n# read delta table into Dask DataFrame\ndelta_path = \"path/to/data/people_countries_delta_dask\"\nddf = ddt.read_deltalake(delta_path)\n</code></pre> <p>Dask is a library for efficient distributed computing and works with lazy evaluation. Function calls to <code>dask.dataframe</code> build a task graph in the background. To trigger computation, call <code>.compute()</code>:</p> <pre><code>&gt; ddf.compute()\n\n|    | first_name   | last_name   | country   | continent   |\n|---:|:-------------|:------------|:----------|:------------|\n|  0 | Ernesto      | Guevara     | Argentina | NaN         |\n|  0 | Bruce        | Lee         | China     | Asia        |\n|  1 | Jack         | Ma          | China     | Asia        |\n|  0 | Wolfgang     | Manche      | Germany   | NaN         |\n|  1 | Soraya       | Jala        | Germany   | NaN         |\n</code></pre> <p>You can read in specific versions of Delta tables by specifying a <code>version</code> number or a timestamp:</p> <pre><code># with specific version\nddf = ddt.read_deltalake(delta_path, version=3)\n\n# with specific datetime\nddt.read_deltalake(delta_path, datetime=\"2018-12-19T16:39:57-08:00\")\n</code></pre> <p><code>dask-deltatable</code> also supports reading from remote sources like S3 with:</p> <pre><code>ddt.read_deltalake(\"s3://bucket_name/delta_path\", version=3)\n</code></pre> <p>To read data from remote sources you'll need to make sure the credentials are properly configured in environment variables or config files. Refer to your cloud provider documentation to configure these.</p>"},{"location":"integrations/delta-lake-dask/#what-can-i-do-with-a-dask-deltatable","title":"What can I do with a Dask Deltatable?","text":"<p>Reading a Delta Lake in with <code>dask-deltatable</code> returns a regular Dask DataFrame. You can perform all the regular Dask operations on this DataFrame.</p> <p>Let's take a look at the first few rows:</p> <pre><code>&gt; ddf.head(n=3)\n\n|    | first_name   | last_name   | country   |   continent |\n|---:|:-------------|:------------|:----------|------------:|\n|  0 | Ernesto      | Guevara     | Argentina |         nan |\n</code></pre> <p><code>dask.dataframe.head()</code> shows you the first rows of the first partition in the dataframe. In this case, the first partition only has 1 row.</p> <p>This is because the Delta Lake has been partitioned by country:</p> <pre><code>&gt; !ls ../../data/people_countries_delta_dask\n_delta_log        country=Argentina country=China     country=Germany\n</code></pre> <p><code>dask-deltatable</code> neatly reads in the partitioned Delta Lake into corresponding Dask DataFrame partitions:</p> <pre><code>&gt; # see number of partitions\n&gt; ddf.npartitions\n3\n</code></pre> <p>You can inspect a single partition using <code>dask.dataframe.get_partition()</code>:</p> <pre><code>&gt; ddf.get_partition(n=1).compute()\n\n|    | first_name   | last_name   | country   | continent   |\n|---:|:-------------|:------------|:----------|:------------|\n|  0 | Bruce        | Lee         | China     | Asia        |\n|  1 | Jack         | Ma          | China     | Asia        |\n</code></pre>"},{"location":"integrations/delta-lake-dask/#perform-dask-operations","title":"Perform Dask Operations","text":"<p>Let's perform some basic computations over the Delta Lake data that's now stored in our Dask DataFrame.</p> <p>Suppose you want to group the dataset by the <code>country</code> column:</p> <pre><code>&gt; ddf.groupby(['country']).count().compute()\n\n| country   |   first_name |   last_name |   continent |\n|:----------|-------------:|------------:|------------:|\n| Argentina |            1 |           1 |           1 |\n| China     |            2 |           2 |           2 |\n| Germany   |            2 |           2 |           2 |\n</code></pre> <p>Dask executes this <code>groupby</code> operation in parallel across all available cores.</p>"},{"location":"integrations/delta-lake-dask/#map-functions-over-partitions","title":"Map Functions over Partitions","text":"<p>You can also use Dask's <code>map_partitions</code> method to map a custom Python function over all the partitions.</p> <p>Let's write a function that will replace the missing <code>continent</code> values with the right continent names.</p> <pre><code># define custom python function\n\n# get na_string\ndf = ddf.get_partition(0).compute()\nna_string = df.iloc[0].continent\nna_string\n\n# define function\ndef replace_proper(partition, na_string):\n    if [partition.country == \"Argentina\"]:\n        partition.loc[partition.country==\"Argentina\"] = partition.loc[partition.country==\"Argentina\"].replace(na_string, \"South America\")\n    if [partition.country == \"Germany\"]:\n        partition.loc[partition.country==\"Germany\"] = partition.loc[partition.country==\"Germany\"].replace(na_string, \"Europe\")\n    else:\n        pass\n    return partition\n</code></pre> <p>Now map this over all partitions in the Dask DataFrame:</p> <pre><code># define metadata and map function over partitions\n&gt; meta = dict(ddf.dtypes)\n&gt; ddf3 = ddf.map_partitions(replace_proper, na_string, meta=meta)\n&gt; ddf3.compute()\n\n|    | first_name   | last_name   | country   | continent     |\n|---:|:-------------|:------------|:----------|:--------------|\n|  0 | Ernesto      | Guevara     | Argentina | South America |\n|  0 | Bruce        | Lee         | China     | Asia          |\n|  1 | Jack         | Ma          | China     | Asia          |\n|  0 | Wolfgang     | Manche      | Germany   | Europe        |\n|  1 | Soraya       | Jala        | Germany   | Europe        |\n</code></pre>"},{"location":"integrations/delta-lake-dask/#write-to-delta-lake","title":"Write to Delta Lake","text":"<p>After doing your data processing in Dask, you can write the data back out to Delta Lake using <code>to_deltalake</code>:</p> <pre><code>ddt.to_deltalake(\"tmp/test_write\", ddf)\n</code></pre>"},{"location":"integrations/delta-lake-dask/#contribute-to-dask-deltalake","title":"Contribute to <code>dask-deltalake</code>","text":"<p>To contribute, go to the <code>dask-deltalake</code> Github repository.</p>"},{"location":"integrations/delta-lake-datafusion/","title":"Using Delta Lake with DataFusion","text":"<p>This page explains how to use Delta Lake with DataFusion.</p> <p>Delta Lake offers DataFusion users better performance and more features compared to other formats like CSV or Parquet.</p> <p>Delta Lake works well with the DataFusion Rust API and the DataFusion Python API.  It's a great option for all DataFusion users.</p> <p>Delta Lake also depends on DataFusion to implement SQL-related functionality under the hood.  We will also discuss this dependency at the end of this guide in case you're interested in learning more about the symbiotic relationship between the two libraries.</p>"},{"location":"integrations/delta-lake-datafusion/#delta-lake-performance-benefits-for-datafusion-users","title":"Delta Lake performance benefits for DataFusion users","text":"<p>Let's run some DataFusion queries on a Parquet file and a Delta table with the same data to learn more about the performance benefits of Delta Lake.</p> <p>Suppose you have the following dataset with 1 billion rows and 9 columns.  Here are the first three rows of data:</p> <pre><code>+-------+-------+--------------+-------+-------+--------+------+------+---------+\n| id1   | id2   | id3          |   id4 |   id5 |    id6 |   v1 |   v2 |      v3 |\n|-------+-------+--------------+-------+-------+--------+------+------+---------|\n| id016 | id046 | id0000109363 |    88 |    13 | 146094 |    4 |    6 | 18.8377 |\n| id039 | id087 | id0000466766 |    14 |    30 | 111330 |    4 |   14 | 46.7973 |\n| id047 | id098 | id0000307804 |    85 |    23 | 187639 |    3 |    5 | 47.5773 |\n+-------+-------+--------------+-------+-------+--------+------+------+---------+\n</code></pre> <p>Here's how to register a Delta Lake table with DataFusion:</p> <pre><code>from datafusion import SessionContext, col, functions as f\nfrom deltalake import DeltaTable\n\nctx = SessionContext()\ntable = DeltaTable(\"G1_1e9_1e2_0_0\")\nctx.register_table_provider(\"my_delta_table\", table)\n</code></pre> <p>Now query the table:</p> <pre><code>ctx.sql(\"select id1, sum(v1) as v1 from my_delta_table where id1='id096' group by id1\").show()\n</code></pre> <p>That query takes 2.8 seconds to execute.</p> <p>Let's register the same dataset as a Parquet table, run the same query, and compare the runtime difference.</p> <p>Register the Parquet table and run the query:</p> <pre><code>path = \"G1_1e9_1e2_0_0.parquet\"\nctx.register_parquet(\"my_parquet_table\", path)\nctx.sql(\"select id1, sum(v1) as v1 from my_parquet_table where id1='id096' group by id1\")\n</code></pre> <p>This query takes 5.3 seconds to run.</p> <p>Parquet stores data in row groups and DataFusion can intelligently skip row groups that don't contain relevant data, so the query is faster than a file format like CSV which doesn't support row group skipping.</p> <p>Delta Lake stores file-level metadata information in the transaction log, so it can skip entire files when queries are executed.  Delta Lake can skip entire files and then skip row groups within the individual files.  This makes Delta Lake even faster than Parquet files, especially for larger datasets spread across many files.</p>"},{"location":"integrations/delta-lake-datafusion/#dataframe-syntax","title":"Dataframe syntax","text":"<p>You can also use DataFusion's dataframe syntax to run the query above. Please note: unlike Polars or Pandas, all dataframes in DataFusion are lazy.</p> <pre><code>ctx.table(\"my_delta_table\").filter(col(\"id1\") == \"id096\").aggregate(\n    col(\"id1\"), f.sum(col(\"v1\")).alias(\"v1\")\n).show()\n</code></pre>"},{"location":"integrations/delta-lake-datafusion/#delta-lake-features-for-datafusion-users","title":"Delta Lake features for DataFusion users","text":"<p>Delta Lake also provides other features that are useful for DataFusion users like ACID transactions, concurrency protection, time travel, versioned data, and more.</p>"},{"location":"integrations/delta-lake-datafusion/#why-delta-lake-depends-on-datafusion","title":"Why Delta Lake depends on DataFusion","text":"<p>Delta Lake depends on DataFusion to provide some end-user features.</p> <p>DataFusion is useful in providing SQL-related Delta Lake features. Some examples:</p> <ul> <li>Update and merge are written in terms of SQL expressions.</li> <li>Invariants and constraints are written in terms of SQL expressions.</li> </ul> <p>Anytime we have to evaluate SQL, we need some sort of SQL engine.  We use DataFusion for that.</p>"},{"location":"integrations/delta-lake-datafusion/#conclusion","title":"Conclusion","text":"<p>Delta Lake is a great file format for DataFusion users.</p> <p>Delta Lake also uses DataFusion to provide some end-user features.</p> <p>DataFusion and Delta Lake have a wonderful symbiotic relationship and play very nicely with each other.</p> <p>See this guide for more information on Delta Lake and PyArrow and why PyArrow Datasets are often a better option than PyArrow tables.</p>"},{"location":"integrations/delta-lake-pandas/","title":"Using Delta Lake with pandas","text":"<p>Delta Lake is a great storage system for pandas analyses.  This page shows how it's easy to use Delta Lake with pandas, the unique features Delta Lake offers pandas users, and how Delta Lake can make your pandas analyses run faster.</p> <p>Delta Lake is very easy to install for pandas analyses, just run <code>pip install deltalake</code>.</p> <p>Delta Lake allows for performance optimizations, so pandas queries can run much faster than the query run on data stored in CSV or Parquet.  See the following chart for the query runtime for the a Delta tables compared with CSV/Parquet.</p> <p></p> <p>Z Ordered Delta tables run this query much faster than when the data is stored in Parquet or CSV.  Let's dive in deeper and see how Delta Lake makes pandas faster.</p>"},{"location":"integrations/delta-lake-pandas/#delta-lake-makes-pandas-queries-run-faster","title":"Delta Lake makes pandas queries run faster","text":"<p>There are a few reasons Delta Lake can make pandas queries run faster:</p> <ol> <li>column pruning: only grabbing the columns relevant for a query</li> <li>file skipping: only reading files with data for the query</li> <li>row group skipping: only reading row groups with data for the query</li> <li>Z ordering data: colocating similar data in the same files, so file skipping is more effective</li> </ol> <p>Reading less data (fewer columns and/or fewer rows) is how Delta Lake makes pandas queries run faster.</p> <p>Parquet allows for column pruning and row group skipping, but doesn't support file-level skipping or Z Ordering.  CSV doesn't support any of these performance optimizations.</p> <p>Let's take a look at a sample dataset and run a query to see the performance enhancements offered by Delta Lake.</p> <p>Suppose you have a 1 billion row dataset with 9 columns, here are the first three rows of the dataset:</p> <pre><code>+-------+-------+--------------+-------+-------+--------+------+------+---------+\n| id1   | id2   | id3          |   id4 |   id5 |    id6 |   v1 |   v2 |      v3 |\n|-------+-------+--------------+-------+-------+--------+------+------+---------|\n| id016 | id046 | id0000109363 |    88 |    13 | 146094 |    4 |    6 | 18.8377 |\n| id039 | id087 | id0000466766 |    14 |    30 | 111330 |    4 |   14 | 46.7973 |\n| id047 | id098 | id0000307804 |    85 |    23 | 187639 |    3 |    5 | 47.5773 |\n+-------+-------+--------------+-------+-------+--------+------+------+---------+\n</code></pre> <p>The dataset is roughly 50 GB when stored as an uncompressed CSV files.  Let's run some queries on a 2021 Macbook M1 with 64 GB of RAM.</p> <p>Start by running the query on an uncompressed CSV file:</p> <pre><code>(\n    pd.read_csv(f\"{Path.home()}/data/G1_1e9_1e2_0_0.csv\", usecols=[\"id1\", \"id2\", \"v1\"])\n    .query(\"id1 == 'id016'\")\n    .groupby(\"id2\")\n    .agg({\"v1\": \"sum\"})\n)\n</code></pre> <p>This query takes 234 seconds to execute.  It runs out of memory if the <code>usecols</code> parameter is not set.</p> <p>Now let's convert the CSV dataset to Parquet and run the same query on the data stored in a Parquet file.</p> <pre><code>(\n    pd.read_parquet(\n        f\"{Path.home()}/data/G1_1e9_1e2_0_0.parquet\", columns=[\"id1\", \"id2\", \"v1\"]\n    )\n    .query(\"id1 == 'id016'\")\n    .groupby(\"id2\")\n    .agg({\"v1\": \"sum\"})\n)\n</code></pre> <p>This query takes 118 seconds to execute.</p> <p>Parquet stores data in row groups and allows for skipping when the <code>filters</code> predicates are set.  Run the Parquet query again with row group skipping enabled:</p> <pre><code>(\n    pd.read_parquet(\n        f\"{Path.home()}/data/G1_1e9_1e2_0_0.parquet\",\n        columns=[\"id1\", \"id2\", \"v1\"],\n        filters=[(\"id1\", \"==\", \"id016\")],\n    )\n    .query(\"id1 == 'id016'\")\n    .groupby(\"id2\")\n    .agg({\"v1\": \"sum\"})\n)\n</code></pre> <p>This query runs in 19 seconds.  Lots of row groups can be skipped for this particular query.</p> <p>Now let's run the same query on a Delta table to see the out-of-the box performance:</p> <pre><code>(\n    DeltaTable(f\"{Path.home()}/data/deltalake_baseline_G1_1e9_1e2_0_0\", version=0)\n    .to_pandas(filters=[(\"id1\", \"==\", \"id016\")], columns=[\"id1\", \"id2\", \"v1\"])\n    .query(\"id1 == 'id016'\")\n    .groupby(\"id2\")\n    .agg({\"v1\": \"sum\"})\n)\n</code></pre> <p>This query runs in 8 seconds, which is a significant performance enhancement.</p> <p>Now let's Z Order the Delta table by <code>id1</code> which will make the data skipping even better.  Run the query again on the Z Ordered Delta table:</p> <pre><code>(\n    DeltaTable(f\"{Path.home()}/data/deltalake_baseline_G1_1e9_1e2_0_0\", version=1)\n    .to_pandas(filters=[(\"id1\", \"==\", \"id016\")], columns=[\"id1\", \"id2\", \"v1\"])\n    .query(\"id1 == 'id016'\")\n    .groupby(\"id2\")\n    .agg({\"v1\": \"sum\"})\n)\n</code></pre> <p>The query now executes in 2.4 seconds.</p> <p>Delta tables can make certain pandas queries run much faster.</p>"},{"location":"integrations/delta-lake-pandas/#delta-lake-lets-pandas-users-time-travel","title":"Delta Lake lets pandas users time travel","text":"<p>Start by creating a Delta table:</p> <pre><code>from deltalake import write_deltalake, DeltaTable\n\ndf = pd.DataFrame({\"num\": [1, 2, 3], \"letter\": [\"a\", \"b\", \"c\"]})\nwrite_deltalake(\"tmp/some-table\", df)\n</code></pre> <p>Here are the contents of the Delta table (version 0 of the Delta table):</p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n|     3 | c        |\n+-------+----------+\n</code></pre> <p>Now append two rows to the Delta table:</p> <pre><code>df = pd.DataFrame({\"num\": [8, 9], \"letter\": [\"dd\", \"ee\"]})\nwrite_deltalake(\"tmp/some-table\", df, mode=\"append\")\n</code></pre> <p>Here are the contents after the append operation (version 1 of the Delta table):</p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n|     3 | c        |\n|     8 | dd       |\n|     9 | ee       |\n+-------+----------+\n</code></pre> <p>Now perform an overwrite transaction:</p> <pre><code>df = pd.DataFrame({\"num\": [11, 22], \"letter\": [\"aa\", \"bb\"]})\nwrite_deltalake(\"tmp/some-table\", df, mode=\"overwrite\")\n</code></pre> <p>Here are the contents after the overwrite operation (version 2 of the Delta table):</p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     8 | dd       |\n|     9 | ee       |\n+-------+----------+\n</code></pre> <p>Read in the Delta table and it will grab the latest version by default:</p> <pre><code>DeltaTable(\"tmp/some-table\").to_pandas()\n\n+-------+----------+\n|   num | letter   |\n|-------+----------|\n|    11 | aa       |\n|    22 | bb       |\n+-------+----------+\n</code></pre> <p>You can easily time travel back to version 0 of the Delta table:</p> <pre><code>DeltaTable(\"tmp/some-table\", version=0).to_pandas()\n\n+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n|     3 | c        |\n+-------+----------+\n</code></pre> <p>You can also time travel to version 1 of the Delta table:</p> <pre><code>DeltaTable(\"tmp/some-table\", version=1).to_pandas()\n\n+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n|     3 | c        |\n|     8 | dd       |\n|     9 | ee       |\n+-------+----------+\n</code></pre> <p>Time travel is a powerful feature that pandas users cannot access with CSV or Parquet.</p>"},{"location":"integrations/delta-lake-pandas/#schema-enforcement","title":"Schema enforcement","text":"<p>Delta tables only allow you to append DataFrame with matching schema by default.  Suppose you have a DataFrame with <code>num</code> and <code>animal</code> columns, which is different from the Delta table that has columns with <code>num</code> and <code>letter</code> columns.</p> <p>Try to append this DataFrame with a mismatched schema to the existing table:</p> <pre><code>df = pd.DataFrame({\"num\": [5, 6], \"animal\": [\"cat\", \"dog\"]})\nwrite_deltalake(\"tmp/some-table\", df)\n</code></pre> <p>This transaction will be rejected and will return the following error message:</p> <pre><code>ValueError: Schema of data does not match table schema\nData schema:\nnum: int64\nanimal: string\n-- schema metadata --\npandas: '{\"index_columns\": [{\"kind\": \"range\", \"name\": null, \"start\": 0, \"' + 474\nTable Schema:\nnum: int64\nletter: string\n</code></pre> <p>Schema enforcement protects your table from getting corrupted by appending data with mismatched schema.  Parquet and CSV don't offer schema enforcement for pandas users.</p>"},{"location":"integrations/delta-lake-pandas/#overwriting-schema-of-table","title":"Overwriting schema of table","text":"<p>You can overwrite the table contents and schema by setting the <code>schema_mode</code> option.  Here's how to overwrite the table contents:</p> <pre><code>write_deltalake(\"tmp/some-table\", df, mode=\"overwrite\", schema_mode=\"overwrite\")\n</code></pre> <p>Here are the contents of the table after the values and schema have been overwritten:</p> <pre><code>+-------+----------+\n|   num | animal   |\n|-------+----------|\n|     5 | cat      |\n|     6 | dog      |\n+-------+----------+\n</code></pre> <p>If you want the schema to be merged instead, specify schema_mode=\"merge\".</p>"},{"location":"integrations/delta-lake-pandas/#in-memory-vs-in-storage-data-changes","title":"In-memory vs. in-storage data changes","text":"<p>It's important to distinguish between data stored in-memory and data stored on disk when understanding the functionality offered by Delta Lake.</p> <p>pandas loads data from storage (CSV, Parquet, or Delta Lake) into in-memory DataFrames.</p> <p>pandas makes it easy to modify the data in memory, say update a column value.  It's not easy to update a column value in storage systems like CSV or Parquet using pandas.</p> <p>Delta Lake makes it easy for pandas users to update data in storage.</p>"},{"location":"integrations/delta-lake-pandas/#why-delta-lake-allows-for-faster-queries","title":"Why Delta Lake allows for faster queries","text":"<p>Delta tables store data in many files and metadata about the files in the transaction log.  Delta Lake allows for certain queries to skip entire files, which makes pandas queries run much faster.</p>"},{"location":"integrations/delta-lake-pandas/#more-resources","title":"More resources","text":"<p>See this talk on why Delta Lake is the best file format for pandas analyses to learn more: </p>"},{"location":"integrations/delta-lake-pandas/#conclusion","title":"Conclusion","text":"<p>Delta Lake provides many features that make it an excellent format for pandas analyses:</p> <ul> <li>performance optimizations make pandas queries run faster</li> <li>data management features make pandas analyses more reliable</li> <li>advanced features allow you to perform more complex pandas analyses</li> </ul> <p>Python deltalake offers pandas users a better experience compared with CSV/Parquet.</p>"},{"location":"integrations/delta-lake-polars/","title":"Using Delta Lake with polars","text":"<p>This page explains why Delta Lake is a great storage system for Polars analyses.</p> <p>You will learn how to create Delta tables with Polars, how to query Delta tables with Polars, and the unique advantages Delta Lake offers the Polars community.</p> <p>Here are some amazing benefits that Delta Lake provides Polars users:</p> <ul> <li>time travel</li> <li>ACID transactions for reliable writes</li> <li>better performance with file skipping</li> <li>enhanced file skipping via Z Ordering</li> <li>ability to rollback mistakes</li> <li>and many, many more</li> </ul> <p>Let's start by showing how to use Polars with Delta Lake, explore how Delta Lake can make Polars queries run faster, and then look at all the cool features Delta Lake offers Polars users.</p>"},{"location":"integrations/delta-lake-polars/#creating-a-delta-lake-table-with-polars","title":"Creating a Delta Lake table with Polars","text":"<p>Create a Polars DataFrame and write it out to a Delta table:</p> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"x\": [1, 2, 3]})\ndf.write_delta(\"tmp/bear_delta_lake\")\n</code></pre> <p>Inspect the contents of the Delta table:</p> <pre><code>print(pl.read_delta(\"tmp/bear_delta_lake\"))\n\n+-----+\n| x   |\n| --- |\n| i64 |\n+=====+\n| 1   |\n| 2   |\n| 3   |\n+-----+\n</code></pre> <p>Now create another Polars DataFrame and append it to the existing Delta table:</p> <pre><code>df2 = pl.DataFrame({\"x\": [8, 9, 10]})\ndf2.write_delta(\"tmp/bear_delta_lake\", mode=\"append\")\n</code></pre> <p>Re-inspect the contents of the Delta table:</p> <pre><code>print(pl.read_delta(\"tmp/bear_delta_lake\"))\n\n+-----+\n| x   |\n| --- |\n| i64 |\n+=====+\n| 1   |\n| 2   |\n| 3   |\n| 8   |\n| 9   |\n| 10  |\n+-----+\n</code></pre> <p>Now overwrite the existing Delta table:</p> <pre><code>df3 = pl.DataFrame({\"x\": [55, 66, 77]})\ndf3.write_delta(\"tmp/bear_delta_lake\", mode=\"overwrite\")\n</code></pre> <p>Inspect the Delta table:</p> <pre><code>print(pl.read_delta(\"tmp/bear_delta_lake\"))\n\n+-----+\n| x   |\n| --- |\n| i64 |\n+=====+\n| 55  |\n| 66  |\n| 77  |\n+-----+\n</code></pre> <p>The Delta table now has three versions, as shown in the following diagram:</p> <p></p>"},{"location":"integrations/delta-lake-polars/#time-travel-with-delta-lake-for-polars","title":"Time travel with Delta Lake for Polars","text":"<p>Time travel back to version 0 of the Delta table:</p> <pre><code>print(pl.read_delta(\"tmp/bear_delta_lake\", version=0))\n\n+-----+\n| x   |\n| --- |\n| i64 |\n+=====+\n| 1   |\n| 2   |\n| 3   |\n+-----+\n</code></pre> <p>Time travel back to version 1 of the Delta table:</p> <pre><code>print(pl.read_delta(\"tmp/bear_delta_lake\", version=1))\n\n+-----+\n| x   |\n| --- |\n| i64 |\n+=====+\n| 1   |\n| 2   |\n| 3   |\n| 9   |\n| 8   |\n| 10  |\n+-----+\n</code></pre> <p>Read the Delta table without specifying a version and see how it reads the latest version by default:</p> <pre><code>print(pl.read_delta(\"tmp/bear_delta_lake\"))\n\n+-----+\n| x   |\n| --- |\n| i64 |\n+=====+\n| 55  |\n| 66  |\n| 77  |\n+-----+\n</code></pre> <p>Let's dive into how to read Delta tables with Polars in more detail and compare the query runtime performance on larger datasets.</p>"},{"location":"integrations/delta-lake-polars/#reading-a-delta-lake-table-with-polars","title":"Reading a Delta Lake table with Polars","text":"<p>Let's look at the h2o groupby dataset that has 1 billion rows and 9 columns.  Here are the first three rows of the dataset:</p> <pre><code>+-------+-------+--------------+-------+-------+--------+------+------+---------+\n| id1   | id2   | id3          |   id4 |   id5 |    id6 |   v1 |   v2 |      v3 |\n|-------+-------+--------------+-------+-------+--------+------+------+---------|\n| id016 | id046 | id0000109363 |    88 |    13 | 146094 |    4 |    6 | 18.8377 |\n| id039 | id087 | id0000466766 |    14 |    30 | 111330 |    4 |   14 | 46.7973 |\n| id047 | id098 | id0000307804 |    85 |    23 | 187639 |    3 |    5 | 47.5773 |\n+-------+-------+--------------+-------+-------+--------+------+------+---------+\n</code></pre> <p>This dataset is 50GB when stored in an uncompressed CSV file.  Let's run some queries on this dataset when it's stored in different file formats with Polars.</p> <p>This section will show the runtime for a query when the data is stored in CSV, Parquet, and Delta Lake and explain why Delta tables are the fastest.</p> <p></p> <p>Start by running a query on an uncompressed CSV file with <code>read_csv</code>:</p> <pre><code>pl.read_csv(\"~/data/G1_1e9_1e2_0_0.csv\").filter(pl.col(\"id1\") &lt; \"id016\").group_by(\n    [\"id1\", \"id2\"]\n).agg(pl.sum(\"v1\").alias(\"v1_sum\")).collect()\n</code></pre> <p>This query errors out after running for several minutes.  The machine runs out of memory.  Let's try it again with <code>scan_csv</code>.</p> <pre><code>pl.scan_csv(\"~/data/G1_1e9_1e2_0_0.csv\").filter(pl.col(\"id1\") &lt; \"id016\").group_by(\n    [\"id1\", \"id2\"]\n).agg(pl.sum(\"v1\").alias(\"v1_sum\")).collect()\n</code></pre> <p>This query runs in 56.2 seconds.</p> <p>Now let's run the same query when the data is stored in a Parquet file:</p> <pre><code>pl.scan_parquet(\"~/data/G1_1e9_1e2_0_0.parquet\").filter(\n    pl.col(\"id1\") &lt; \"id016\"\n).group_by([\"id1\", \"id2\"]).agg(pl.sum(\"v1\").alias(\"v1_sum\")).collect()\n</code></pre> <p>This query runs in 8.3 seconds.  It's much faster because Polars is optimized to skip row groups in Parquet files that don't contain data that's relevant for the query.</p> <p>Then run the query on newly created Delta table:</p> <pre><code>pl.scan_delta(\"~/data/deltalake/G1_1e9_1e2_0_0\", version=1).filter(\n    pl.col(\"id1\") &lt; \"id016\"\n).group_by([\"id1\", \"id2\"]).agg(pl.sum(\"v1\").alias(\"v1_sum\")).collect()\n</code></pre> <p>This query runs in 7.2 seconds.  Polars can run this query faster because it can inspect the Delta transaction log and skip entire files that don't contain relevant data before performing the ordinary Parquet row group skipping.</p> <p>Finally run the query on the Delta table after it has been Z Ordered by <code>id1</code>:</p> <pre><code>pl.scan_delta(\"~/data/deltalake/G1_1e9_1e2_0_0\", version=2).filter(\n    pl.col(\"id1\") &lt; \"id016\"\n).group_by([\"id1\", \"id2\"]).agg(pl.sum(\"v1\").alias(\"v1_sum\")).collect()\n</code></pre> <p>This query runs in 3.5 seconds.  The query on the Z Ordered Delta table is even faster because similar data has been co-located in the same files.  This allows for even greater data skipping.</p> <p>Polars can leverage file skipping to query Delta tables very quickly.</p>"},{"location":"integrations/delta-lake-polars/#why-polars-is-fast-with-delta-lake","title":"Why Polars is fast with Delta Lake","text":"<p>Delta tables consist of metadata in a transaction log and data stored in Parquet files.</p> <p>When Polars queries a Delta table, it starts by consulting the transaction log to understand the metadata of each file in the Delta table.  This allows for Polars to quickly identify which files should be skipped by the query.</p> <p>CSV files don't contain any such metadata, so file skipping isn't an option.  Polars can skip Parquet files based on metadata, but it needs to open up each file and read the metadata, which is slower that grabbing the file-level metadata directly from the transaction log.</p> <p>Parquet doesn't allow users to easily Z Order the data and colocate similar data in the same row groups.  The Z Order optimizations are only supported in Delta tables.</p> <p>Delta Lake offers Polars users with unique performance optimizations.</p>"},{"location":"integrations/delta-lake-polars/#other-delta-lake-features-relevant-for-polars-users","title":"Other Delta Lake features relevant for Polars users","text":"<ul> <li>ACID transactions for reliable writes</li> <li>better performance with file skipping</li> <li>enhanced file skipping via Z Ordering</li> <li>ability to rollback mistakes</li> </ul>"},{"location":"integrations/delta-lake-polars/#conclusion","title":"Conclusion","text":"<p>This guide shows how Delta Lake is a great storage format for Polars analyses.</p> <p>Delta Lake is easy to use, fast, and full of features that are great for Polars users.</p>"},{"location":"integrations/object-storage/adls/","title":"Azure ADLS Storage Backend","text":"<p><code>delta-rs</code> offers native support for using Microsoft Azure Data Lake Storage (ADSL) as an object storage backend.</p> <p>You don\u2019t need to install any extra dependencies to read/write Delta tables to S3 with engines that use <code>delta-rs</code>. You do need to configure your ADLS access credentials correctly.</p>"},{"location":"integrations/object-storage/adls/#passing-credentials-explicitly","title":"Passing Credentials Explicitly","text":"<p>You can also pass ADLS credentials to your query engine explicitly.</p> <p>For Polars, you would do this using the <code>storage_options</code> keyword as demonstrated above. This will forward your credentials to the <code>object store</code> library that Polars uses for cloud storage access under the hood. Read the <code>object store</code> documentation for more information defining specific credentials.</p>"},{"location":"integrations/object-storage/adls/#example-write-delta-table-to-adls-with-polars","title":"Example: Write Delta table to ADLS with Polars","text":"<p>Using Polars, you can write a Delta table to ADLS directly like this:</p> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"foo\": [1, 2, 3, 4, 5]})\n\n# define container name\ncontainer = &lt;container_name&gt;\n\n# define credentials\nstorage_options = {\n    \"ACCOUNT_NAME\": &lt;account_name&gt;,\n    \"ACCESS_KEY\": &lt;access_key&gt;,\n}\n\n# write Delta to ADLS\ndf_pl.write_delta(\n    f\"abfs://{container}/delta_table\",\n    storage_options = storage_options\n)\n</code></pre>"},{"location":"integrations/object-storage/adls/#example-with-pandas","title":"Example with pandas","text":"<p>For libraries without direct <code>write_delta</code> methods (like Pandas), you can use the <code>write_deltalake</code> function from the <code>deltalake</code> library:</p> <pre><code>import pandas as pd\nfrom deltalake import write_deltalake\n\ndf = pd.DataFrame({\"foo\": [1, 2, 3, 4, 5]})\n\nwrite_deltalake(\n    f\"abfs://{container}/delta_table_pandas\",\n    df,\n    storage_options=storage_options\n)\n</code></pre>"},{"location":"integrations/object-storage/adls/#using-azure-cli","title":"Using Azure CLI","text":"<p>If your local session is authenticated using the Azure CLI then you can read and write Delta tables directly to ADLS.</p> <pre><code>from deltalake import write_deltalake\n\n# build path\nstorage_account_name = \"&lt;STORAGE_ACCOUNT_NAME&gt;\"\ncontainer_name = \"&lt;CONTAINER_NAME&gt;\"\ntable_name = \"&lt;TABLE_NAME&gt;\" \nabfs_path = f\"abfss://{container_name}@{storage_account_name}.dfs.core.windows.net/{table_name}/\"\n\n# define credentials\nstorage_options = {\n    \"azure_tenant_id\": \"&lt;TENANT_ID&gt;\",\n    \"azure_use_azure_cli\": \"true\",\n}\n\ndt = DeltaTable(abfs_path,storage_options=storage_options)\n</code></pre>"},{"location":"integrations/object-storage/gcs/","title":"GCS Storage Backend","text":"<p><code>delta-rs</code> offers native support for using Google Cloud Storage (GCS) as an object storage backend.</p> <p>You don\u2019t need to install any extra dependencies to read/write Delta tables to GCS with engines that use <code>delta-rs</code>. You do need to configure your GCS access credentials correctly.</p>"},{"location":"integrations/object-storage/gcs/#using-application-default-credentials","title":"Using Application Default Credentials","text":"<p>Application Default Credentials (ADC) is a strategy used by GCS to automatically find credentials based on the application environment.</p> <p>If you are working from your local machine and have ADC set up then you can read/write Delta tables from GCS directly, without having to pass your credentials explicitly.</p>"},{"location":"integrations/object-storage/gcs/#example-write-delta-tables-to-gcs-with-polars","title":"Example: Write Delta tables to GCS with Polars","text":"<p>Using Polars, you can write a Delta table to GCS like this:</p> <pre><code># create a toy dataframe\nimport polars as pl\ndf = pl.DataFrame({\"foo\": [1, 2, 3, 4, 5]})\n\n# define path\ntable_path = \"gs://bucket/delta-table\"\n\n# write Delta to GCS\ndf.write_delta(table_path)\n</code></pre>"},{"location":"integrations/object-storage/gcs/#passing-gcs-credentials-explicitly","title":"Passing GCS Credentials explicitly","text":"<p>Alternatively, you can pass GCS credentials to your query engine explicitly.</p> <p>For Polars, you would do this using the <code>storage_options</code> keyword. This will forward your credentials to the <code>object store</code> library that Polars uses under the hood. Read the Polars documentation and the <code>object store</code> documentation for more information.</p>"},{"location":"integrations/object-storage/gcs/#delta-lake-on-gcs-required-permissions","title":"Delta Lake on GCS: Required permissions","text":"<p>You will need the following permissions in your GCS account:</p> <ul> <li><code>storage.objects.create</code></li> <li><code>storage.objects.delete</code> (only required for uploads that overwrite an existing object)</li> <li><code>storage.objects.get</code> (only required if you plan on using the Google Cloud CLI)</li> <li><code>storage.objects.list</code> (only required if you plan on using the Google Cloud CLI)</li> </ul> <p>For more information, see the GCP documentation</p>"},{"location":"integrations/object-storage/hdfs/","title":"HDFS Storage Backend","text":"<p>HDFS support is provided via the hdfs-native-object-store package, which sits on top of hdfs-native. This is an HDFS client written from scratch in Rust, with no bindings to libhdfs or any use of Java. While it supports most common cluster configurations, it does not support every possible client configuration that could exist.</p>"},{"location":"integrations/object-storage/hdfs/#supported-configurations","title":"Supported Configurations","text":"<p>By default, the client looks for existing Hadoop configs in following manner:</p> <ul> <li>If the <code>HADOOP_CONF_DIR</code> environment variable is defined, load configs from <code>$HADOOP_CONF_DIR/core-site.xml</code> and <code>$HADOOP_CONF_DIR/hdfs-site.xml</code></li> <li>Otherwise, if the <code>HADOOP_HOME</code> environment variable is set, load configs from <code>$HADOOP_HOME/etc/hadoop/core-site.xml</code> and <code>$HADOOP_HOME/etc/hadoop/hdfs-site.xml</code></li> </ul> <p>Additionally, you can pass Hadoop configs as <code>storage_options</code> and these will take precedence over the above configs.</p> <p>Currently the supported client configuration parameters are:</p> <ul> <li><code>dfs.ha.namenodes.*</code> - name service support</li> <li><code>dfs.namenode.rpc-address.*</code> - name service support</li> <li><code>fs.viewfs.mounttable.*.link.*</code> - ViewFS links</li> <li><code>fs.viewfs.mounttable.*.linkFallback</code> - ViewFS link fallback</li> </ul> <p>If you find your setup is not supported, please file an issue in the hdfs-native repository.</p>"},{"location":"integrations/object-storage/hdfs/#secure-clusters","title":"Secure Clusters","text":"<p>The client supports connecting to secure clusters through both Kerberos authentication as well as token authentication, and all SASL protection types are supported. The highest supported protection mechanism advertised by the server will be used.</p>"},{"location":"integrations/object-storage/hdfs/#kerberos-support","title":"Kerberos Support","text":"<p>Kerberos is supported through dynamically loading the <code>libgssapi_krb5</code> library. This must be installed separately through your package manager, and currently only works on Linux and Mac.</p> <p>Debian-based systems: <pre><code>apt-get install libgssapi-krb5-2\n</code></pre></p> <p>RHEL-based systems: <pre><code>yum install krb5-libs\n</code></pre></p> <p>MacOS: <pre><code>brew install krb5\n</code></pre></p> <p>Then simply <code>kinit</code> to get your TGT and authentication to HDFS should just work.</p>"},{"location":"integrations/object-storage/hdfs/#token-support","title":"Token Support","text":"<p>Token authentication is supported by looking for a token file located at the environment variable <code>HADOOP_TOKEN_FILE_LOCATION</code>. This is the location systems like YARN will automatically place a delegation token, so things will just work inside of YARN jobs.</p>"},{"location":"integrations/object-storage/hdfs/#issues","title":"Issues","text":"<p>If you face any HDFS-specific issues, please report to the hdfs-native-object-store repository.</p>"},{"location":"integrations/object-storage/lakefs/","title":"LakeFS","text":"<p><code>delta-rs</code> offers native support for using LakeFS as an object storage backend. Each  deltalake operation is executed in a transaction branch and safely merged into your source branch.</p> <p>You don\u2019t need to install any extra dependencies to read/write Delta tables to LakeFS with engines that use <code>delta-rs</code>. You do need to configure your LakeFS access credentials correctly.</p>"},{"location":"integrations/object-storage/lakefs/#passing-lakefs-credentials","title":"Passing LakeFS Credentials","text":"<p>You can pass your LakeFS credentials explicitly by using:</p> <ul> <li>the <code>storage_options</code>kwarg</li> <li>Environment variables</li> </ul>"},{"location":"integrations/object-storage/lakefs/#example","title":"Example","text":"<p>Let's work through an example with Polars. The same logic applies to other Python engines like Pandas, Daft, Dask, etc.</p> <p>Follow the steps below to use Delta Lake on LakeFS with Polars:</p> <ol> <li>Install Polars and deltalake. For example, using:</li> </ol> <p><code>pip install polars deltalake</code></p> <ol> <li>Create a dataframe with some toy data.</li> </ol> <p><code>df = pl.DataFrame({'x': [1, 2, 3]})</code></p> <ol> <li>Set your <code>storage_options</code> correctly.</li> </ol> <pre><code>storage_options = {\n        \"endpoint\": \"https://mylakefs.intranet.com\", # LakeFS endpoint\n        \"access_key_id\": \"LAKEFSID\",\n        \"secret_access_key\": \"LAKEFSKEY\",\n    }\n</code></pre> <ol> <li>Write data to Delta table using the <code>storage_options</code> kwarg. The subpath after the bucket is always the branch you want to write into.</li> </ol> <pre><code>df.write_delta(\n    \"lakefs://bucket/branch/table\",\n    storage_options=storage_options,\n)\n</code></pre>"},{"location":"integrations/object-storage/lakefs/#cleaning-up-failed-transaction-branches","title":"Cleaning up failed transaction branches","text":"<p>It might occur that a deltalake operation fails midway. At this point a lakefs transaction branch was created, but never destroyed. The branches are hidden in the UI, but each branch starts with <code>delta-tx</code>.</p> <p>With the lakefs python library you can list these branches and delete stale ones. </p> <p>"},{"location":"integrations/object-storage/s3-like/","title":"CloudFlare R2 &amp; Minio","text":"<p><code>delta-rs</code> offers native support for using Cloudflare R2 or Minio as an S3-compatible storage backend. R2 and Minio support conditional puts, which removes the need for DynamoDB for safe concurrent writes.  However, we have to pass the <code>aws_conditional_put</code> flag into <code>storage_options</code>. See the example below.</p> <p>You don\u2019t need to install any extra dependencies to read/write Delta tables to S3 with engines that use <code>delta-rs</code>. You do need to configure your AWS access credentials correctly.</p>"},{"location":"integrations/object-storage/s3-like/#passing-s3-credentials","title":"Passing S3 Credentials","text":"<p>You can pass your AWS credentials explicitly by using:</p> <ul> <li>the <code>storage_options</code>kwarg</li> <li>Environment variables</li> </ul>"},{"location":"integrations/object-storage/s3-like/#example","title":"Example","text":"<p>Let's work through an example with Polars. The same logic applies to other Python engines like Pandas, Daft, Dask, etc.</p> <p>Follow the steps below to use Delta Lake on S3 (R2/Minio) with Polars:</p> <ol> <li>Install Polars and deltalake. For example, using:</li> </ol> <p><code>pip install polars deltalake</code></p> <ol> <li>Create a dataframe with some toy data.</li> </ol> <p><code>df = pl.DataFrame({'x': [1, 2, 3]})</code></p> <ol> <li>Set your <code>storage_options</code> correctly.</li> </ol> <pre><code>storage_options = {\n    'AWS_SECRET_ACCESS_KEY': &lt;access_key&gt;,\n    'aws_conditional_put': 'etag', # Here we say to use conditional put, this provides safe concurrency.\n}\n</code></pre> <ol> <li>Write data to Delta table using the <code>storage_options</code> kwarg.</li> </ol> <pre><code>df.write_delta(\n    \"s3://bucket/delta_table\",\n    storage_options=storage_options,\n)\n</code></pre>"},{"location":"integrations/object-storage/s3-like/#minio-and-docker","title":"Minio and Docker","text":"<p>Minio is straightforward to host locally with Docker and docker-compose, via the following <code>docker-compose.yml</code> file - just run <code>docker-compose up</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  minio:\n    image: minio/minio\n    ports:\n      - \"9000:9000\"\n      - \"9001:9001\"\n    environment:\n      MINIO_ROOT_USER: ...\n      MINIO_ROOT_PASSWORD: ...\n    command: server /data --console-address \":9001\"\n</code></pre> <p>With this configuration, Minio will host its S3-compatible API over HTTP, not HTTPS, on port 9000.  This requires an additional flag in <code>storage_options</code>, <code>AWS_ALLOW_HTTP</code>, to be set to <code>true</code>:</p> <pre><code>storage_options = {\n    'AWS_ACCESS_KEY_ID': ...,\n    'AWS_SECRET_ACCESS_KEY': ...,\n    'AWS_ENDPOINT_URL': 'http://localhost:9000',\n    'AWS_ALLOW_HTTP': 'true',\n    'aws_conditional_put': 'etag'\n}\n</code></pre>"},{"location":"integrations/object-storage/s3/","title":"AWS S3 Storage Backend","text":"<p><code>delta-rs</code> offers native support for using AWS S3 as an object storage backend.</p> <p>You don\u2019t need to install any extra dependencies to read/write Delta tables to S3 with engines that use <code>delta-rs</code>. You do need to configure your AWS access credentials correctly.</p>"},{"location":"integrations/object-storage/s3/#note-for-boto3-users","title":"Note for boto3 users","text":"<p>Many Python engines use boto3 to connect to AWS. This library supports reading credentials automatically from your local <code>.aws/config</code> or <code>.aws/creds</code> file.</p> <p>For example, if you\u2019re running locally with the proper credentials in your local <code>.aws/config</code> or <code>.aws/creds</code> file then you can write a Parquet file to S3 like this with pandas:</p> <pre><code>    import pandas as pd\n    df = pd.DataFrame({'x': [1, 2, 3]})\n    df.to_parquet(\"s3://avriiil/parquet-test-pandas\")\n</code></pre> <p>The <code>delta-rs</code> writer does not use <code>boto3</code> and therefore does not support taking credentials from your <code>.aws/config</code> or <code>.aws/creds</code> file. If you\u2019re used to working with writers from Python engines like Polars, pandas or Dask, this may mean a small change to your workflow.</p>"},{"location":"integrations/object-storage/s3/#passing-aws-credentials","title":"Passing AWS Credentials","text":"<p>You can pass your AWS credentials explicitly by using:</p> <ul> <li>the <code>storage_options</code>kwarg</li> <li>Environment variables</li> <li>EC2 metadata if using EC2 instances</li> <li>AWS Profiles</li> </ul>"},{"location":"integrations/object-storage/s3/#example","title":"Example","text":"<p>Let's work through an example with Polars. The same logic applies to other Python engines like Pandas, Daft, Dask, etc.</p> <p>Follow the steps below to use Delta Lake on S3 with Polars:</p> <ol> <li>Install Polars and deltalake. For example, using:</li> </ol> <p><code>pip install polars deltalake</code></p> <ol> <li>Create a dataframe with some toy data.</li> </ol> <p><code>df = pl.DataFrame({'x': [1, 2, 3]})</code></p> <ol> <li>Set your <code>storage_options</code> correctly.</li> </ol> <pre><code>storage_options = {\n    \"AWS_REGION\":&lt;region_name&gt;,\n    'AWS_ACCESS_KEY_ID': &lt;key_id&gt;,\n    'AWS_SECRET_ACCESS_KEY': &lt;access_key&gt;,\n    'AWS_S3_LOCKING_PROVIDER': 'dynamodb',\n    'DELTA_DYNAMO_TABLE_NAME': 'delta_log',\n}\n</code></pre> <ol> <li>Write data to Delta table using the <code>storage_options</code> kwarg.</li> </ol> <pre><code>df.write_delta(\n    \"s3://bucket/delta_table\",\n    storage_options=storage_options,\n)\n</code></pre>"},{"location":"integrations/object-storage/s3/#delta-lake-on-aws-s3-safe-concurrent-writes","title":"Delta Lake on AWS S3: Safe Concurrent Writes","text":"<p>You need a locking provider to ensure safe concurrent writes when writing Delta tables to AWS S3. This is because AWS S3 does not guarantee mutual exclusion.</p> <p>A locking provider guarantees that only one writer is able to create the same file. This prevents corrupted or conflicting data.</p> <p><code>delta-rs</code> uses DynamoDB to guarantee safe concurrent writes.</p> <p>Run the code below in your terminal to create a DynamoDB table that will act as your locking provider.</p> <pre><code>    aws dynamodb create-table \\\n    --table-name delta_log \\\n    --attribute-definitions AttributeName=tablePath,AttributeType=S AttributeName=fileName,AttributeType=S \\\n    --key-schema AttributeName=tablePath,KeyType=HASH AttributeName=fileName,KeyType=RANGE \\\n    --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5\n</code></pre> <p>If for some reason you don't want to use DynamoDB as your locking mechanism you can choose to set the <code>AWS_S3_ALLOW_UNSAFE_RENAME</code> variable to <code>true</code> in order to enable S3 unsafe writes.</p> <p>Read more in the Usage section.</p>"},{"location":"integrations/object-storage/s3/#delta-lake-on-aws-s3-required-permissions","title":"Delta Lake on AWS S3: Required permissions","text":"<p>You need to have permissions to get, put and delete objects in the S3 bucket you're storing your data in. Please note that you must be allowed to delete objects even if you're just appending to the Delta Lake, because there are temporary files into the log folder that are deleted after usage.</p> <p>In AWS S3, you will need the following permissions:</p> <ul> <li>s3:GetObject</li> <li>s3:PutObject</li> <li>s3:DeleteObject</li> </ul> <p>In DynamoDB, you will need the following permissions:</p> <ul> <li>dynamodb:GetItem</li> <li>dynamodb:Query</li> <li>dynamodb:PutItem</li> <li>dynamodb:UpdateItem</li> </ul>"},{"location":"integrations/object-storage/special_configuration/","title":"Advanced object storage configuration","text":"<p>Delta-rs provides some addition values to be set in the storage_options for advanced use case:</p> <ul> <li>Limit concurrent requests overall</li> <li>Set retry configuration</li> <li>Exponential backoff with decorrelated jitter algorithm details See here for more details </li> <li>Mounted storage support</li> </ul> Config key Description OBJECT_STORE_CONCURRENCY_LIMIT The number of concurrent connections the underlying object store can create max_retries The maximum number of times to retry a request. Set to 0 to disable retries retry_timeout The maximum length of time from the initial request after which no further retries will be attempted backoff_config.init_backoff The initial backoff duration backoff_config.max_backoff The maximum backoff duration backoff_config.base The multiplier to use for the next backoff duration MOUNT_ALLOW_UNSAFE_RENAME If set it will allow unsafe renames on mounted storage"},{"location":"upgrade-guides/guide-1.0.0/","title":"DeltaLake 1.0.0 Migration Guide","text":"<p>DeltaLake 1.0.0 introduces significant changes, including the removal of the legacy Python writer engine. All write operations are now delegated to the <code>Rust</code> engine, which provides enhanced performance via <code>streaming execution</code> and <code>multipart uploads</code> for improved concurrency and reduced memory usage.</p> <p>In addition, DeltaLake no longer has a hard dependency on PyArrow, making it more lightweight and suitable for use in minimal or size-constrained environments. Arrow data handling between Python and Rust is now powered by <code>arro3</code>, a lightweight Arrow implementation backed by <code>arrow-rs</code>.</p> <p>For users who still require PyArrow-based read functionality, it remains available as an optional dependency. To continue using these features, install DeltaLake with the <code>pyarrow</code> extra, <code>deltalake[pyarrow]</code>.</p>"},{"location":"upgrade-guides/guide-1.0.0/#breaking-changes","title":"Breaking changes","text":""},{"location":"upgrade-guides/guide-1.0.0/#arro3-adoption","title":"<code>arro3</code> adoption","text":"<p>DeltaLake 1.0.0 introduces support for Arrow PyCapsule protocol using a lightweight arrow implementation with <code>arro3</code>. As a result, the <code>write_deltalake</code> and <code>DeltaTable.merge</code> functions now only accept inputs that implement one of the following interfaces:</p> <ul> <li><code>ArrowStreamExportable</code></li> <li><code>ArrowArrayExportable</code></li> </ul> <p>This means you can directly pass data from compatible libraries, such as:</p> <ul> <li>Polars DataFrame</li> <li>PyArrow Table or RecordBatchReader</li> <li>Pandas DataFrame (via its Arrow export support)</li> </ul> <p>DeltaLake will consume these objects efficiently through the Arrow C Data Interface.</p>"},{"location":"upgrade-guides/guide-1.0.0/#schema-types-and-fields","title":"Schema, Types and Fields","text":"<p>Schema handling has also transitioned from PyArrow to <code>arro3</code>. Internally, schema, types, and fields are now defined and interpreted via the Arrow C Data Interface:</p> <p>Our schema code also no longer converts to pyarrow but converts to <code>arro3</code> schema/types/fields directly over Arrow C Data Interface.</p> <ul> <li><code>to_pyarrow</code> \u2192 replaced with <code>to_arrow</code></li> <li><code>from_pyarrow</code> -&gt; replaced with <code>from_arrow</code> (can accept any object implementing <code>ArrowSchemaExportable</code>)</li> </ul> <p>All DeltaLake schema components\u2014such as schema, field, and type objects\u2014now implement the <code>__arrow_c_schema__</code> protocol. This means they are directly consumable by any library that supports the Arrow C Data Interface (e.g., Polars, PyArrow, pandas).</p>"},{"location":"upgrade-guides/guide-1.0.0/#arrow-object-outputs","title":"Arrow Object Outputs","text":"<p>Several DeltaLake APIs now return arro3-based Arrow objects instead of PyArrow objects. This includes:</p> <ul> <li><code>DeltaTable.get_add_actions</code></li> <li><code>DeltaTable.load_cdf</code></li> <li><code>QueryBuilder.execute</code></li> </ul> <p>These returned objects are fully compatible with libraries like Polars and PyArrow. For example:</p> <pre><code>import polars as pl\nimport pyarrow as pa\n\ndt = DeltaTable(\"test\")\nrb = dt.load_df()\n\n# With polars\ndf = pl.DataFrame(rb)\n\n# With pyarrow\ntbl = pa.table(df)\n</code></pre>"},{"location":"upgrade-guides/guide-1.0.0/#create-api","title":"<code>create</code> API","text":"<p>The <code>create</code> API now accepts schema definitions as either:</p> <ul> <li>A <code>DeltaSchema</code> object, or</li> <li>Any object implementing the <code>ArrowSchemaExportable</code> protocol (e.g., a PyArrow schema)</li> </ul> <p>This ensures full interoperability with modern Arrow-compatible libraries while leveraging the performance and flexibility of the Arrow C Data Interface.</p>"},{"location":"upgrade-guides/guide-1.0.0/#write_deltalake-api","title":"<code>write_deltalake</code> API","text":""},{"location":"upgrade-guides/guide-1.0.0/#engine-parameter-removed","title":"<code>engine</code> parameter removed","text":"<p>The engine parameter has been removed. All writes now default to the Rust engine.</p> <p>Before:</p> <pre><code>write_deltalake(\n    \"mytable\",\n    data=data,\n    mode=\"append\",\n    engine=\"rust\",\n)\n</code></pre> <p>After:</p> <pre><code>write_deltalake(\n    \"mytable\",\n    data=data,\n    mode=\"append\",\n)\n</code></pre>"},{"location":"upgrade-guides/guide-1.0.0/#pyarrow-specific-parameters-removed","title":"PyArrow-specific parameters removed","text":"<p>The following parameters related to the deprecated Python engine are no longer supported:</p> <ul> <li><code>file_options: Optional[ds.ParquetFileWriteOptions]</code></li> <li><code>max_partitions: Optional[int]</code></li> <li><code>max_open_files: int</code></li> <li><code>max_rows_per_file: int</code></li> <li><code>min_rows_per_group: int</code></li> <li><code>max_rows_per_group: int</code></li> </ul>"},{"location":"upgrade-guides/guide-1.0.0/#partition_filters-removed","title":"<code>partition_filters</code> removed","text":"<p>The partition_filters parameter has been removed. Use the <code>predicate</code> parameter as an alternative for overwriting a subset during writes</p>"},{"location":"upgrade-guides/guide-1.0.0/#large_dtypes-removed","title":"<code>large_dtypes</code> removed","text":"<p>The <code>large_dtypes</code> parameter has been removed. DeltaLake now always passes through all Arrow data types without modification for both <code>write_deltalake</code> and <code>DeltaTable.merge</code>.</p>"},{"location":"upgrade-guides/guide-1.0.0/#querybuilder","title":"QueryBuilder","text":"<p>QueryBuilder no longer implements <code>show</code>, and <code>execute</code> will directly return a RecordBatchReader. Additionally the experimental flag has been removed.</p>"},{"location":"upgrade-guides/guide-1.0.0/#commitproperties","title":"CommitProperties","text":""},{"location":"upgrade-guides/guide-1.0.0/#custom_metadata-replaced-with-commit_properties","title":"<code>custom_metadata</code> replaced with <code>commit_properties</code>","text":"<p>The custom_metadata argument has been replaced by the commit_properties parameter on the following APIs:</p> <ul> <li>convert_to_deltalake</li> <li>DeltaTable</li> <li>create</li> <li>vacuum</li> <li>update</li> <li>merge</li> <li>restore</li> <li>repair</li> <li>add_columns</li> <li>add_constraint</li> <li>set_table_properties</li> <li>compact</li> <li>z_order</li> <li>delete</li> </ul> <p>Before:</p> <pre><code>convert_to_deltalake(\n    uri=\"mytable\",\n    custom_metadata={\"foo\":\"bar\"},\n)\n</code></pre> <p>After:</p> <pre><code>convert_to_deltalake(\n    uri=\"mytable\",\n    commit_properties=CommitProperties(custom_metadata={\"foo\":\"bar\"}),\n)\n</code></pre>"},{"location":"upgrade-guides/guide-1.0.0/#deltatable","title":"DeltaTable","text":""},{"location":"upgrade-guides/guide-1.0.0/#removed-from_data_catalog","title":"removed <code>from_data_catalog</code>","text":"<p>This method was previously unimplemented and has now been fully removed from the DeltaTable class.</p>"},{"location":"upgrade-guides/guide-1.0.0/#removed-get_earliest_version","title":"removed <code>get_earliest_version</code>","text":"<p>This method is potentially very expensive while we could not find a clear use case for it. If you have a specific use case, please open an issue on GitHub.</p>"},{"location":"upgrade-guides/guide-1.0.0/#transaction_versions-changed-to-transaction_version","title":"<code>transaction_versions</code> changed to <code>transaction_version</code>","text":"<p><code>transaction_versions</code> has been renamed to <code>transaction_version</code> and now returns a single version number for a specific application instead of a dictionary for all applications. This allows for internal optimisations and aligns more with the use case for idempotent writes.</p> <p>To store more complex state as part of the delta log, use <code>domainMetadata</code>.</p>"},{"location":"upgrade-guides/guide-1.0.0/#removed-get_num_index_cols-get_stats_columns-and-check_can_write_timestamp_ntz","title":"removed <code>get_num_index_cols</code>, <code>get_stats_columns</code> and <code>check_can_write_timestamp_ntz</code>.","text":"<p>These methods were rxposed for use by the <code>pyarrow</code> engine, which no longer exists.</p>"},{"location":"upgrade-guides/guide-1.0.0/#deprecated-files","title":"deprecated <code>files</code>","text":"<p>The <code>files</code> method has been deprecated and will be removed in a future release. Use <code>file_uris</code> instead. The relative paths reported by <code>files</code> cannot properly be interpreted when using features like shallow clones. <code>file_uris</code> reposrts absolute paths that can handle a more dynamic path resolution.</p>"},{"location":"upgrade-guides/guide-1.0.0/#internal-changes","title":"Internal changes","text":""},{"location":"upgrade-guides/guide-1.0.0/#writerproperties-columnproperties-and-bloomfilterproperties-moved-to-deltalakewriterproperties","title":"<code>WriterProperties</code>, <code>ColumnProperties</code> and <code>BloomFilterProperties</code> moved to <code>deltalake.writer.properties</code>","text":"<p>Can be imported directly with:</p> <pre><code>from deltalake import WriterProperties, ColumnProperties, BloomFilterProperties\n</code></pre>"},{"location":"upgrade-guides/guide-1.0.0/#addaction-commitproperties-and-postcommithookproperties-moved-to-deltalaketransaction","title":"<code>AddAction</code>, <code>CommitProperties</code> and <code>PostCommithookProperties</code> moved to <code>deltalake.transaction</code>","text":"<p>Can be imported directly with:</p> <pre><code>from deltalake import AddAction, CommitProperties, PostCommithookProperties\n</code></pre>"},{"location":"upgrade-guides/guide-1.0.0/#new-features","title":"New features","text":""},{"location":"upgrade-guides/guide-1.0.0/#public-apis-for-transaction-management","title":"Public APIs for transaction management","text":"<p>Functionality previously limited to internal PyArrow writer methods is now publicly available:</p> <ul> <li><code>write_new_deltalake</code> has been renamed to <code>create_table_with_add_actions</code> and is now exposed under deltalake.transaction.</li> <li>You can now initiate a write transaction on an existing table using: <code>DeltaTable.create_write_transaction(...)</code></li> </ul>"},{"location":"upgrade-guides/guide-1.0.0/#behavior-changes-with-unsupported-delta-features","title":"Behavior changes with unsupported delta features \u26a0\ufe0f","text":"<p>Previously, it was possible to work with Delta tables that included unsupported features (e.g., Deletion Vectors) as long as those features were not actively used during an operation/interaction.</p> <p>As of version 1.0.0, this is no longer allowed. DeltaLake will now raise an error if it detects unsupported features in a table. This change ensures safety and avoids inconsistencies stemming from partial or undefined behavior.</p>"},{"location":"usage/appending-overwriting-delta-lake-table/","title":"Appending to and overwriting a Delta Lake table","text":"<p>This section explains how to append to an existing Delta table and how to overwrite a Delta table.</p>"},{"location":"usage/appending-overwriting-delta-lake-table/#delta-lake-append-transactions","title":"Delta Lake append transactions","text":"<p>Suppose you have a Delta table with the following contents:</p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n|     3 | c        |\n+-------+----------+\n</code></pre> <p>Append two additional rows of data to the table:</p> PythonRust <pre><code>from deltalake import write_deltalake, DeltaTable\n\ndf = pd.DataFrame({\"num\": [8, 9], \"letter\": [\"dd\", \"ee\"]})\nwrite_deltalake(\"tmp/some-table\", df, mode=\"append\")\n</code></pre> <p><code>rust     let table = open_table(\"tmp/some-table\").await?;     DeltaOps(table).write(RecordBatch::try_new(         Arc::new(Schema::new(vec![             Field::new(\"num\", DataType::Int32, false),             Field::new(\"letter\", DataType::Utf8, false),         ])),         vec![             Arc::new(Int32Array::from(vec![8, 9])),             Arc::new(StringArray::from(vec![                 \"dd\", \"ee\"             ])),         ])).with_save_mode(SaveMode::Append).await?;</code></p> <p>Here are the updated contents of the Delta table:</p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n|     3 | c        |\n|     8 | dd       |\n|     9 | ee       |\n+-------+----------+\n</code></pre> <p>Now let's see how to perform an overwrite transaction.</p>"},{"location":"usage/appending-overwriting-delta-lake-table/#delta-lake-overwrite-transactions","title":"Delta Lake overwrite transactions","text":"<p>Now let's see how to overwrite the existing Delta table.</p> Python <p><code>python     df = pd.DataFrame({\"num\": [11, 22], \"letter\": [\"aa\", \"bb\"]})     write_deltalake(\"tmp/some-table\", df, mode=\"overwrite\")</code></p> Rust <p><code>rust     let table = open_table(\"tmp/some-table\").await?;     DeltaOps(table).write(RecordBatch::try_new(         Arc::new(Schema::new(vec![             Field::new(\"num\", DataType::Int32, false),             Field::new(\"letter\", DataType::Utf8, false),         ])),         vec![             Arc::new(Int32Array::from(vec![1, 2, 3])),             Arc::new(StringArray::from(vec![                 \"a\", \"b\", \"c\",             ])),         ])).with_save_mode(SaveMode::Overwrite).await?;</code> Here are the contents of the Delta table after the overwrite operation:</p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|    11 | aa       |\n|    22 | bb       |\n+-------+----------+\n</code></pre> <p>Overwriting just performs a logical delete. It doesn't physically remove the previous data from storage. Time travel back to the previous version to confirm that the old version of the table is still accessible.</p> PythonRust <pre><code>dt = DeltaTable(\"tmp/some-table\", version=1)\n</code></pre> <p><code>rust     let mut table = open_table(\"tmp/some-table\").await?;     table.load_version(1).await?;</code></p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n|     3 | c        |\n|     8 | dd       |\n|     9 | ee       |\n+-------+----------+\n</code></pre>"},{"location":"usage/constraints/","title":"Adding a Constraint to a table","text":"<p>Check constraints are a way to enforce that only data that meets the constraint is allowed to be added to the table.</p>"},{"location":"usage/constraints/#add-the-constraint","title":"Add the Constraint","text":"Python Rust <p> <code>DeltaTable</code> <pre><code>from deltalake import DeltaTable\n\ndt = DeltaTable(\"../rust/tests/data/simple_table\")\n\n# Check the schema before hand\nprint(dt.schema())\n# Add the constraint to the table.\ndt.alter.add_constraint({\"id_gt_0\": \"id &gt; 0\"})\n</code></pre></p> <p> <code>DeltaTable</code> <pre><code>let table = deltalake::open_table(\"../rust/tests/data/simple_table\").await?;\nlet ops = DeltaOps(table);\nops.add_constraint().with_constraint(\"id_gt_0\", \"id &gt; 0\").await?;\n</code></pre></p> <p>After you have added the constraint to the table attempting to append data to the table that violates the constraint will instead throw an error.</p>"},{"location":"usage/constraints/#verify-the-constraint-by-trying-to-add-some-data","title":"Verify the constraint by trying to add some data","text":"Python Rust <pre><code>from deltalake import write_deltalake, DeltaTable\nimport pandas as pd\n\ndt = DeltaTable(\"../rust/tests/data/simple_table\")\n\ndf = pd.DataFrame({\"id\": [-1]})\nwrite_deltalake(dt, df, mode=\"append\")\n# _internal.DeltaProtocolError: Invariant violations: [\"Check or Invariant (id &gt; 0) violated by value in row: [-1]\"]\n</code></pre> <pre><code>let mut table = deltalake::open_table(\"../rust/tests/data/simple_table\").await?;\nlet schema = table.snapshot()?.arrow_schema()?;\nlet invalid_values: Vec&lt;Arc&lt;dyn Array&gt;&gt; = vec![\n    Arc::new(Int32Array::from(vec![-10]))\n];\nlet batch = RecordBatch::try_new(schema, invalid_values)?;\nlet mut writer = RecordBatchWriter::for_table(&amp;table)?;\nwriter.write(batch).await?;\nwriter.flush_and_commit(&amp;mut table).await?;\n</code></pre>"},{"location":"usage/create-delta-lake-table/","title":"Creating a Delta Lake Table","text":"<p>This section explains how to create a Delta Lake table.</p> <p>You can easily write a DataFrame to a Delta table.</p> pandasPolarsRust <pre><code>from deltalake import write_deltalake\nimport pandas as pd\n\ndf = pd.DataFrame({\"num\": [1, 2, 3], \"letter\": [\"a\", \"b\", \"c\"]})\nwrite_deltalake(\"tmp/some-table\", df)\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"num\": [1, 2, 3], \"letter\": [\"a\", \"b\", \"c\"]})\ndf.write_delta(\"tmp/some-table\")\n</code></pre> <pre><code>let delta_ops = DeltaOps::try_from_uri(\"tmp/some-table\").await?;\nlet mut table = delta_ops\n    .create()\n    .with_table_name(\"some-table\")\n    .with_save_mode(SaveMode::Overwrite)\n    .with_columns(\n        StructType::new(vec![\n            StructField::new(\n                \"num\".to_string(),\n                DataType::Primitive(PrimitiveType::Integer),\n                true,\n            ),\n            StructField::new(\n                \"letter\".to_string(),\n                DataType::Primitive(PrimitiveType::String),\n                true,\n            ),\n        ])\n        .fields()\n        .cloned(),\n    )\n    .await?;\n\nlet mut record_batch_writer =\n    deltalake::writer::RecordBatchWriter::for_table(&amp;mut table)?;\nrecord_batch_writer\n    .write(\n        RecordBatch::try_new(\n            Arc::new(Schema::new(vec![\n                Field::new(\"num\", DataType::Int32, true),\n                Field::new(\"letter\", Utf8, true),\n            ])),\n            vec![\n                Arc::new(Int32Array::from(vec![1, 2, 3])),\n                Arc::new(StringArray::from(vec![\n                    \"a\", \"b\", \"c\",\n                ])),\n            ],\n        )?,\n    )\n    .await?;\nrecord_batch_writer.flush_and_commit(&amp;mut table).await?;\n</code></pre> <p>Here are the contents of the Delta table in storage:</p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n|     3 | c        |\n+-------+----------+\n</code></pre>"},{"location":"usage/deleting-rows-from-delta-lake-table/","title":"Deleting rows from a Delta Lake table","text":"<p>This section explains how to delete rows from a Delta Lake table.</p> <p>Suppose you have the following Delta table with four rows:</p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n|     3 | c        |\n|     4 | d        |\n+-------+----------+\n</code></pre> <p>Here's how to delete all the rows where the <code>num</code> is greater than 2:</p> PythonRust <pre><code>dt = DeltaTable(\"tmp/my-table\")\ndt.delete(\"num &gt; 2\")\n</code></pre> <p><pre><code>let table = deltalake::open_table(\"./data/simple_table\").await?;\nlet (table, delete_metrics) = DeltaOps(table)\n    .delete()\n    .with_predicate(col(\"num\").gt(lit(2)))\n    .await?;\n</code></pre> <code>with_predicate</code> expects an argument that can be translated to a Datafusion <code>Expression</code>. This can be either using the Dataframe API, or using a <code>SQL where</code> clause: <pre><code>let table = deltalake::open_table(\"./data/simple_table\").await?;\nlet (table, delete_metrics) = DeltaOps(table)\n    .delete()\n    .with_predicate(\"num &gt; 2\")\n    .await?;\n</code></pre></p> <p>Here are the contents of the Delta table after the delete operation has been performed:</p> <pre><code>+-------+----------+\n|   num | letter   |\n|-------+----------|\n|     1 | a        |\n|     2 | b        |\n+-------+----------+\n</code></pre> <p><code>dt.delete()</code> accepts any <code>SQL where</code> clause. If no predicate is provided, all rows will be deleted.</p> <p>Read more in the API docs</p>"},{"location":"usage/examining-table/","title":"Examining a Table","text":""},{"location":"usage/examining-table/#metadata","title":"Metadata","text":"<p>The delta log maintains basic metadata about a table, including:</p> <ul> <li>A unique <code>id</code></li> <li>A <code>name</code>, if provided</li> <li>A <code>description</code>, if provided</li> <li>The list of <code>partitionColumns</code>.</li> <li>The <code>created_time</code> of the table</li> <li>A map of table <code>configuration</code>. This includes fields such as     <code>delta.appendOnly</code>, which if <code>true</code> indicates the table is not meant     to have data deleted from it.</li> </ul> <p>Get metadata from a table with the DeltaTable.metadata() method:</p> PythonRust <pre><code>&gt;&gt;&gt; from deltalake import DeltaTable\n&gt;&gt;&gt; dt = DeltaTable(\"../rust/tests/data/simple_table\")\n&gt;&gt;&gt; dt.metadata()\nMetadata(id: 5fba94ed-9794-4965-ba6e-6ee3c0d22af9, name: None, description: None, partitionColumns: [], created_time: 1587968585495, configuration={})\n</code></pre> <pre><code>let table = deltalake::open_table(\"../rust/tests/data/simple_table\").await?;\nlet metadata = table.metadata()?;\nprintln!(\"metadata: {:?}\", metadata);\n</code></pre>"},{"location":"usage/examining-table/#schema","title":"Schema","text":"<p>The schema for the table is also saved in the transaction log. It can either be retrieved in the Delta Lake form as Schema or as a PyArrow schema. The first allows you to introspect any column-level metadata stored in the schema, while the latter represents the schema the table will be loaded into.</p> PythonRust <p>Use DeltaTable.schema to retrieve the delta lake schema: <pre><code>&gt;&gt;&gt; from deltalake import DeltaTable\n&gt;&gt;&gt; dt = DeltaTable(\"../rust/tests/data/simple_table\")\n&gt;&gt;&gt; dt.schema()\nSchema([Field(id, PrimitiveType(\"long\"), nullable=True)])\n</code></pre></p> <p>Use <code>DeltaTable::get_schema</code> to retrieve the delta lake schema <pre><code>let table = deltalake::open_table(\"./data/simple_table\").await?;\nlet schema = table.get_schema()?;\nprintln!(\"schema: {:?}\", schema);\n</code></pre></p> <p>These schemas have a JSON representation that can be retrieved.</p> PythonRust <p>To reconstruct from json, use DeltaTable.schema.to_json(). <pre><code>&gt;&gt;&gt; dt.schema().to_json()\n'{\"type\":\"struct\",\"fields\":[{\"name\":\"id\",\"type\":\"long\",\"nullable\":true,\"metadata\":{}}]}'\n</code></pre></p> <p>Use <code>serde_json</code> to get the schema as a json. <pre><code>println!(\"{}\", serde_json::to_string_pretty(&amp;schema)?);\n</code></pre></p> <p>It is also possible to retrieve the Arrow schema:</p> PythonRust <p>Use DeltaTable.schema.to_arrow() to retrieve the Arro3 schema:</p> <pre><code>&gt;&gt;&gt; dt.schema().to_arrow()\nid: int64\n</code></pre> <pre><code>let arrow_schema = table.snapshot()?.arrow_schema()?;\nprintln!(\"arrow_schema: {:?}\", schema);\n</code></pre>"},{"location":"usage/examining-table/#history","title":"History","text":"<p>Depending on what system wrote the table, the delta table may have provenance information describing what operations were performed on the table, when, and by whom. This information is retained for 30 days by default, unless otherwise specified by the table configuration <code>delta.logRetentionDuration</code>.</p> <p>Note</p> <p>This information is not written by all writers and different writers may use different schemas to encode the actions. For Spark\\'s format, see: https://docs.delta.io/latest/delta-utility.html#history-schema</p> <p>To view the available history, use <code>DeltaTable.history</code>:</p> PythonRust <pre><code>from deltalake import DeltaTable\n\ndt = DeltaTable(\"../rust/tests/data/simple_table\")\ndt.history()\n</code></pre> <pre><code>[{'timestamp': 1587968626537, 'operation': 'DELETE', 'operationParameters': {'predicate': '[\"((`id` % CAST(2 AS BIGINT)) = CAST(0 AS BIGINT))\"]'}, 'readVersion': 3, 'isBlindAppend': False},\n{'timestamp': 1587968614187, 'operation': 'UPDATE', 'operationParameters': {'predicate': '((id#697L % cast(2 as bigint)) = cast(0 as bigint))'}, 'readVersion': 2, 'isBlindAppend': False},\n{'timestamp': 1587968604143, 'operation': 'WRITE', 'operationParameters': {'mode': 'Overwrite', 'partitionBy': '[]'}, 'readVersion': 1, 'isBlindAppend': False},\n{'timestamp': 1587968596254, 'operation': 'MERGE', 'operationParameters': {'predicate': '(oldData.`id` = newData.`id`)'}, 'readVersion': 0, 'isBlindAppend': False},\n{'timestamp': 1587968586154, 'operation': 'WRITE', 'operationParameters': {'mode': 'ErrorIfExists', 'partitionBy': '[]'}, 'isBlindAppend': True}]\n</code></pre> <pre><code>let table = deltalake::open_table(\"../rust/tests/data/simple_table\").await?;\nlet history = table.history(None).await?;\nprintln!(\"Table history: {:#?}\", history);\n</code></pre>"},{"location":"usage/examining-table/#current-add-actions","title":"Current Add Actions","text":"<p>The active state for a delta table is determined by the Add actions, which provide the list of files that are part of the table and metadata about them, such as creation time, size, and statistics. You can get a data frame of the add actions data using <code>DeltaTable.get_add_actions</code>:</p> <p>&lt;!-- spellchecker:off --!&gt;</p> PythonRust <pre><code>&gt;&gt;&gt; from deltalake import DeltaTable\n&gt;&gt;&gt; dt = DeltaTable(\"../rust/tests/data/delta-0.8.0\")\n&gt;&gt;&gt; dt.get_add_actions(flatten=True).to_pandas()\n                                                    path  size_bytes   modification_time  data_change  num_records  null_count.value  min.value  max.value\n0  part-00000-c9b90f86-73e6-46c8-93ba-ff6bfaf892a...         440 2021-03-06 15:16:07         True            2                 0          0          2\n1  part-00000-04ec9591-0b73-459e-8d18-ba5711d6cbe...         440 2021-03-06 15:16:16         True            2                 0          2          4\n</code></pre> <pre><code>let table = deltalake::open_table(\"./data/simple_table\").await?;\nlet actions = table.snapshot()?.add_actions_table(true)?;\nprintln!(\"{}\", pretty_format_batches(&amp;vec![actions])?);\n</code></pre> <p>This works even with past versions of the table:</p> PythonRust <pre><code>&gt;&gt;&gt; dt = DeltaTable(\"../rust/tests/data/delta-0.8.0\", version=0)\n&gt;&gt;&gt; dt.get_add_actions(flatten=True).to_pandas()\n                                                path  size_bytes   modification_time  data_change  num_records  null_count.value  min.value  max.value\n0  part-00000-c9b90f86-73e6-46c8-93ba-ff6bfaf892a...         440 2021-03-06 15:16:07         True            2                 0          0          2\n1  part-00001-911a94a2-43f6-4acb-8620-5e68c265498...         445 2021-03-06 15:16:07         True            3                 0          2          4\n</code></pre> <pre><code>let mut table = deltalake::open_table(\"./data/simple_table\").await?;\ntable.load_version(0).await?;\nlet actions = table.snapshot()?.add_actions_table(true)?;\nprintln!(\"{}\", pretty_format_batches(&amp;vec![actions])?);\n</code></pre> <p>&lt;!-- spellchecker:on --!&gt;</p>"},{"location":"usage/installation/","title":"Installation","text":"<p>The <code>deltalake</code> project can be installed via pip for Python or Cargo for Rust.</p>"},{"location":"usage/installation/#install-delta-lake-for-python","title":"Install Delta Lake for Python","text":"<p>With pip:</p> <pre><code>pip install deltalake\n</code></pre> <p>With Conda:</p> <pre><code>conda install -c conda-forge deltalake\n</code></pre>"},{"location":"usage/installation/#install-delta-lake-for-rust","title":"Install Delta Lake for Rust","text":"<p>With Cargo:</p> <pre><code>cargo add deltalake\n</code></pre>"},{"location":"usage/installation/#run-delta-lake-and-pandas-in-a-jupyter-notebook","title":"Run Delta Lake and pandas in a Jupyter Notebook","text":"<p>You can easily run Delta Lake and pandas in a Jupyter notebook.</p> <p>Create an environment file with the dependencies as follows:</p> <pre><code>name: deltalake-minimal\nchannels:\n  - conda-forge\n  - defaults\ndependencies:\n  - python=3.11\n  - ipykernel\n  - pandas\n  - polars\n  - jupyterlab\n  - deltalake\n</code></pre> <p>Create a virtual environment with the dependencies:</p> <pre><code>conda env create -f deltalake-minimal.yml\n</code></pre> <p>Open the Jupyter notebook and run commands as follows:</p> <p></p>"},{"location":"usage/loading-table/","title":"Loading a Delta Table","text":"<p>A DeltaTable represents the state of a delta table at a particular version. This includes which files are currently part of the table, the schema of the table, and other metadata such as creation time.</p>  Python Rust <p> <code>DeltaTable</code> <pre><code>from deltalake import DeltaTable\n\ndt = DeltaTable(\"../rust/tests/data/delta-0.2.0\")\nprint(f\"Version: {dt.version()}\")\nprint(f\"Files: {dt.files()}\")\n</code></pre></p> <p> <code>DeltaTable</code> <pre><code>let table = deltalake::open_table(\"../rust/tests/data/simple_table\").await.unwrap();\nprintln!(\"Version: {}\", table.version());\nprintln!(\"Files: {}\", table.get_files());\n</code></pre></p> <p>Depending on your storage backend, you could use the <code>storage_options</code> parameter to provide some configuration. Configuration is defined for specific backends - s3 options, azure options, gcs options.</p> PythonRust <pre><code>&gt;&gt;&gt; storage_options = {\"AWS_ACCESS_KEY_ID\": \"THE_AWS_ACCESS_KEY_ID\", \"AWS_SECRET_ACCESS_KEY\":\"THE_AWS_SECRET_ACCESS_KEY\"}\n&gt;&gt;&gt; dt = DeltaTable(\"../rust/tests/data/delta-0.2.0\", storage_options=storage_options)\n</code></pre> <pre><code>let storage_options = HashMap::from_iter(vec![\n    (\"AWS_ACCESS_KEY_ID\".to_string(), \"THE_AWS_ACCESS_KEY_ID\".to_string()),\n    (\"AWS_SECRET_ACCESS_KEY\".to_string(), \"THE_AWS_SECRET_ACCESS_KEY\".to_string()),\n]);\nlet table = open_table_with_storage_options(\"../rust/tests/data/delta-0.2.0\", storage_options).await?;\n</code></pre> <p>The configuration can also be provided via the environment, and the basic service provider is derived from the URL being used. We try to support many of the well-known formats to identify basic service properties.</p> <p>S3:</p> <ul> <li>s3://\\&lt;bucket&gt;/\\&lt;path&gt;</li> <li>s3a://\\&lt;bucket&gt;/\\&lt;path&gt;</li> </ul> <p>Note that <code>delta-rs</code> does not read credentials from a local <code>.aws/config</code> or <code>.aws/creds</code> file. Credentials can be accessed from environment variables, ec2 metadata, profiles or web identity. You can also pass credentials to <code>storage_options</code> using <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code>.</p> <p>Azure:</p> <ul> <li>az://\\&lt;container&gt;/\\&lt;path&gt;</li> <li>adl://\\&lt;container&gt;/\\&lt;path&gt;</li> <li>abfs://\\&lt;container&gt;/\\&lt;path&gt;</li> </ul> <p>GCS:</p> <ul> <li>gs://\\&lt;bucket&gt;/\\&lt;path&gt;</li> </ul>"},{"location":"usage/loading-table/#verify-table-existence","title":"Verify Table Existence","text":"<p>You can check whether or not a Delta table exists at a particular path by using the <code>DeltaTable.is_deltatable()</code> method.</p> PythonRust <pre><code>from deltalake import DeltaTable\n\ntable_path = \"&lt;path/to/valid/table&gt;\"\nDeltaTable.is_deltatable(table_path)\n# True\n\ninvalid_table_path = \"&lt;path/to/nonexistent/table&gt;\"\nDeltaTable.is_deltatable(invalid_table_path)\n# False\n\nbucket_table_path = \"&lt;path/to/valid/table/in/bucket&gt;\"\nstorage_options = {\n    \"AWS_ACCESS_KEY_ID\": \"THE_AWS_ACCESS_KEY_ID\",\n    \"AWS_SECRET_ACCESS_KEY\": \"THE_AWS_SECRET_ACCESS_KEY\",\n    ...\n}\nDeltaTable.is_deltatable(bucket_table_path, storage_options)\n# True\n</code></pre> <pre><code>let table_path = \"&lt;path/to/valid/table&gt;\";\nlet builder = deltalake::DeltaTableBuilder::from_uri(table_path);\nbuilder.build()?.verify_deltatable_existence().await?;\n// true\n\nlet invalid_table_path = \"&lt;path/to/nonexistent/table&gt;\";\nlet builder = deltalake::DeltaTableBuilder::from_uri(invalid_table_path);\nbuilder.build()?.verify_deltatable_existence().await?;\n// false\n\nlet bucket_table_path = \"&lt;path/to/valid/table/in/bucket&gt;\";\nlet storage_options = HashMap::from_iter(vec![\n    (\"AWS_ACCESS_KEY_ID\".to_string(), \"THE_AWS_ACCESS_KEY_ID\".to_string()),\n    (\"AWS_SECRET_ACCESS_KEY\".to_string(), \"THE_AWS_SECRET_ACCESS_KEY\".to_string()),\n]);\nlet builder = deltalake::DeltaTableBuilder::from_uri(bucket_table_path).with_storage_options(storage_options);\nbuilder.build()?.verify_deltatable_existence().await?;\n// true\n</code></pre>"},{"location":"usage/loading-table/#custom-storage-backends","title":"Custom Storage Backends","text":"<p>While delta always needs its internal storage backend to work and be properly configured, in order to manage the delta log, it may sometime be advantageous - and is common practice in the arrow world - to customize the storage interface used for reading the bulk data.</p> <p><code>deltalake</code> will work with any storage compliant with <code>pyarrow.fs.FileSystem</code>, however the root of the filesystem has to be adjusted to point at the root of the Delta table. We can achieve this by wrapping the custom filesystem into a <code>pyarrow.fs.SubTreeFileSystem</code>.</p> <pre><code>import pyarrow.fs as fs\nfrom deltalake import DeltaTable\n\npath = \"&lt;path/to/table&gt;\"\nfilesystem = fs.SubTreeFileSystem(path, fs.LocalFileSystem())\n\ndt = DeltaTable(path)\nds = dt.to_pyarrow_dataset(filesystem=filesystem)\n</code></pre> <p>When using the pyarrow factory method for file systems, the normalized path is provided on creation. In case of S3 this would look something like:</p> <pre><code>import pyarrow.fs as fs\nfrom deltalake import DeltaTable\n\ntable_uri = \"s3://&lt;bucket&gt;/&lt;path&gt;\"\nraw_fs, normalized_path = fs.FileSystem.from_uri(table_uri)\nfilesystem = fs.SubTreeFileSystem(normalized_path, raw_fs)\n\ndt = DeltaTable(table_uri)\nds = dt.to_pyarrow_dataset(filesystem=filesystem)\n</code></pre>"},{"location":"usage/loading-table/#time-travel","title":"Time Travel","text":"<p>To load previous table states, you can provide the version number you wish to load:</p> PythonRust <pre><code>&gt;&gt;&gt; dt = DeltaTable(\"../rust/tests/data/simple_table\", version=2)\n</code></pre> <pre><code>let mut table = open_table(\"./data/simple_table\").await?;\ntable.load_version(1).await?;\n</code></pre> <p>Once you've loaded a table, you can also change versions using either a version number or datetime string:</p> PythonRust <pre><code>&gt;&gt;&gt; dt.load_version(1)\n&gt;&gt;&gt; dt.load_with_datetime(\"2021-11-04 00:05:23.283+00:00\")\n</code></pre> <pre><code>table.load_version(1).await?;\ntable.load_with_datetime(\"2021-11-04 00:05:23.283+00:00\".parse().unwrap()).await?;\n</code></pre> <p>Warning</p> <p>Previous table versions may not exist if they have been vacuumed, in which case an exception will be thrown. See Vacuuming tables for more information.</p>"},{"location":"usage/loading-table/#load-table-from-unity-catalog","title":"Load table from Unity Catalog","text":"<p>You may load a Delta Table from your Databricks or Open Source Unity Catalog using a <code>uc://</code> URL of format <code>uc://&lt;catalog-name&gt;.&lt;db-name&gt;.&lt;table-name&gt;</code>. Example as follows:</p> Python <pre><code>import os\nfrom deltalake import DeltaTable\n\n# Set your Unity Catalog workspace URL in the\n# DATABRICKS_WORKSPACE_URL environment variable.\nos.environ[\"DATABRICKS_WORKSPACE_URL\"] = \"https://adb-1234567890.XX.azuredatabricks.net\"\n\n# Set your Unity Catalog access token in the\n# DATABRICKS_ACCESS_TOKEN environment variable.\nos.environ[\"DATABRICKS_ACCESS_TOKEN\"] = \"&lt;unity-catalog-access-token-here&gt;\"\n\n# Your Unity Catalog name here\ncatalog_name = \"unity\"\n\n# Your UC database name here\ndb_name = \"my_database\"\n\n# Your table name in the UC database here\ntable_name = \"my_table\"\n\n# Full UC URL in required format\nuc_full_url = f\"{catalog_name}.{db_name}.{table_name}\"\n\n# This should load the valid delta table at specified location,\n# and you can start using it.\ndt = DeltaTable(uc_full_url)\ndt.is_deltatable(dt.table_uri)\n# True\n</code></pre>"},{"location":"usage/managing-tables/","title":"Managing Delta Tables","text":""},{"location":"usage/managing-tables/#vacuuming-tables","title":"Vacuuming tables","text":"<p>Vacuuming a table will delete any files that have been marked for deletion. This may make some past versions of a table invalid, so this can break time travel. However, it will save storage space. Vacuum will retain files in a certain window, by default one week, so time travel will still work in shorter ranges.</p> <p>Delta tables usually don't delete old files automatically, so vacuuming regularly is considered good practice, unless the table is only appended to.</p> <p>Use <code>DeltaTable.vacuum</code> to perform the vacuum operation. Note that to prevent accidental deletion, the function performs a dry-run by default: it will only list the files to be deleted. Pass <code>dry_run=False</code> to actually delete files.</p> PythonRust <pre><code>&gt;&gt;&gt; dt = DeltaTable(\"../rust/tests/data/simple_table\")\n&gt;&gt;&gt; dt.vacuum()\n['../rust/tests/data/simple_table/part-00006-46f2ff20-eb5d-4dda-8498-7bfb2940713b-c000.snappy.parquet',\n'../rust/tests/data/simple_table/part-00190-8ac0ae67-fb1d-461d-a3d3-8dc112766ff5-c000.snappy.parquet',\n'../rust/tests/data/simple_table/part-00164-bf40481c-4afd-4c02-befa-90f056c2d77a-c000.snappy.parquet',\n...]\n&gt;&gt;&gt; dt.vacuum(dry_run=False) # Don't run this unless you are sure!\n</code></pre> <pre><code>let mut table = open_table(\"./data/simple_table\").await?;\nlet (table, vacuum_metrics) = DeltaOps(table).vacuum().with_dry_run(true).await?;\nprintln!(\"Files deleted: {:?}\", vacuum_metrics.files_deleted);\n\nlet (table, vacuum_metrics) = DeltaOps(table).vacuum().with_dry_run(false).await?;\n</code></pre>"},{"location":"usage/managing-tables/#optimizing-tables","title":"Optimizing tables","text":"<p>Optimizing a table compacts small files into larger files to avoid the small file problem. This is especially important for tables that get small amounts of data appended to with high frequency. In addition to compacting small files, you can colocate similar data in the same files with Z Ordering, which allows for better file skipping and faster queries.</p> <p>A table <code>dt = DeltaTable(...)</code> has two methods for optimizing it:</p> <ul> <li><code>dt.optimize.compact()</code> for compacting small files,</li> <li><code>dt.optimize.z_order()</code> to compact and apply Z Ordering.</li> </ul> <p>See the section Small file compaction for more information and a detailed example on <code>compact</code>, and the section Z Order for more information on <code>z_order</code>.</p> PythonRust <pre><code>dt = DeltaTable(...)\ndt.optimize.compact()\n</code></pre> <pre><code>let mut table = open_table(\"./data/simple_table\").await?;\nlet (table, metrics) = DeltaOps(table).optimize().with_type(OptimizeType::Compact).await?;\n</code></pre>"},{"location":"usage/merging-tables/","title":"Merging a Table","text":"<p>Delta Lake <code>MERGE</code> operations allow you to merge source data into a target table based on specific conditions. <code>MERGE</code> operations are great for making selective changes to your Delta table without having to rewrite the entire table.</p> <p>Use <code>dt.merge()</code> with a single or multiple conditional statements to perform CRUD operations (Create, Read, Update, Delete) at scale. You can also use Delta Lake merge for efficient Change Data Capture (CDC), Slowly Changing Dimensions (SDC) operations and to ensure GDPR compliance.</p>"},{"location":"usage/merging-tables/#basic-structure-of-merge-command","title":"Basic Structure of <code>MERGE</code> Command","text":"<p>Let\u2019s start by understanding the basic structure of a Delta Lake <code>MERGE</code> command in delta-rs.</p> <p>Use the TableMerger API to construct a <code>MERGE</code> command with one or multiple conditional clauses:</p> <pre><code>    (\n        dt.merge(                                       # target data\n            source=source_data,                         # source data\n            predicate=\"target.x = source.x\",\n            source_alias=\"source\",\n            target_alias=\"target\")\n        .when_matched_update(                           # conditional statement\n            updates={\"x\": \"source.x\", \"y\":\"source.y\"})\n        .execute()\n    )\n</code></pre> <p>In the syntax above:</p> <ul> <li><code>dt</code> is your target Delta table</li> <li><code>source_data</code> is your source data</li> <li><code>source</code> and <code>target</code> are your respective aliases for your source and target datasets</li> <li><code>when_matched_update</code> is one of many possible conditional statements, see the sections below for more</li> <li><code>execute()</code> executes the MERGE operation with the specified settings</li> </ul> <p>Note that executing a <code>MERGE</code> operation automatically writes the changes to your Delta table in a single transaction.</p>"},{"location":"usage/merging-tables/#update","title":"Update","text":"<p>Use <code>when_matched_update</code> to perform an UPDATE operation.</p> <p>You can define the rules for the update using the <code>updates</code> keyword. If a <code>predicate</code> is passed to <code>merge()</code> then only rows which evaluate to true will be updated.</p> <p>For example, let\u2019s update the value of a column in the target table based on a matching row in the source table.</p> PythonRust <pre><code>from deltalake import DeltaTable, write_deltalake\nimport pyarrow as pa\n\n# define target table\n&gt; target_data = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\n&gt; write_deltalake(\"tmp_table\", target_data)\n&gt; dt = DeltaTable(\"tmp_table\")\n&gt; dt.to_pandas().sort_values(\"x\", ignore_index=True)\n\nx  y\n0  1  4\n1  2  5\n2  3  6\n\n# define source table\n&gt; source_data = pa.table({\"x\": [2, 3], \"y\": [5,8]})\n&gt; source_data\n\nx  y\n0  2  5\n1  3  8\n\n# define merge logic\n&gt; (\n&gt;     dt.merge(\n&gt;         source=source_data,\n&gt;         predicate=\"target.x = source.x\",\n&gt;         source_alias=\"source\",\n&gt;         target_alias=\"target\")\n&gt;     .when_matched_update(\n&gt;         updates={\"x\": \"source.x\", \"y\":\"source.y\"})\n&gt;     .execute()\n&gt; )\n</code></pre> <pre><code>// define target table\nlet delta_ops = DeltaOps::try_from_uri(\"tmp/some-table\").await?;\nlet mut table = delta_ops\n    .create()\n    .with_table_name(\"some-table\")\n    .with_save_mode(SaveMode::Overwrite)\n    .with_columns(\n        StructType::new(vec![\n            StructField::new(\n                \"x\".to_string(),\n                DataType::Primitive(PrimitiveType::Integer),\n                true,\n            ),\n            StructField::new(\n                \"y\".to_string(),\n                DataType::Primitive(PrimitiveType::Integer),\n                true,\n            ),\n        ])\n        .fields()\n        .cloned(),\n    )\n    .await?;\n\nlet schema = Arc::new(Schema::new(vec![\n    Field::new(\"x\", arrow::datatypes::DataType::Int32, true),\n    Field::new(\"y\", arrow::datatypes::DataType::Int32, true),\n]));\nlet mut record_batch_writer = deltalake::writer::RecordBatchWriter::for_table(&amp;mut table)?;\nrecord_batch_writer\n    .write(RecordBatch::try_new(\n        schema.clone(),\n        vec![\n            Arc::new(Int32Array::from(vec![1, 2, 3])),\n            Arc::new(Int32Array::from(vec![4, 5, 6])),\n        ],\n    )?)\n    .await?;\n\nrecord_batch_writer.flush_and_commit(&amp;mut table).await?;\n\nlet ctx = SessionContext::new();\nlet source_data = ctx.read_batch(RecordBatch::try_new(\n    schema,\n    vec![\n        Arc::new(Int32Array::from(vec![2, 3])),\n        Arc::new(Int32Array::from(vec![5, 6])),\n    ],\n)?)?;\n\nDeltaOps(table)\n    .merge(source_data, \"target.x = source.x\")\n    .with_source_alias(\"source\")\n    .with_target_alias(\"target\")\n    .when_matched_update(|update| \n        update\n        .update(\"x\", \"source.x\")\n        .update(\"y\", \"source.y\"))?\n    .await?;\n</code></pre> <p>First, we match rows for which the <code>x</code> values are the same using <code>predicate=\"target.x = source.x\"</code>. We then update the <code>x</code> and <code>y</code> values of the matched row with the new (source) values using <code>updates={\"x\": \"source.x\", \"y\":\"source.y\"}</code>.</p> <pre><code># inspect result\n&gt; dt.to_pandas().sort_values(\"x\", ignore_index=True)\n\n   x  y\n0  1  4\n1  2  5\n2  3  8\n</code></pre> <p>The value of the <code>y</code> column has been correctly updated for the row that matches our predicate.</p> <p>You can also use <code>when_matched_update_all</code> to update all source fields to target fields. In this case, source and target are required to have the same field names.</p>"},{"location":"usage/merging-tables/#insert","title":"Insert","text":"<p>Use <code>when_not_matched_insert</code> to perform an INSERT operation.</p> <p>For example, let\u2019s say we start with the same target table:</p> PythonRust <pre><code>&gt; target_data = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\n&gt; write_deltalake(\"tmp_table\", target_data)\n&gt; dt = DeltaTable(\"tmp_table\")\n\nx  y\n0  1  4\n1  2  5\n2  3  6\n</code></pre> <pre><code>let delta_ops = DeltaOps::try_from_uri(\"./data/simple_table\").await?;\nlet mut table = delta_ops\n    .create()\n    .with_table_name(\"some-table\")\n    .with_save_mode(SaveMode::Overwrite)\n    .with_columns(\n        StructType::new(vec![\n            StructField::new(\n                \"x\".to_string(),\n                DataType::Primitive(PrimitiveType::Integer),\n                true,\n            ),\n            StructField::new(\n                \"y\".to_string(),\n                DataType::Primitive(PrimitiveType::Integer),\n                true,\n            ),\n        ])\n        .fields()\n        .cloned(),\n    )\n    .await?;\n\nlet schema = Arc::new(Schema::new(vec![\n    Field::new(\"x\", arrow::datatypes::DataType::Int32, true),\n    Field::new(\"y\", arrow::datatypes::DataType::Int32, true),\n]));\nlet mut record_batch_writer = deltalake::writer::RecordBatchWriter::for_table(&amp;mut table)?;\nrecord_batch_writer\n    .write(RecordBatch::try_new(\n        schema.clone(),\n        vec![\n            Arc::new(Int32Array::from(vec![1, 2, 3])),\n            Arc::new(Int32Array::from(vec![4, 5, 6])),\n        ],\n    )?)\n    .await?;\n\nrecord_batch_writer.flush_and_commit(&amp;mut table).await?;\n</code></pre> <p>And we want to merge only new records from our source data, without duplication:</p> PythonRust <pre><code>&gt; source_data = pa.table({\"x\": [2,3,7], \"y\": [4,5,8]})\n\nx  y\n0  2  5\n1  3  6\n2  7  8\n</code></pre> <pre><code>    let ctx = SessionContext::new();\nlet source_data = ctx.read_batch(RecordBatch::try_new(\n    schema,\n    vec![\n        Arc::new(Int32Array::from(vec![2, 3])),\n        Arc::new(Int32Array::from(vec![5, 6])),\n    ],\n)?)?;\n</code></pre> <p>The <code>MERGE</code> syntax would be as follows:</p> PythonRust <pre><code>(\n    dt.merge(\n        source=source_data,\n        predicate=\"target.x = source.x\",\n        source_alias=\"source\",\n        target_alias=\"target\")\n    .when_not_matched_insert(\n        updates={\"x\": \"source.x\", \"y\":\"source.y\"})\n    .execute()\n)\n\n&gt; # inspect result\n&gt; print(dt.to_pandas().sort_values(\"x\", ignore_index=True))\n\nx  y\n0  1  4\n1  2  5\n2  3  6\n3  7  8\n</code></pre> <pre><code>DeltaOps(table)\n.merge(source_data, \"target.x = source.x\")\n.with_source_alias(\"source\")\n.with_target_alias(\"target\")\n.when_not_matched_insert(\n    |insert| insert.set(\"x\", \"source.x\").set(\"y\", \"source.y\")\n)?.await?;\n</code></pre> <p>The new row has been successfully added to the target dataset.</p> <p>You can also use <code>when_not_matched_insert_all</code> to insert a new row to the target table, updating all source fields to target fields. In this case, source and target are required to have the same field names.</p>"},{"location":"usage/merging-tables/#delete","title":"Delete","text":"<p>Use <code>when_matched_delete</code> to perform a DELETE operation.</p> <p>For example, given the following <code>target_data</code> and <code>source_data</code>:</p> <pre><code>target_data = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\nwrite_deltalake(\"tmp_table\", target_data)\ndt = DeltaTable(\"tmp_table\")\nsource_data = pa.table({\"x\": [2, 3], \"deleted\": [False, True]})\n</code></pre> <p>You can delete the rows that match a predicate (in this case <code>\"deleted\" = True</code>) using:</p> PythonRust <pre><code>(\n    dt.merge(\n        source=source_data,\n        predicate=\"target.x = source.x\",\n        source_alias=\"source\",\n        target_alias=\"target\")\n    .when_matched_delete(\n        predicate=\"source.deleted = true\")\n    .execute()\n)\n</code></pre> <pre><code>DeltaOps(table)\n.merge(source_data, \"target.x = source.x\")\n.with_source_alias(\"source\")\n.with_target_alias(\"target\")\n.when_matched_delete(\n    |delete| delete.predicate(\"source.deleted = true\")\n)?.await?;\n</code></pre> <p>This will result in:</p> <pre><code>&gt; dt.to_pandas().sort_values(\"x\", ignore_index=True)\n\n   x  y\n0  1  4\n1  2  5\n</code></pre> <p>The matched row has been successfully deleted.</p>"},{"location":"usage/merging-tables/#upsert","title":"Upsert","text":"<p>You can combine conditional statements to perform more complex operations.</p> <p>To perform an upsert operation, use <code>when_matched_update</code> and <code>when_not_matched_insert</code> in a single <code>merge()</code> clause.</p> <p>For example:</p> PythonRust <pre><code>target_data = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\nwrite_deltalake(\"tmp_table\", target_data)\ndt = DeltaTable(\"tmp_table\")\nsource_data = pa.table({\"x\": [2, 3, 5], \"y\": [5, 8, 11]})\n\n(\n    dt.merge(\n        source=source_data,\n        predicate=\"target.x = source.x\",\n        source_alias=\"source\",\n        target_alias=\"target\")\n    .when_matched_update(\n        updates={\"x\": \"source.x\", \"y\":\"source.y\"})\n    .when_not_matched_insert(\n        updates={\"x\": \"source.x\", \"y\":\"source.y\"})\n    .execute()\n)\n</code></pre> <pre><code>DeltaOps(table)\n.merge(source_data, \"target.x = source.x\")\n.with_source_alias(\"source\")\n.with_target_alias(\"target\")\n.when_matched_update(\n    |update| update.update(\"x\", \"source.x\").update(\"y\", \"source.y\"),\n)?\n.when_not_matched_insert(\n    |insert| insert.set(\"x\", \"source.x\").set(\"y\", \"source.y\"),\n)?\n.await?;\n</code></pre> <p>This will give you the following output:</p> <pre><code>&gt; dt.to_pandas().sort_values(\"x\", ignore_index=True)\n\n   x  y\n0  1  4\n1  2  5\n2  3  8\n3  5  11\n</code></pre>"},{"location":"usage/merging-tables/#upsert-with-delete","title":"Upsert with Delete","text":"<p>Use the <code>when_matched_delete</code> or <code>when_not_matched_by_source_delete</code> methods to add a DELETE operation to your upsert. This is helpful if you want to delete stale records from the target data.</p> <p>For example, given the same <code>target_data</code> and <code>source_data</code> used in the section above:</p> PythonRust <pre><code>(\n    dt.merge(\n        source=source_data,\n        predicate=\"target.x = source.x\",\n        source_alias=\"source\",\n        target_alias=\"target\")\n    .when_matched_update(\n        updates={\"x\": \"source.x\", \"y\":\"source.y\"})\n    .when_not_matched_insert(\n        updates={\"x\": \"source.x\", \"y\":\"source.y\"})\n    .when_not_matched_by_source_delete()\n    .execute()\n)\n</code></pre> <pre><code>DeltaOps(table)\n.merge(source_data, \"target.x = source.x\")\n.with_source_alias(\"source\")\n.with_target_alias(\"target\")\n.when_matched_update(\n    |update| update.update(\"x\", \"source.x\").update(\"y\", \"source.y\"),\n)?\n.when_not_matched_insert(\n    |insert| insert.set(\"x\", \"source.x\").set(\"y\", \"source.y\"),\n)?\n.when_not_matched_by_source_delete(|delete| delete)?\n.await?;\n</code></pre> <p>This will result in:</p> <pre><code>&gt; dt.to_pandas().sort_values(\"x\", ignore_index=True)\n\n   x  y\n0  2  5\n1  3  8\n2  5  11\n</code></pre> <p>The row containing old data no longer present in the source dataset has been successfully deleted.</p>"},{"location":"usage/merging-tables/#multiple-matches","title":"Multiple Matches","text":"<p>Note that when multiple match conditions are met, the first condition that matches is executed.</p> <p>For example, given the following <code>target_data</code> and <code>source_data</code>:</p> <pre><code>target_data = pa.table({\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\nwrite_deltalake(\"tmp_table\", target_data)\ndt = DeltaTable(\"tmp_table\")\nsource_data = pa.table({\"x\": [2, 3, 5], \"y\": [5, 8, 11]})\n</code></pre> <p>Let\u2019s perform a merge with <code>when_matched_delete</code> first, followed by <code>when_matched_update</code>:</p> <pre><code>(\n    dt.merge(\n        source=source_data,\n        predicate=\"target.x = source.x\",\n        source_alias=\"source\",\n        target_alias=\"target\")\n    .when_matched_delete(\n        predicate=\"source.x = target.x\")\n    .when_matched_update(\n        updates={\"x\": \"source.x\", \"y\":\"source.y\"})\n    .execute()\n)\n</code></pre> <p>This will result in:</p> <pre><code>&gt; dt.to_pandas().sort_values(\"x\", ignore_index=True)\n\n   x  y\n0  1  4\n</code></pre> <p>Let\u2019s now perform the merge with the flipped order: <code>update</code> first, then <code>delete</code>:</p> <pre><code>(\n    dt.merge(\n        source=source_data,\n        predicate=\"target.x = source.x\",\n        source_alias=\"source\",\n        target_alias=\"target\")\n    .when_matched_update(\n        updates={\"x\": \"source.x\", \"y\":\"source.y\"})\n    .when_matched_delete(\n        predicate=\"source.x = target.x\")\n    .execute()\n)\n</code></pre> <p>This will result in:</p> <pre><code>&gt; dt.to_pandas().sort_values(\"x\", ignore_index=True)\n\n   x  y\n0  1  4\n1  2  5\n2  3  8\n</code></pre>"},{"location":"usage/merging-tables/#conditional-updates","title":"Conditional Updates","text":"<p>You can perform conditional updates for rows that have no match in the source data using when_not_matched_by_source_update.</p> <p>For example, given the following target_data and source_data:</p> <pre><code>target_data = pa.table({\"1 x\": [1, 2, 3], \"1y\": [4, 5, 6]})\nwrite_deltalake(\"tmp\", target_data)\ndt = DeltaTable(\"tmp\")\nsource_data = pa.table({\"x\": [2, 3, 4]})\n</code></pre> <p>Set y = 0 for all rows that have no matches in the new source data, provided that the original y value is greater than 3:</p> <pre><code>(\n   dt.merge(\n       source=new_data,\n       predicate='target.x = source.x',\n       source_alias='source',\n       target_alias='target')\n   .when_not_matched_by_source_update(\n       predicate = \"`1y` &gt; 3\",\n       updates = {\"`1y`\": \"0\"})\n   .execute()\n)\n</code></pre> <p>This will result in:</p> <pre><code>&gt; dt.to_pandas().sort_values(\"x\", ignore_index=True)\n   x  y\n0  1  0\n1  2  5\n2  3  6\n</code></pre>"},{"location":"usage/merging-tables/#notes","title":"Notes","text":"<ul> <li>Column names with special characters, such as numbers or spaces should be encapsulated in backticks: \"target.<code>123column</code>\" or \"target.<code>my column</code>\"</li> </ul>"},{"location":"usage/merging-tables/#optimizing-merge-performance","title":"Optimizing Merge Performance","text":"<p>Delta Lake merge operations can be resource intensive when working with large tables. Processing time and compute resources can be significantly reduced by using efficient predicates which are specific to the data being merged.</p> <p>The following strategies explain how to optimize merge operations for better performance.</p>"},{"location":"usage/merging-tables/#1-add-partition-columns-to-predicates","title":"1. Add Partition Columns to Predicates","text":"<p>When your table is partitioned, including partition columns in your merge predicate can improve performance by enabling file pruning:</p> <pre><code># Good - uses partition column and value\n(\n    dt.merge(\n        source=source_data,\n        predicate=\"s.id = t.id AND s.month_id = t.month_id AND t.month_id = 202501\",  # month_id is a partition column\n        source_alias=\"s\",\n        target_alias=\"t\")\n    .execute()\n)\n\n\n# Less optimal - no partition column usage\n(\n    dt.merge(\n        source=source_data,\n        predicate=\"s.id = t.id\",  # No partition column specified\n        source_alias=\"s\",\n        target_alias=\"t\")\n    .execute()\n)\n</code></pre> <p>As you can see, your filter should specify the partition column(s) and the value(s) you want to target during the merge operation. This is especially important when using the default argument <code>streamed_exec=True</code> in the <code>merge</code> method which disables the use of source table statistics to derive an early pruning predicate. Without these statistics, explicit predicates in your merge condition are required for file pruning.</p>"},{"location":"usage/merging-tables/#2-add-additional-filter-columns-to-predicates","title":"2. Add Additional Filter Columns to Predicates","text":"<p>Partitioning data on certain columns may be inefficient when it creates an excessive number of files or results in files that are too small.</p> <p>For example, you might have a source which is updated daily with the previous date's data. If the size of the data is too small to justify daily partitioning, you can use the following predicate to prune the monthly partition and only join the previous day's data:</p> <pre><code># The predicate below prunes the monthly partition and only joins the previous day's data\n# Note: the table is only partitioned by the `month_id` column. The `date_id` value is computed from the source data.\n(\n    dt.merge(\n        source=source_data,\n        predicate=\"s.id = t.id AND s.month_id = t.month_id AND t.month_id = 202501 AND s.date_id = t.date_id AND t.date_id = 20250120\",\n        source_alias=\"s\",\n        target_alias=\"t\")\n    .execute()\n)\n</code></pre>"},{"location":"usage/merging-tables/#performance-impact","title":"Performance Impact","text":"<p>The effectiveness of these optimizations can be monitored using the operation metrics:</p> <pre><code>metrics = dt.merge(...).execute()\n\nprint(f\"Files scanned: {metrics.get('num_target_files_scanned')}\")\nprint(f\"Files skipped: {metrics.get('num_target_files_skipped_during_scan')}\")\nprint(f\"Execution time: {metrics.get('execution_time_ms')} ms\")\n</code></pre> <p>An efficient merge operation should show:</p> <ul> <li>A high ratio of skipped files to scanned files</li> <li>Lower execution time compared to less specific predicates</li> </ul> <p>Here is an example of logs from a merge operation with a partitioned table without adding the partition columns to the predicates:</p> <pre><code>Merging table with predicates: {\n    'merge': 's.unique_constraint_hash = t.unique_constraint_hash',\n    'when_matched_update_all': 's.post_transform_row_hash != t.post_transform_row_hash'\n}\nFiles Scanned: 24\nFiles Skipped: 0\nFiles Added: 1\nExecution Time: 23774ms\n</code></pre> <p>The table is partitioned by the <code>month_id</code> column and all files are scanned which is not efficient. If we add the partition columns to the predicates, the merge operation will only scan the relevant files which is faster and more efficient:</p> <pre><code>Merging table with predicates: {\n    'merge': 's.unique_constraint_hash = t.unique_constraint_hash AND s.month_id = t.month_id AND t.month_id = 202503',\n    'when_matched_update_all': 's.post_transform_row_hash != t.post_transform_row_hash AND s.month_id = t.month_id AND t.month_id = 202503'\n}\nFiles Scanned: 1\nFiles Skipped: 10\nFiles Added: 1\nExecution Time: 2964ms\n</code></pre> <p>For this specific source, it is known that each data update only includes a few recent days. This means that we can further optimize the merge operation by making the predicate even more specific by adding the unique <code>date_id</code> column values to the predicates.</p> <pre><code> Merging table with predicates: {\n    'merge': 's.unique_constraint_hash = t.unique_constraint_hash AND s.month_id = t.month_id AND t.month_id = 202503 AND s.date_id = t.date_id AND t.date_id IN (20250314, 20250315, 20250316)',\n    'when_matched_update_all': 's.post_transform_row_hash != t.post_transform_row_hash AND s.month_id = t.month_id AND t.month_id = 202503 AND s.date_id = t.date_id AND t.date_id IN (20250314, 20250315, 20250316)'\n}\nFiles Scanned: 0\nFiles Skipped: 18\nFiles Added: 1\nExecution Time: 416ms\n</code></pre> <p>The final result skips all files that are not relevant to the merge operation and is significantly faster (98%) than the original operation.</p>"},{"location":"usage/merging-tables/#best-practices","title":"Best Practices","text":"<ol> <li>Always Include Partition Columns: If your table is partitioned, include partition columns in your merge predicates</li> <li>Keep Statistics Updated: Regular table optimization helps Delta Lake make better decisions about file pruning</li> <li>Monitor Metrics: Use the operation metrics to verify the effectiveness of your predicates</li> </ol>"},{"location":"usage/overview/","title":"Usage","text":"<p>This guide teaches you how to use Delta Lake.  You will learn how to create Delta tables, run queries, perform DML operations, and optimize your tables.</p> <p>It's easy to use Delta Lake with pandas, Polars, Rust, or any other PyArrow-like DataFrame library.</p> <p>See the Spark Delta Lake documentation if you're using Delta Lake with Spark.</p>"},{"location":"usage/querying-delta-tables/","title":"Querying Delta Tables","text":"<p>Delta tables can be queried in several ways. By loading as Arrow data or an Arrow dataset, they can be used by compatible engines such as Pandas and DuckDB. By passing on the list of files, they can be loaded into other engines such as Dask.</p> <p>Delta tables are often larger than can fit into memory on a single computer, so this module provides ways to read only the parts of the data you need. Partition filters allow you to skip reading files that are part of irrelevant partitions. Only loading the columns required also saves memory. Finally, some methods allow reading tables batch-by-batch, allowing you to process the whole table while only having a portion loaded at any given time.</p> <p>To load into Pandas or a PyArrow table use the <code>DeltaTable.to_pandas</code> and <code>DeltaTable.to_pyarrow_table</code> methods, respectively. Both of these support filtering partitions and selecting particular columns.</p> <pre><code>&gt;&gt;&gt; from deltalake import DeltaTable\n&gt;&gt;&gt; dt = DeltaTable(\"../rust/tests/data/delta-0.8.0-partitioned\")\n&gt;&gt;&gt; dt.schema().to_arrow()\nvalue: string\nyear: string\nmonth: string\nday: string\n&gt;&gt;&gt; dt.to_pandas(partitions=[(\"year\", \"=\", \"2021\")], columns=[\"value\"])\n      value\n0     6\n1     7\n2     5\n3     4\n&gt;&gt;&gt; dt.to_pyarrow_table(partitions=[(\"year\", \"=\", \"2021\")], columns=[\"value\"])\npyarrow.Table\nvalue: string\n</code></pre> <p>Converting to a PyArrow Dataset allows you to filter on columns other than partition columns and load the result as a stream of batches rather than a single table. Convert to a dataset using <code>DeltaTable.to_pyarrow_dataset</code>. Filters applied to datasets will use the partition values and file statistics from the Delta transaction log and push down any other filters to the scanning operation.</p> <pre><code>&gt;&gt;&gt; import pyarrow.dataset as ds\n&gt;&gt;&gt; dataset = dt.to_pyarrow_dataset()\n&gt;&gt;&gt; condition = (ds.field(\"year\") == \"2021\") &amp; (ds.field(\"value\") &gt; \"4\")\n&gt;&gt;&gt; dataset.to_table(filter=condition, columns=[\"value\"]).to_pandas()\n  value\n0     6\n1     7\n2     5\n&gt;&gt;&gt; batch_iter = dataset.to_batches(filter=condition, columns=[\"value\"], batch_size=2)\n&gt;&gt;&gt; for batch in batch_iter: print(batch.to_pandas())\n  value\n0     6\n1     7\n  value\n0     5\n</code></pre> <p>PyArrow datasets may also be passed to compatible query engines, such as DuckDB</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; ex_data = duckdb.arrow(dataset)\n&gt;&gt;&gt; ex_data.filter(\"year = 2021 and value &gt; 4\").project(\"value\")\n---------------------\n-- Expression Tree --\n---------------------\nProjection [value]\n  Filter [year=2021 AND value&gt;4]\n    arrow_scan(140409099470144, 4828104688, 1000000)\n\n---------------------\n-- Result Columns  --\n---------------------\n- value (VARCHAR)\n\n---------------------\n-- Result Preview  --\n---------------------\nvalue\nVARCHAR\n[ Rows: 3]\n6\n7\n5\n</code></pre> <p>Finally, you can always pass the list of file paths to an engine. For example, you can pass them to <code>dask.dataframe.read_parquet</code>:</p> <pre><code>&gt;&gt;&gt; import dask.dataframe as dd\n&gt;&gt;&gt; df = dd.read_parquet(dt.file_uris())\n&gt;&gt;&gt; df\nDask DataFrame Structure:\n                value             year            month              day\nnpartitions=6\n               object  category[known]  category[known]  category[known]\n                  ...              ...              ...              ...\n...               ...              ...              ...              ...\n                  ...              ...              ...              ...\n                  ...              ...              ...              ...\nDask Name: read-parquet, 6 tasks\n&gt;&gt;&gt; df.compute()\n  value  year month day\n0     1  2020     1   1\n0     2  2020     2   3\n0     3  2020     2   5\n0     4  2021     4   5\n0     5  2021    12   4\n0     6  2021    12  20\n1     7  2021    12  20\n</code></pre> <p>When working with the Rust API, Apache Datafusion can be used to query data from a delta table.</p> <pre><code>let table = deltalake::open_table(\"../rust/tests/data/delta-0.8.0-partitioned\").await?;\nlet ctx = SessionContext::new();\nctx.register_table(\"simple_table\", Arc::new(table.clone()))?;\nlet df = ctx.sql(\"SELECT value FROM simple_table WHERE year = 2021\").await?;\ndf.show().await?;\n</code></pre> <p>Apache Datafusion also supports a Dataframe interface than can be used instead of the SQL interface: <pre><code>let table = deltalake::open_table(\"../rust/tests/data/delta-0.8.0-partitioned\").await?;\nlet ctx = SessionContext::new();\nlet dataframe = ctx.read_table( Arc::new(table.clone()))?;\nlet df = dataframe.filter(col(\"year\").eq(lit(2021)))?.select(vec![col(\"value\")])?;\ndf.show().await?;\n</code></pre></p>"},{"location":"usage/read-cdf/","title":"Reading the Change Data Feed from a Delta Table","text":"<p>Reading the CDF data from a table with change data is easy.</p> <p>The <code>delta.enableChangeDataFeed</code> configuration needs to be set to <code>true</code> when creating the delta table.</p>"},{"location":"usage/read-cdf/#reading-cdf-log","title":"Reading CDF Log","text":"Python Rust <pre><code>import polars\nfrom deltalake import DeltaTable\n\ndt = DeltaTable(\"../rust/tests/data/cdf-table\")\ntable = dt.load_cdf(starting_version=0, ending_version=4).read_all()\npt = polars.from_arrow(table)\npt.group_by(\"_commit_version\").len().sort(\"len\", descending=True)\n</code></pre> <pre><code>#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n\n    let table = deltalake::open_table(\"tmp/some-table\").await?;\n    let ctx = SessionContext::new();\n    let ops = DeltaOps(table);\n    let cdf = ops\n        .load_cdf()\n        .with_starting_version(0)\n        .with_ending_version(4)\n        .build()\n        .await?;\n\n    let batches = collect_batches(\n        cdf.properties().output_partitioning().partition_count(),\n        &amp;cdf,\n        ctx,\n    ).await?;\n    arrow_cast::pretty::print_batches(&amp;batches)?;\n\n\n    Ok(())\n}\n\nasync fn collect_batches(\n    num_partitions: usize,\n    stream: &amp;impl ExecutionPlan,\n    ctx: SessionContext,\n) -&gt; Result&lt;Vec&lt;RecordBatch&gt;, Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut batches = vec![];\n    for p in 0..num_partitions {\n        let data: Vec&lt;RecordBatch&gt; =\n            collect_sendable_stream(stream.execute(p, ctx.task_ctx())?).await?;\n        batches.extend_from_slice(&amp;data);\n    }\n    Ok(batches)\n}\n</code></pre> <p>The output can then be used in various execution engines. The python example shows how one might consume the cdf feed inside polars.</p>"},{"location":"usage/optimize/delta-lake-z-order/","title":"Delta Lake Z Order","text":"<p>This section explains how to Z Order a Delta table.</p> <p>Z Ordering colocates similar data in the same files, which allows for better file skipping and faster queries.</p> <p>Suppose you have a table with <code>first_name</code>, <code>age</code>, and <code>country</code> columns.</p> <p>If you Z Order the data by the <code>country</code> column, then individuals from the same country will be stored in the same files.  When you subquently query the data for individuals from a given country, it will execute faster because more data can be skipped.</p> <p>Here's how to Z Order a Delta table:</p> PythonRust <pre><code>dt = DeltaTable(\"tmp\")\ndt.optimize.z_order([\"country\"])\n</code></pre> <pre><code>let table = open_table(\"tmp\").await?;    \n\nlet (table, metrics) = DeltaOps(table)\n    .optimize()\n    .with_type(OptimizeType::ZOrder(vec![\"country\".to_string()]))\n    .await?;\nprintln!(\"{:?}\", metrics);\n</code></pre>"},{"location":"usage/optimize/small-file-compaction-with-optimize/","title":"Delta Lake small file compaction with optimize","text":"<p>This post shows you how to perform small file compaction with using the <code>optimize</code> method.  This was added to the <code>DeltaTable</code> class in version 0.9.0.  This command rearranges the small files into larger files which will reduce the number of files and speed up queries.</p> <p>This is very helpful for workloads that append frequently. For example, if you have a table that is appended to every 10 minutes, after a year you will have 52,560 files in the table. If the table is partitioned by another dimension, you will have 52,560 files per partition; with just 100 unique values that's millions of files. By running <code>optimize</code> periodically, you can reduce the number of files in the table to a more manageable number.</p> <p>Typically, you will run optimize less frequently than you append data. If possible, you might run optimize once you know you have finished writing to a particular partition. For example, on a table partitioned by date, you might append data every 10 minutes, but only run optimize once a day at the end of the day. This will ensure you don't need to compact the same data twice.</p> <p>This section will also teach you about how to use <code>vacuum</code> to physically remove files from storage that are no longer needed.  You\u2019ll often want vacuum after running optimize to remove the small files from storage once they\u2019ve been compacted into larger files.</p> <p>Let\u2019s start with an example to explain these key concepts.  All the code covered in this post is stored in this notebook in case you\u2019d like to follow along.</p>"},{"location":"usage/optimize/small-file-compaction-with-optimize/#create-a-delta-table-with-small-files","title":"Create a Delta table with small files","text":"<p>Let\u2019s start by creating a Delta table with a lot of small files so we can demonstrate the usefulness of the <code>optimize</code> command.</p> <p>Start by writing a function that generates on thousand rows of random data given a timestamp.</p> PythonRust <pre><code>def record_observations(date: datetime) -&gt; pa.Table:\n    \"\"\"Pulls data for a certain datetime\"\"\"\n    nrows = 1000\n    return pa.table(\n        {\n            \"date\": pa.array([date.date()] * nrows),\n            \"timestamp\": pa.array([date] * nrows),\n            \"value\": pc.random(nrows),\n        }\n    )\n</code></pre> <pre><code>pub fn record_observations(timestamp: DateTime&lt;Utc&gt;) -&gt; RecordBatch {\n    let nrows = 1000;\n    let date = timestamp.date_naive();\n    let timestamp = timestamp;\n    let value = (0..nrows)\n        .map(|_| rand::random::&lt;f64&gt;())\n        .collect::&lt;Vec&lt;f64&gt;&gt;();\n    let date = (0..nrows).map(|_| date).collect::&lt;Vec&lt;NaiveDate&gt;&gt;();\n    let timestamp = (0..nrows)\n        .map(|_| timestamp.timestamp_micros())\n        .collect::&lt;Vec&lt;i64&gt;&gt;();\n\n    let schema = Schema::new(vec![\n        Field::new(\"date\", arrow::datatypes::DataType::Date32, false),\n        Field::new(\n            \"timestamp\",\n            arrow::datatypes::DataType::Timestamp(TimeUnit::Microsecond, Some(\"UTC\".to_string().into())),\n            false,\n        ),\n        Field::new(\"value\", arrow::datatypes::DataType::Float64, false),\n    ]);\n\n    RecordBatch::try_new(\n        Arc::new(schema),\n        vec![\n            Arc::new(Date32Array::from(\n                date.iter()\n                    .map(|d| Date32Type::from_naive_date(*d))\n                    .collect::&lt;Vec&lt;i32&gt;&gt;(),\n            )),\n            Arc::new(TimestampMicrosecondArray::from(timestamp).with_timezone(\"UTC\")),\n            Arc::new(Float64Array::from(value)),\n        ],\n    )\n    .unwrap()\n}\n</code></pre> <p>Let\u2019s run this function and observe the output:</p> PythonRust <pre><code>record_observations(datetime(2021, 1, 1, 12)).to_pandas()\n\n  date              timestamp   value\n0   2021-01-01  2021-01-01 12:00:00 0.3186397383362023\n1   2021-01-01  2021-01-01 12:00:00 0.04253766974259088\n2   2021-01-01  2021-01-01 12:00:00 0.9355682965171573\n\u2026\n999 2021-01-01  2021-01-01 12:00:00 0.23207037062879843\n</code></pre> <pre><code>let batch = record_observations(\"2021-01-01T12:00:00Z\".parse::&lt;DateTime&lt;Utc&gt;&gt;().unwrap());\nprintln!(\"{}\", pretty_format_batches(&amp;vec![batch])?);\n// +------------+---------------------+------------------------+\n// | date       | timestamp           | value                  |\n// +------------+---------------------+------------------------+\n// | 2021-01-01 | 2021-01-01T12:00:00 | 0.4061923494886005     |\n// | 2021-01-01 | 2021-01-01T12:00:00 | 0.9987878410434536     |\n// | 2021-01-01 | 2021-01-01T12:00:00 | 0.5731950954440364     |\n// | 2021-01-01 | 2021-01-01T12:00:00 | 0.44535166836074713    |\n// | 2021-01-01 | 2021-01-01T12:00:00 | 0.7122994421129841     |\n// | 2021-01-01 | 2021-01-01T12:00:00 | 0.09947198303405769    |\n// | 2021-01-01 | 2021-01-01T12:00:00 | 0.02835490232344251    |\n// | 2021-01-01 | 2021-01-01T12:00:00 | 0.565059582551305      |\n// | 2021-01-01 | 2021-01-01T12:00:00 | 0.2149121627261419     |\n// ...\n</code></pre> <p>Let\u2019s write 100 hours worth of data to the Delta table.</p> PythonRust <pre><code># Every hour starting at midnight on 2021-01-01\nhours_iter = (datetime(2021, 1, 1) + timedelta(hours=i) for i in itertools.count())\n\n# Write 100 hours worth of data\nfor timestamp in itertools.islice(hours_iter, 100):\n    write_deltalake(\n        \"observation_data\",\n        record_observations(timestamp),\n        partition_by=[\"date\"],\n        mode=\"append\",\n    )\n</code></pre> <pre><code>let mut table = DeltaOps::try_from_uri(\"observation_data\")\n  .await?\n  .create()\n  .with_table_name(\"observations_data\")\n  .with_columns(\n      StructType::new(vec![\n          StructField::new(\n              \"date\".to_string(),\n              DataType::Primitive(PrimitiveType::Date),\n              false,\n          ),\n          StructField::new(\n              \"timestamp\".to_string(),\n              DataType::Primitive(PrimitiveType::Timestamp),\n              false,\n          ),\n          StructField::new(\n              \"value\".to_string(),\n              DataType::Primitive(PrimitiveType::Double),\n              false,\n          ),\n      ])\n      .fields()\n      .cloned(),\n  )\n  .with_partition_columns(vec![\"date\"])\n  .with_save_mode(SaveMode::Append)\n  .await?;\n\nlet hours_iter = (0..).map(|i| {\n    \"2021-01-01T00:00:00Z\".parse::&lt;DateTime&lt;Utc&gt;&gt;().unwrap() + chrono::Duration::hours(i)\n});\n\n// write 100 hours worth of data\nfor timestamp in hours_iter.take(100) {\n    let batch = record_observations(timestamp);\n    let mut writer =  deltalake::writer::RecordBatchWriter::for_table(&amp;table)?;\n    writer\n        .write(batch)\n        .await?;\n    writer.flush_and_commit(&amp;mut table).await?;\n}\n</code></pre> <p>This data was appended to the Delta table in 100 separate transactions, so the table will contain 100 transaction log entries and 100 data files.  You can see the number of files with the <code>files()</code> method.</p> PythonRust <pre><code>dt = DeltaTable(\"observation_data\")\nlen(dt.files()) # 100\n</code></pre> <pre><code>let table = open_table(\"observation_data\").await?;\nlet files = table.get_files_iter()?;\nprintln!(\"len: {}\", files.count()); // len: 100\n</code></pre> <p>Here\u2019s how the files are persisted in storage.</p> <pre><code>observation_data\n\u251c\u2500\u2500 _delta_log\n\u2502   \u251c\u2500\u2500 00000000000000000000.json\n\u2502   \u251c\u2500\u2500 \u2026\n\u2502   \u2514\u2500\u2500 00000000000000000099.json\n\u251c\u2500\u2500 date=2021-01-01\n\u2502   \u251c\u2500\u2500 0-cfe227c6-edd9-4369-a1b0-db4559a2e693-0.parquet\n\u2502   \u251c\u2500\u2500 \u2026\n\u2502   \u251c\u2500\u2500 23-a4ace29e-e73e-40a1-81d3-0f5dc13093de-0.parquet\n\u251c\u2500\u2500 date=2021-01-02\n\u2502   \u251c\u2500\u2500 24-9698b456-66eb-4075-8732-fe56d81edb60-0.parquet\n\u2502   \u251c\u2500\u2500 \u2026\n\u2502   \u2514\u2500\u2500 47-d3fce527-e018-4c02-8acd-a649f6f523d2-0.parquet\n\u251c\u2500\u2500 date=2021-01-03\n\u2502   \u251c\u2500\u2500 48-fd90a7fa-5a14-42ed-9f59-9fe48d87899d-0.parquet\n\u2502   \u251c\u2500\u2500 \u2026\n\u2502   \u2514\u2500\u2500 71-5f143ade-8ae2-4854-bdc5-61154175665f-0.parquet\n\u251c\u2500\u2500 date=2021-01-04\n\u2502   \u251c\u2500\u2500 72-477c10fe-dc09-4087-80f0-56006e4a7911-0.parquet\n\u2502   \u251c\u2500\u2500 \u2026\n\u2502   \u2514\u2500\u2500 95-1c92cbce-8af4-4fe4-9c11-832245cf4d40-0.parquet\n\u2514\u2500\u2500 date=2021-01-05\n    \u251c\u2500\u2500 96-1b878ee5-25fd-431a-bc3e-6dcacc96b470-0.parquet\n    \u251c\u2500\u2500 \u2026\n    \u2514\u2500\u2500 99-9650ed63-c195-433d-a86b-9469088c14ba-0.parquet\n</code></pre> <p>Each of these Parquet files are tiny - they\u2019re only 10 KB.  Let\u2019s see how to compact these tiny files into larger files, which is more efficient for data queries.</p>"},{"location":"usage/optimize/small-file-compaction-with-optimize/#compact-small-files-in-the-delta-table-with-optimize","title":"Compact small files in the Delta table with optimize","text":"<p>Let\u2019s run the optimize command to compact the existing small files into larger files:</p> PythonRust <pre><code>dt = DeltaTable(\"observation_data\")\n\ndt.optimize.compact()\n</code></pre> <pre><code>let table = open_table(\"observation_data\").await?;\nlet (table, metrics) = DeltaOps(table).optimize().with_type(OptimizeType::Compact).await?;\nprintln!(\"{:?}\", metrics);\n</code></pre> <p>Here\u2019s the output of the command:</p> <pre><code>{'numFilesAdded': 5,\n 'numFilesRemoved': 100,\n 'filesAdded': {'min': 39000,\n  'max': 238282,\n  'avg': 198425.6,\n  'totalFiles': 5,\n  'totalSize': 992128},\n 'filesRemoved': {'min': 10244,\n  'max': 10244,\n  'avg': 10244.0,\n  'totalFiles': 100,\n  'totalSize': 1024400},\n 'partitionsOptimized': 5,\n 'numBatches': 1,\n 'totalConsideredFiles': 100,\n 'totalFilesSkipped': 0,\n 'preserveInsertionOrder': True}\n</code></pre> <p>The optimize operation has added 5 new files and marked 100 existing files for removal (this is also known as \u201ctombstoning\u201d files).  It has compacted the 100 tiny files into 5 larger files.</p> <p>Let\u2019s append some more data to the Delta table and see how we can selectively run optimize on the new data that\u2019s added.</p>"},{"location":"usage/optimize/small-file-compaction-with-optimize/#handling-incremental-updates-with-optimize","title":"Handling incremental updates with optimize","text":"<p>Let\u2019s append another 24 hours of data to the Delta table:</p> PythonRust <pre><code>for timestamp in itertools.islice(hours_iter, 24):\n    write_deltalake(\n        dt,\n        record_observations(timestamp),\n        partition_by=[\"date\"],\n        mode=\"append\",\n    )\n</code></pre> <pre><code>let mut table = open_table(\"observation_data\").await?;\nlet hours_iter = (0..).map(|i| {\n    \"2021-01-01T00:00:00Z\".parse::&lt;DateTime&lt;Utc&gt;&gt;().unwrap() + chrono::Duration::hours(i)\n});\nfor timestamp in hours_iter.skip(100).take(24) {\n    let batch = record_observations(timestamp);\n    let mut writer =  deltalake::writer::RecordBatchWriter::for_table(&amp;table)?;\n    writer\n        .write(batch)\n        .await?;\n    writer.flush_and_commit(&amp;mut table).await?;\n}\n</code></pre> <p>We can use <code>get_add_actions()</code> to introspect the table state. We can see that <code>2021-01-06</code> has only a few hours of data so far, so we don't want to optimize that yet. But <code>2021-01-05</code> has all 24 hours of data, so it's ready to be optimized.</p> PythonRust <pre><code>dt.get_add_actions(flatten=True).to_pandas()[\n    \"partition.date\"\n].value_counts().sort_index()\n\n2021-01-01     1\n2021-01-02     1\n2021-01-03     1\n2021-01-04     1\n2021-01-05    21\n2021-01-06     4\n</code></pre> <pre><code>let table = open_table(\"observation_data\").await?;\nlet batch = table.snapshot()?.add_actions_table(true)?;\nlet ctx = SessionContext::new();\nctx.register_batch(\"observations\", batch.clone())?;\nlet df = ctx.sql(\"\nSELECT \\\"partition.date\\\",\n        COUNT(*)\nFROM observations\nGROUP BY \\\"partition.date\\\"\nORDER BY \\\"partition.date\\\"\").await?;\ndf.show().await?;\n\n\n+----------------+----------+\n| partition.date | count(*) |\n+----------------+----------+\n| 2021-01-01     | 1        |\n| 2021-01-02     | 1        |\n| 2021-01-03     | 1        |\n| 2021-01-04     | 1        |\n| 2021-01-05     | 21       |\n| 2021-01-06     | 4        |\n+----------------+----------+\n</code></pre> <p>To optimize a single partition, you can pass in a <code>partition_filters</code> argument specifying which partitions to optimize.</p> PythonRust <pre><code>dt.optimize.compact(partition_filters=[(\"date\", \"=\", \"2021-01-05\")])\n</code></pre> <pre><code>  let table = open_table(\"observation_data\").await?;\n  let (table, metrics) = DeltaOps(table)\n      .optimize()\n      .with_type(OptimizeType::Compact)\n      .with_filters(&amp;vec![(\"date\", \"=\", \"2021-01-05\").try_into()?])\n      .await?;\n  println!(\"{:?}\", metrics);\n</code></pre> <pre><code>{'numFilesAdded': 1,\n 'numFilesRemoved': 21,\n 'filesAdded': {'min': 238282,\n  'max': 238282,\n  'avg': 238282.0,\n  'totalFiles': 1,\n  'totalSize': 238282},\n 'filesRemoved': {'min': 10244,\n  'max': 39000,\n  'avg': 11613.333333333334,\n  'totalFiles': 21,\n  'totalSize': 243880},\n 'partitionsOptimized': 1,\n 'numBatches': 1,\n 'totalConsideredFiles': 21,\n 'totalFilesSkipped': 0,\n 'preserveInsertionOrder': True}\n</code></pre> <p>This optimize operation tombstones 21 small data files and adds one file with all the existing data properly condensed.  Let\u2019s take a look a portion of the <code>_delta_log/00000000000000000125.json</code> file, which is the transaction log entry that corresponds with this incremental optimize command.</p> <pre><code>{\n  \"remove\": {\n    \"path\": \"date=2021-01-05/part-00000-41178aab-2491-488f-943d-8f03867295ee-c000.snappy.parquet\",\n    \"deletionTimestamp\": 1683465499480,\n    \"dataChange\": false,\n    \"extendedFileMetadata\": null,\n    \"partitionValues\": {\n      \"date\": \"2021-01-05\"\n    },\n    \"size\": 39000,\n    \"tags\": null\n  }\n}\n\n{\n  \"remove\": {\n    \"path\": \"date=2021-01-05/101-79ae6fc9-c0cc-49ec-bb94-9aba879ac949-0.parquet\",\n    \"deletionTimestamp\": 1683465499481,\n    \"dataChange\": false,\n    \"extendedFileMetadata\": null,\n    \"partitionValues\": {\n      \"date\": \"2021-01-05\"\n    },\n    \"size\": 10244,\n    \"tags\": null\n  }\n}\n\n\u2026\n\n{\n  \"add\": {\n    \"path\": \"date=2021-01-05/part-00000-4b020a40-c836-4a11-851f-4691370c9f3a-c000.snappy.parquet\",\n    \"size\": 238282,\n    \"partitionValues\": {\n      \"date\": \"2021-01-05\"\n    },\n    \"modificationTime\": 1683465499493,\n    \"dataChange\": false,\n    \"stats\": \"{\\\"numRecords\\\":24000,\\\"minValues\\\":{\\\"value\\\":0.00005581532256615507,\\\"timestamp\\\":\\\"2021-01-05T00:00:00.000Z\\\"},\\\"maxValues\\\":{\\\"timestamp\\\":\\\"2021-01-05T23:00:00.000Z\\\",\\\"value\\\":0.9999911402868216},\\\"nullCount\\\":{\\\"timestamp\\\":0,\\\"value\\\":0}}\",\n    \"tags\": null\n  }\n}\n</code></pre> <p>The transaction log indicates that many files have been tombstoned and one file is added, as expected.</p> <p>The Delta Lake optimize command \u201cremoves\u201d data by marking the data files as removed in the transaction log. The optimize command doesn\u2019t physically delete the Parquet file from storage. Optimize performs a \u201clogical remove\u201d not a \u201cphysical remove\u201d.</p> <p>Delta Lake uses logical operations so you can time travel back to earlier versions of your data.  You can vacuum your Delta table to physically remove Parquet files from storage if you don\u2019t need to time travel and don\u2019t want to pay to store the tombstoned files.</p>"},{"location":"usage/optimize/small-file-compaction-with-optimize/#vacuuming-after-optimizing","title":"Vacuuming after optimizing","text":"<p>The vacuum command deletes all files from storage that are marked for removal in the transaction log and older than the retention period which is 7 days by default.</p> <p>It\u2019s normally a good idea to have a retention period of at least 7 days.  For purposes of this example, we will set the retention period to zero, just so you can see how the files get removed from storage.  Adjusting the retention period in this manner isn\u2019t recommended for production use cases.</p> <p>Let\u2019s run the vacuum command:</p> PythonRust <pre><code>dt.vacuum(retention_hours=0, enforce_retention_duration=False, dry_run=False)\n</code></pre> <pre><code>let table = open_table(\"observation_data\").await?;\nlet (table, metrics) = DeltaOps(table)\n    .vacuum()\n    .with_retention_period(chrono::Duration::days(0))\n    .with_enforce_retention_duration(false)\n    .with_dry_run(false)\n    .await?;\nprintln!(\"{:?}\", metrics);\n</code></pre> <p>The command returns a list of all the files that are removed from storage:</p> <pre><code>['date=2021-01-02/39-a98680f2-0e0e-4f26-a491-18b183f9eb05-0.parquet',\n 'date=2021-01-02/41-e96bc8bb-c571-484c-b534-e897424fb7da-0.parquet',\n \u2026\n 'date=2021-01-01/0-cfe227c6-edd9-4369-a1b0-db4559a2e693-0.parquet',\n 'date=2021-01-01/18-ded53418-172b-4e40-bf2e-7c8142e71bd1-0.parquet']\n</code></pre> <p>Let\u2019s look at the content of the Delta table now that all the really small files have been removed from storage:</p> <pre><code>observation_data\n\u251c\u2500\u2500 _delta_log\n\u2502   \u251c\u2500\u2500 00000000000000000000.json\n\u2502   \u251c\u2500\u2500 00000000000000000001.json\n\u2502   \u251c\u2500\u2500 \u2026\n\u2502   \u251c\u2500\u2500 00000000000000000124.json\n\u2502   \u2514\u2500\u2500 00000000000000000125.json\n\u251c\u2500\u2500 date=2021-01-01\n\u2502   \u2514\u2500\u2500 part-00000-31e3df5a-8bbe-425c-b85d-77794f922837-c000.snappy.parquet\n\u251c\u2500\u2500 date=2021-01-02\n\u2502   \u2514\u2500\u2500 part-00000-8af07878-b179-49ce-a900-d58595ffb60a-c000.snappy.parquet\n\u251c\u2500\u2500 date=2021-01-03\n\u2502   \u2514\u2500\u2500 part-00000-5e980864-b32f-4686-a58d-a75fae455c1e-c000.snappy.parquet\n\u251c\u2500\u2500 date=2021-01-04\n\u2502   \u2514\u2500\u2500 part-00000-1e82d23b-084d-47e3-9790-d68289c39837-c000.snappy.parquet\n\u251c\u2500\u2500 date=2021-01-05\n\u2502   \u2514\u2500\u2500 part-00000-4b020a40-c836-4a11-851f-4691370c9f3a-c000.snappy.parquet\n\u2514\u2500\u2500 date=2021-01-06\n    \u251c\u2500\u2500 121-0ecb5d70-4a28-4cd4-b2d2-89ee2285eaaa-0.parquet\n    \u251c\u2500\u2500 122-6b2d2758-9154-4392-b287-fe371ee507ec-0.parquet\n    \u251c\u2500\u2500 123-551d318f-4968-441f-83fc-89f98cd15daf-0.parquet\n    \u2514\u2500\u2500 124-287309d3-662e-449d-b4da-2e67b7cc0557-0.parquet\n</code></pre> <p>All the partitions only contain a single file now, except for the <code>date=2021-01-06</code> partition that has not been compacted yet.</p> <p>An entire partition won\u2019t necessarily get compacted to a single data file when optimize is run.  Each partition has data files that are condensed to the target file size.</p>"},{"location":"usage/optimize/small-file-compaction-with-optimize/#what-causes-the-small-file-problem","title":"What causes the small file problem?","text":"<p>Delta tables can accumulate small files for a variety of reasons:</p> <ul> <li>User error: users can accidentally write files that are too small.  Users should sometimes repartition in memory before writing to disk to avoid appending files that are too small.</li> <li>Frequent appends: systems that append more often tend to append more smaller files.  A pipeline that appends every minute will generally generate ten times as many small files compared to a system that appends every ten minutes.</li> <li>Appending to partitioned data lakes with high cardinality columns can also cause small files.  If you append every hour to a table that\u2019s partitioned on a column with 1,000 distinct values, then every append could create 1,000 new files.  Partitioning by date avoids this problem because the data isn\u2019t split up across partitions in this manner.</li> </ul>"},{"location":"usage/optimize/small-file-compaction-with-optimize/#conclusion","title":"Conclusion","text":"<p>This page showed you how to create a Delta table with many small files, compact the small files into larger files with optimize, and remove the tombstoned files from storage with vacuum.</p> <p>You also learned about how to incrementally optimize partitioned Delta tables, so you only compact newly added data.</p> <p>An excessive number of small files slows down Delta table queries, so periodic compaction is important.  Make sure to properly maintain your Delta tables, so performance does not degrade over time.</p>"},{"location":"usage/writing/","title":"Writing Delta Tables","text":"<p>For overwrites and appends, use <code>write_deltalake</code>. If the table does not already exist, it will be created. The <code>data</code> parameter will accept a Pandas DataFrame, a PyArrow Table, or an iterator of PyArrow Record Batches.</p> <pre><code>&gt;&gt;&gt; from deltalake import write_deltalake\n&gt;&gt;&gt; df = pd.DataFrame({'x': [1, 2, 3]})\n&gt;&gt;&gt; write_deltalake('path/to/table', df)\n</code></pre> <p>Note: <code>write_deltalake</code> accepts a Pandas DataFrame, but will convert it to a Arrow table before writing. See caveats in <code>pyarrow:python/pandas</code>.</p> <p>By default, writes create a new table and error if it already exists. This is controlled by the <code>mode</code> parameter, which mirrors the behavior of Spark's <code>pyspark.sql.DataFrameWriter.saveAsTable</code> DataFrame method. To overwrite pass in <code>mode='overwrite'</code> and to append pass in <code>mode='append'</code>:</p> <pre><code>&gt;&gt;&gt; write_deltalake('path/to/table', df, mode='overwrite')\n&gt;&gt;&gt; write_deltalake('path/to/table', df, mode='append')\n</code></pre> <p><code>write_deltalake</code> will raise <code>ValueError</code> if the schema of the data passed to it differs from the existing table's schema. If you wish to alter the schema as part of an overwrite pass in <code>schema_mode=\"overwrite\"</code> or <code>schema_mode=\"merge\"</code>. <code>schema_mode=\"overwrite\"</code> will completely overwrite the schema, even if columns are dropped; merge will append the new columns and fill missing columns with <code>null</code>. <code>schema_mode=\"merge\"</code> is also supported on append operations.</p>"},{"location":"usage/writing/#overwriting-a-partition","title":"Overwriting a partition","text":"<p>You can overwrite a specific partition by using <code>mode=\"overwrite\"</code> together with <code>partition_filters</code>. This will remove all files within the matching partition and insert your data as new files. This can only be done on one partition at a time. All the input data must belong to that partition or else the method will raise an error.</p> <pre><code>&gt;&gt;&gt; from deltalake import write_deltalake\n&gt;&gt;&gt; df = pd.DataFrame({'x': [1, 2, 3], 'y': ['a', 'a', 'b']})\n&gt;&gt;&gt; write_deltalake('path/to/table', df, partition_by=['y'])\n\n&gt;&gt;&gt; table = DeltaTable('path/to/table')\n&gt;&gt;&gt; df2 = pd.DataFrame({'x': [100], 'y': ['b']})\n&gt;&gt;&gt; write_deltalake(table, df2, partition_filters=[('y', '=', 'b')], mode=\"overwrite\")\n\n&gt;&gt;&gt; table.to_pandas()\n     x  y\n0    1  a\n1    2  a\n2  100  b\n</code></pre> <p>This method could also be used to insert a new partition if one doesn't already exist, making this operation idempotent.</p>"},{"location":"usage/writing/#overwriting-part-of-the-table-data-using-a-predicate","title":"Overwriting part of the table data using a predicate","text":"<p>Note</p> <p>This predicate is often called a <code>replaceWhere</code> predicate</p> <p>When you don\u2019t specify the <code>predicate</code>, the overwrite save mode will replace the entire table. Instead of replacing the entire table (which is costly!), you may want to overwrite only the specific parts of the table that should be changed. In this case, you can use a <code>predicate</code> to overwrite only the relevant records or partitions.</p> <p>Note</p> <p>Data written must conform to the same predicate, i.e. not contain any records that don't match the <code>predicate</code> condition, otherwise the operation will fail</p>  Python Rust <p> <code>replaceWhere</code> <pre><code>import pyarrow as pa\nfrom deltalake import write_deltalake\n\n# Assuming there is already a table in this location with some records where `id = '1'` which we want to overwrite\ntable_path = \"/tmp/my_table\"\ndata = pa.table(\n    {\n        \"id\": pa.array([\"1\", \"1\"], pa.string()),\n        \"value\": pa.array([11, 12], pa.int64()),\n    }\n)\nwrite_deltalake(\n    table_path,\n    data,\n    mode=\"overwrite\",\n    predicate=\"id = '1'\",\n)\n</code></pre></p> <p> <code>replaceWhere</code> <pre><code>// Assuming there is already a table in this location with some records where `id = '1'` which we want to overwrite\nuse arrow_array::RecordBatch;\nuse arrow_schema::{DataType, Field, Schema as ArrowSchema};\nuse deltalake::datafusion::logical_expr::{col, lit};\nuse deltalake::protocol::SaveMode;\nuse deltalake::DeltaOps;\n\nlet schema = ArrowSchema::new(vec![\n    Field::new(\"id\", DataType::Utf8, true),\n    Field::new(\"value\", DataType::Int32, true),\n]);\n\nlet data = RecordBatch::try_new(\n    schema.into(),\n    vec![\n        Arc::new(arrow::array::StringArray::from(vec![\"1\", \"1\"])),\n        Arc::new(arrow::array::Int32Array::from(vec![11, 12])),\n    ],\n)\n.unwrap();\n\nlet table = deltalake::open_table(\"/tmp/my_table\").await.unwrap();\nlet _table = DeltaOps(table)\n    .write(vec![data])\n    .with_save_mode(SaveMode::Overwrite)\n    .with_replace_where(col(\"id\").eq(lit(\"1\")))\n    .await\n    .unwrap();\n</code></pre></p>"},{"location":"usage/writing/#using-writer-properties","title":"Using Writer Properties","text":"<p>You can customize the Rust Parquet writer by using the WriterProperties. Additionally, you can apply extra configurations through the BloomFilterProperties and ColumnProperties data classes.</p> <p>Here's how you can do it: <pre><code>from deltalake import BloomFilterProperties, ColumnProperties, WriterProperties, write_deltalake\nimport pyarrow as pa\n\nwp = WriterProperties(\n        statistics_truncate_length=200,\n        default_column_properties=ColumnProperties(\n            bloom_filter_properties=BloomFilterProperties(True, 0.2, 30)\n        ),\n        column_properties={\n            \"value_non_bloom\": ColumnProperties(bloom_filter_properties=None),\n        },\n    )\n\ntable_path = \"/tmp/my_table\"\n\ndata = pa.table(\n        {\n            \"id\": pa.array([\"1\", \"1\"], pa.string()),\n            \"value\": pa.array([11, 12], pa.int64()),\n            \"value_non_bloom\": pa.array([11, 12], pa.int64()),\n        }\n    )\n\nwrite_deltalake(table_path, data, writer_properties=wp)\n</code></pre></p>"},{"location":"usage/writing/writing-to-s3-with-locking-provider/","title":"Writing to S3 with a locking provider","text":"<p>Delta lake guarantees ACID transactions when writing data. This is done by default when writing to all supported object stores except AWS S3. (Some S3 clients like CloudFlare R2 or MinIO may enable concurrent writing without a locking provider, refer to this section for more information).</p> <p>When writing to S3, delta-rs provides a locking mechanism to ensure that concurrent writes are safe. This is done by default when writing to S3, but you can opt-out by setting the <code>AWS_S3_ALLOW_UNSAFE_RENAME</code> variable to <code>true</code>.</p> <p>To enable safe concurrent writes to AWS S3, we must provide an external locking mechanism.</p>"},{"location":"usage/writing/writing-to-s3-with-locking-provider/#dynamodb","title":"DynamoDB","text":"<p>DynamoDB is the only available locking provider at the moment in delta-rs. To enable DynamoDB as the locking provider, you need to set the <code>AWS_S3_LOCKING_PROVIDER</code> to 'dynamodb' as a <code>storage_options</code> or as an environment variable.</p> <p>Additionally, you must create a DynamoDB table with the name <code>delta_log</code> so that it can be automatically recognized by delta-rs. Alternatively, you can use a table name of your choice, but you must set the <code>DELTA_DYNAMO_TABLE_NAME</code> variable to match your chosen table name. The required schema for the DynamoDB table is as follows:</p> <pre><code>\"Table\": {\n    \"AttributeDefinitions\": [\n        {\n            \"AttributeName\": \"fileName\",\n            \"AttributeType\": \"S\"\n        },\n        {\n            \"AttributeName\": \"tablePath\",\n            \"AttributeType\": \"S\"\n        }\n    ],\n    \"TableName\": \"delta_log\",\n    \"KeySchema\": [\n        {\n            \"AttributeName\": \"tablePath\",\n            \"KeyType\": \"HASH\"\n        },\n        {\n            \"AttributeName\": \"fileName\",\n            \"KeyType\": \"RANGE\"\n        }\n    ],\n}\n</code></pre> <p>Here is an example writing to s3 using this mechanism:</p> <pre><code>from deltalake import write_deltalake\ndf = pd.DataFrame({'x': [1, 2, 3]})\nstorage_options = {\n    'AWS_S3_LOCKING_PROVIDER': 'dynamodb',\n    'DELTA_DYNAMO_TABLE_NAME': 'custom_table_name'\n}\nwrite_deltalake(\n    's3a://path/to/table',\n    df,\n    storage_options=storage_options\n)\n</code></pre> <p>This locking mechanism is compatible with the one used by Apache Spark. The <code>tablePath</code> property, denoting the root url of the delta table itself, is part of the primary key, and all writers intending to write to the same table must match this property precisely. In Spark, S3 URLs are prefixed with <code>s3a://</code>, and a table in delta-rs must be configured accordingly.</p> <p>Note that <code>delta-rs</code> does not read credentials from your local <code>.aws/config</code> or <code>.aws/creds</code> file. Credentials can be accessed from environment variables, ec2 metadata, profiles or web identity. You can pass credentials to <code>storage_options</code> using <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code>.</p> <p>To use a custom endpoint (e.g., LocalStack), set <code>AWS_ENDPOINT_URL_DYNAMODB</code> in the <code>storage_options</code>.</p> <p>The following code allows creating the necessary DynamoDB table from the AWS cli:</p> <pre><code>aws dynamodb create-table \\\n--table-name delta_log \\\n--attribute-definitions AttributeName=tablePath,AttributeType=S AttributeName=fileName,AttributeType=S \\\n--key-schema AttributeName=tablePath,KeyType=HASH AttributeName=fileName,KeyType=RANGE \\\n--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5\n</code></pre> <p>You can find additional information in the Delta Lake documentation, which also includes recommendations on configuring a time-to-live (TTL) for the table to avoid growing the table indefinitely.</p>"},{"location":"usage/writing/writing-to-s3-with-locking-provider/#override-dynamodb-config","title":"Override DynamoDB config","text":"<p>In some cases, you may want to override the default DynamoDB configuration. For instance, you use an S3-compatible storage on another cloud provider which is not AWS. Or you need to have another set of credentials for DynamoDB. In this case, you can configure the <code>storage_options</code> with extra environment variables:</p> <ul> <li><code>AWS_ENDPOINT_URL_DYNAMODB</code> overrides <code>AWS_ENDPOINT_URL</code>,</li> <li><code>AWS_REGION_DYNAMODB</code> overrides <code>AWS_REGION</code>,</li> <li><code>AWS_ACCESS_KEY_ID_DYNAMODB</code> overrides <code>AWS_ACCESS_KEY_ID</code>,</li> <li><code>AWS_SECRET_ACCESS_KEY_DYNAMODB</code> overrides <code>AWS_SECRET_ACCESS_KEY</code>.</li> </ul> <p>Example:</p> <pre><code>from deltalake import write_deltalake\ndf = pd.DataFrame({'x': [1, 2, 3]})\nstorage_options = {\n    \"endpoint_url\": \"https://&lt;your-s3-compatible-storage&gt;\",\n    \"REGION\": \"&lt;s3-region&gt;\",\n    \"AWS_ACCESS_KEY_ID\": \"&lt;s3-access-key-id&gt;\",\n    \"AWS_SECRET_ACCESS_KEY\": \"&lt;s3-secret-access-key&gt;\",\n    # override dynamodb config\n    \"AWS_S3_LOCKING_PROVIDER\": \"dynamodb\",\n    \"AWS_ENDPOINT_URL_DYNAMODB\": \"https://dynamodb.&lt;dynamodb-region&gt;.amazonaws.com\",\n    \"AWS_REGION_DYNAMODB\": \"&lt;dynamodb-region&gt;\",\n    \"AWS_ACCESS_KEY_ID_DYNAMODB\": \"&lt;dynamodb-access-key-id&gt;\",\n    \"AWS_SECRET_ACCESS_KEY_DYNAMODB\": \"&lt;dynamodb-secret-access-key&gt;\",\n}\nwrite_deltalake(\n    's3a://path/to/table',\n    df,\n    storage_options=storage_options\n)\n</code></pre>"},{"location":"usage/writing/writing-to-s3-with-locking-provider/#enable-unsafe-writes-in-s3-opt-in","title":"Enable unsafe writes in S3 (opt-in)","text":"<p>If for some reason you don't want to use dynamodb as your locking mechanism you can choose to set the <code>AWS_S3_ALLOW_UNSAFE_RENAME</code> variable to <code>true</code> in order to enable S3 unsafe writes.</p>"},{"location":"usage/writing/writing-to-s3-with-locking-provider/#required-permissions","title":"Required permissions","text":"<p>You need to have permissions to get, put and delete objects in the S3 bucket you're storing your data in. Please note that you must be allowed to delete objects even if you're just appending to the deltalake, because there are temporary files into the log folder that are deleted after usage.</p> <p>In AWS, those would be the required permissions:</p> <ul> <li>s3:GetObject</li> <li>s3:PutObject</li> <li>s3:DeleteObject</li> </ul> <p>In DynamoDB, you need those permissions:</p> <ul> <li>dynamodb:GetItem</li> <li>dynamodb:Query</li> <li>dynamodb:PutItem</li> <li>dynamodb:UpdateItem</li> <li>dynamodb:DeleteItem</li> </ul>"},{"location":"usage/writing/writing-to-s3-with-locking-provider/#enabling-concurrent-writes-for-alternative-clients","title":"Enabling concurrent writes for alternative clients","text":"<p>Unlike AWS S3, some S3 clients support atomic renames by passing some headers in requests.</p> <p>For CloudFlare R2 or Minio passing this in the storage_options will enable concurrent writes:</p> <pre><code>storage_options = {\n    \"conditional_put\": \"etag\",\n}\n</code></pre>"}]}